{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"himena","text":"<p><code>himena</code> is an infinitely extensible and reusable applications framework for data science.</p>"},{"location":"#if-you-are-a-user","title":"If you are a user","text":"<ul> <li><code>himena</code> is implemented with many useful widgets and commands for data processing,   visualization, and analysis.</li> <li>Data is tagged with a workflow that makes your work   reproducible.</li> <li>You can save the process and the results of your work in a   session, which can be reopened later and shared.</li> </ul>"},{"location":"#if-you-are-a-plugin-developer","title":"If you are a plugin developer","text":"<ul> <li>Unlike most of the other applications, the plugins in <code>himena</code> extend each other. See   the plugin system to learn how this works.</li> </ul>"},{"location":"#source","title":"Source","text":"<p>Jump to GitHub repository.</p>"},{"location":"#index","title":"Index","text":"<ul> <li>Tutorial</li> <li>Developper's Guide</li> </ul>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#installation","title":"Installation","text":"<p><code>himena</code> is available on PyPI. You can install it with the recommended dependencies:</p> <pre><code>pip install himena[recommended]\n</code></pre> <p>or with the minimal dependencies:</p> <pre><code>pip install himena\n</code></pre>"},{"location":"tutorial/#start-application","title":"Start Application","text":"<p>After installation, you can start the application by running the <code>himena</code> command:</p> <pre><code>himena\n</code></pre> <p><code>himena</code> can manage multiple profiles. A profile is a set of configurations, color theme and plugins. You can create a new profile of name \"test\" with:</p> <pre><code>himena --new test\n</code></pre> <p>and start the application with the profile:</p> <pre><code>himena test\n</code></pre> <p>Note</p> <p>A profile can be used to separate the configurations for different users, or for different purposes. For example, you can have a profile \"img\" for image analysis, in which <code>himena img</code> is just like a sub-command of <code>himena</code>.</p>"},{"location":"tutorial/#open-a-data","title":"Open a Data","text":"<p>Let's start with a simple example. From the menubar, select <code>File &gt; New &gt; Seaborn &gt; iris</code>. This command will fetch the iris dataset online and open it as a subwindow.</p> <p></p> <p>In <code>himena</code>, a subwindow represents a single data model. For example, this iris dataset is opened as a \"table\" data model. <code>himena</code> automatically picked the table viewer widget to display the data.</p> <p>Of course, you can open a local file from <code>File &gt; Open File(s) ...</code> menu, Ctrl+O shortcut, drag-and-drop or directly paste the data from the clipboard.</p> <p>There are also several ways to create a new window. They are listed in <code>File &gt; New</code> menu, or you can use Ctrl+N shortcut to look for the available options.</p>"},{"location":"tutorial/#execute-commands","title":"Execute Commands","text":"<p>Many commands are registered on the startup of the application. There are several ways to run a command.</p>"},{"location":"tutorial/#window-menu-button","title":"Window Menu Button","text":"<p>The \"window menu button\" pops up a menu that contains the commands relevant to the operation on the current window. These commands are always available regardless of the data model the window represents. For example, \"Duplicate window\" and \"Copy path to cliboard\" are in the window menu.</p>"},{"location":"tutorial/#model-menu-button","title":"Model Menu Button","text":"<p>The \"model menu button\" pops up a menu that contains the commands relevant to the type of the underlying data model. For example, the \"Convert table to text\" is available in the window \"iris\" just opened above.</p>"},{"location":"tutorial/#command-palette","title":"Command Palette","text":"<p>All the commands are accessible from the command palette. Press Ctrl+Shift+P to open the command palette and you can search for any commands by the name.</p>"},{"location":"tutorial/#manage-plugins","title":"Manage Plugins","text":"<p><code>himena</code> is designed to be highly extensible. You can install plugins to add new IO supports, new widgets, and commands. For example, <code>himena-stats</code>, a himena plugin for statistical analysis, can be installed with the following lines.</p> <pre><code>pip install himena-stats -U  # install to the python virtual environment\nhimena --install himena-stats  # install the module to the default profile\nhimena your-profile-name --install himena-stats  # install to a specific profile\n</code></pre> <p>You can also select which plugins to be included in the <code>himena</code> profile from the setting dialog. A setting dialog can be opened from <code>File &gt; Settings ...</code> or shortcut Ctrl+,</p> <p></p>"},{"location":"tutorial/#the-python-interpreter-console","title":"The Python Interpreter Console","text":"<p>A built-in Qt console dock widget plugin is registered by default. You can oepn it by shortcut Ctrl+Shift+C.</p> <p></p>"},{"location":"api/consts/","title":"himena.consts","text":""},{"location":"api/consts/#himena.consts.MenuId","title":"<code>MenuId</code>","text":"<p>Preset of menu IDs.</p> Source code in <code>src\\himena\\consts.py</code> <pre><code>class MenuId(StrEnum):\n    \"\"\"Preset of menu IDs.\"\"\"\n\n    FILE = \"file\"\n    FILE_RECENT = \"file/recent\"\n    FILE_NEW = \"file/new\"\n    FILE_SCREENSHOT = \"file/screenshot\"\n    FILE_SESSION = \"file/session\"\n    WINDOW = \"window\"\n    WINDOW_RESIZE = \"window/resize\"\n    WINDOW_ALIGN = \"window/align\"\n    WINDOW_ANCHOR = \"window/anchor\"\n    WINDOW_NTH = \"window/nth\"\n    VIEW = \"view\"\n    VIEW_LAYOUT = \"view/layout\"\n\n    # \"Tools\" menu\n    TOOLS = \"tools\"\n    TOOLS_DOCK = \"tools/dock\"\n    \"\"\"Menu ID for the dock widgets.\"\"\"\n    TOOLS_ARRAY = \"tools/array\"\n    \"\"\"Menu ID for the commands related to \"array\"-type data.\"\"\"\n    TOOLS_DATAFRAME = \"tools/dataframe\"\n    \"\"\"Menu ID for the commands related to \"dataframe\"-type data.\"\"\"\n    TOOLS_EXCEL = \"tools/excel\"\n    \"\"\"Menu ID for the commands related to \"excel\"-type data.\"\"\"\n    TOOLS_IMAGE = \"tools/image\"\n    \"\"\"Menu ID for the commands related to \"image\"-type data.\"\"\"\n    TOOLS_IMAGE_ROI = \"tools/image/roi\"\n    \"\"\"Menu ID for the commands related to image ROIs.\"\"\"\n    TOOLS_IMAGE_CHANNELS = \"tools/image/channels\"\n    \"\"\"Menu ID for the commands related to image channels.\"\"\"\n    TOOLS_IMAGE_CAPTURE = \"tools/image/capture\"\n    \"\"\"Menu ID for the commands related to capturing current image slice.\"\"\"\n    TOOLS_PLOT = \"tools/plot\"\n    \"\"\"Menu ID for the commands related to \"plot\"-type data.\"\"\"\n    TOOLS_TEXT = \"tools/text\"\n    \"\"\"Menu ID for the commands related to \"text\"-type data.\"\"\"\n    TOOLS_TABLE = \"tools/table\"\n    \"\"\"Menu ID for the commands related to \"table\"-type data.\"\"\"\n    TOOLS_TABLE_COPY = \"tools/table/copy\"\n    \"\"\"Menu ID for the commands that copy the \"table\"-type data.\"\"\"\n    TOOLS_FUNCTION = \"tools/function\"\n    \"\"\"Menu ID for the commands related to \"function\"-type data.\"\"\"\n    TOOLS_OTHERS = \"tools/others\"\n    \"\"\"Menu ID for the commands related to other data.\"\"\"\n\n    # \"Go\" menu\n    GO = \"go\"\n\n    # Others\n    TOOLBAR = \"toolbar\"\n    CORNER = \"corner\"\n    HELP = \"help\"\n\n    RECENT_ALL = \"file/.recent-all\"\n    STARTUP = \"file/.startup\"\n    MODEL_MENU = \"/model_menu\"\n</code></pre>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_ARRAY","title":"<code>TOOLS_ARRAY = 'tools/array'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands related to \"array\"-type data.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_DATAFRAME","title":"<code>TOOLS_DATAFRAME = 'tools/dataframe'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands related to \"dataframe\"-type data.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_DOCK","title":"<code>TOOLS_DOCK = 'tools/dock'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the dock widgets.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_EXCEL","title":"<code>TOOLS_EXCEL = 'tools/excel'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands related to \"excel\"-type data.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_FUNCTION","title":"<code>TOOLS_FUNCTION = 'tools/function'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands related to \"function\"-type data.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_IMAGE","title":"<code>TOOLS_IMAGE = 'tools/image'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands related to \"image\"-type data.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_IMAGE_CAPTURE","title":"<code>TOOLS_IMAGE_CAPTURE = 'tools/image/capture'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands related to capturing current image slice.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_IMAGE_CHANNELS","title":"<code>TOOLS_IMAGE_CHANNELS = 'tools/image/channels'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands related to image channels.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_IMAGE_ROI","title":"<code>TOOLS_IMAGE_ROI = 'tools/image/roi'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands related to image ROIs.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_OTHERS","title":"<code>TOOLS_OTHERS = 'tools/others'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands related to other data.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_PLOT","title":"<code>TOOLS_PLOT = 'tools/plot'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands related to \"plot\"-type data.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_TABLE","title":"<code>TOOLS_TABLE = 'tools/table'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands related to \"table\"-type data.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_TABLE_COPY","title":"<code>TOOLS_TABLE_COPY = 'tools/table/copy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands that copy the \"table\"-type data.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_TEXT","title":"<code>TOOLS_TEXT = 'tools/text'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands related to \"text\"-type data.</p>"},{"location":"api/consts/#himena.consts.StandardType","title":"<code>StandardType</code>","text":"<p>Conventions for standard model types.</p> <p>Developers should use these types as much as possible to ensure compatibility with other plugins.</p> Source code in <code>src\\himena\\consts.py</code> <pre><code>class StandardType(SimpleNamespace):\n    \"\"\"Conventions for standard model types.\n\n    Developers should use these types as much as possible to ensure compatibility with\n    other plugins.\n    \"\"\"\n\n    ### Basic types ###\n    TEXT = \"text\"  # any text\n    TABLE = \"table\"  # 2D data without any special structure\n    ARRAY = \"array\"  # nD grid data such as numpy array\n    DICT = \"dict\"  # dictionary\n    DATAFRAME = \"dataframe\"  # DataFrame object\n\n    ### Subtypes ###\n    # dict subtypes\n    EXCEL = \"dict.table\"  # Excel file (~= tabbed tables)\n    DATAFRAMES = \"dict.dataframe\"\n    ARRAYS = \"dict.array\"\n    IMAGES = \"dict.array.image\"\n\n    # text subtypes\n    HTML = \"text.html\"  # HTML text\n    SVG = \"text.svg\"  # SVG text\n    MARKDOWN = \"text.markdown\"  # markdown text\n    JSON = \"text.json\"  # JSON text\n    IPYNB = \"text.json.ipynb\"  # Jupyter notebook\n\n    # image data\n    IMAGE = \"array.image\"\n    # uint image data that will be interpreted as labels\n    IMAGE_LABELS = \"array.image.labels\"\n    # Complex image data that should be interpreted as a Fourier transform. C0 must\n    # be shifted to the image center (using np.fft.fftshift)\n    IMAGE_FOURIER = \"array.image.fourier\"\n\n    # (N, D) numerical array, such as D-dimensional point cloud\n    COORDINATES = \"array.coordinates\"\n\n    # DataFrame that is supposed to be plotted immediately (such as image line scan)\n    DATAFRAME_PLOT = \"dataframe.plot\"\n\n    ### plotting ###\n    PLOT = \"plot\"  # objects that satisfy the plotting standard\n    PLOT_STACK = \"plot-stack\"  # stack of plot objects\n    MPL_FIGURE = \"matplotlib-figure\"  # matplotlib figure object\n\n    ### 3D ###\n    MESH = \"mesh\"  # vertices, faces and values for 3D mesh\n\n    ### Nested models ###\n    MODELS = \"models\"  # list or dict of models\n    LAZY = \"lazy\"  # lazy loading of models\n\n    ### Other types ###\n    WORKFLOW = \"workflow\"  # himena workflow object\n    WORKFLOW_PARAMETRIC = \"workflow.parametric\"  # parametric workflow object\n    GROUPBY = \"groupby\"  # DataFrame GroupBy object\n    ROIS = \"rois\"  # regions of interest\n    FUNCTION = \"function\"  # callable object\n    DISTRIBUTION = \"distribution\"  # probablistic distribution object\n\n    # fallback when no reader is found for the file (which means that the file could be\n    # opened as a text file)\n    READER_NOT_FOUND = \"reader_not_found\"\n\n    # fallback when no specific widget can be used for the data\n    ANY = \"any\"\n\n    # type used for result stack\n    RESULTS = \"results\"\n</code></pre>"},{"location":"api/layout/","title":"himena.layout","text":""},{"location":"api/layout/#himena.layout.BoxLayout1D","title":"<code>BoxLayout1D</code>","text":"Source code in <code>src\\himena\\layout.py</code> <pre><code>class BoxLayout1D(Layout1D):\n    def __init__(self, main=None, *, margins=(0, 0, 0, 0), spacing=0):\n        super().__init__(main, margins=margins, spacing=spacing)\n        self._stretches: list[float] = []\n\n    def insert(self, index: int, child: Layout, *, stretch: float = 1) -&gt; None:\n        \"\"\"Insert a child layout at the specified index.\"\"\"\n        if stretch &lt;= 0:\n            raise ValueError(f\"stretch must be positive, got {stretch!r}\")\n        if not isinstance(child, Layout):\n            raise TypeError(f\"Can only insert a Layout object, got {type(child)}\")\n        self._children.insert(index, child)\n        child._main_window_ref = self._main_window_ref\n        child._parent_layout_ref = weakref.ref(self)\n        self._stretches.insert(index, float(stretch))\n        self._resize_children(self.rect)\n        return self\n\n    def append(self, child: Layout, *, stretch: float = 1) -&gt; None:\n        return self.insert(len(self), child, stretch=stretch)\n\n    def add(\n        self,\n        child: Layout | Iterable[Layout],\n        *more: Layout,\n        stretch: float = 1,\n    ) -&gt; Self:\n        \"\"\"Add child layout(s) to the layout.\"\"\"\n        if not isinstance(child, Layout):\n            child, more = child[0], [*child[1:], *more]\n        self.append(child, stretch=stretch)\n        for ch in more:\n            self.append(ch, stretch=stretch)\n        return self\n\n    def __delitem__(self, key: int):\n        _assert_supports_index(key)\n        child = self._children.pop(key)\n        child._parent_layout_ref = _no_ref\n        del self._stretches[key]\n        self._resize_children(self.rect)\n\n    def add_vbox_layout(self, *, margins=(0, 0, 0, 0), spacing=0) -&gt; VBoxLayout:\n        layout = VBoxLayout(self._main_window_ref(), margins=margins, spacing=spacing)\n        self.append(layout)\n        return layout\n\n    def add_hbox_layout(self, *, margins=(0, 0, 0, 0), spacing=0) -&gt; HBoxLayout:\n        layout = HBoxLayout(self._main_window_ref(), margins=margins, spacing=spacing)\n        self.append(layout)\n        return layout\n\n    def _may_take_child(\n        self, child: Layout, rect_old: WindowRect, rect_new: WindowRect\n    ) -&gt; Layout:\n        # window moved\n        dist2 = (rect_old.top - rect_new.top) ** 2 + (\n            rect_old.left - rect_new.left\n        ) ** 2\n        if dist2 &gt; 60**2:\n            # remove window from the layout\n            self.remove(child)\n        self._resize_children(self.rect)\n</code></pre>"},{"location":"api/layout/#himena.layout.BoxLayout1D.add","title":"<code>add(child, *more, stretch=1)</code>","text":"<p>Add child layout(s) to the layout.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>def add(\n    self,\n    child: Layout | Iterable[Layout],\n    *more: Layout,\n    stretch: float = 1,\n) -&gt; Self:\n    \"\"\"Add child layout(s) to the layout.\"\"\"\n    if not isinstance(child, Layout):\n        child, more = child[0], [*child[1:], *more]\n    self.append(child, stretch=stretch)\n    for ch in more:\n        self.append(ch, stretch=stretch)\n    return self\n</code></pre>"},{"location":"api/layout/#himena.layout.BoxLayout1D.insert","title":"<code>insert(index, child, *, stretch=1)</code>","text":"<p>Insert a child layout at the specified index.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>def insert(self, index: int, child: Layout, *, stretch: float = 1) -&gt; None:\n    \"\"\"Insert a child layout at the specified index.\"\"\"\n    if stretch &lt;= 0:\n        raise ValueError(f\"stretch must be positive, got {stretch!r}\")\n    if not isinstance(child, Layout):\n        raise TypeError(f\"Can only insert a Layout object, got {type(child)}\")\n    self._children.insert(index, child)\n    child._main_window_ref = self._main_window_ref\n    child._parent_layout_ref = weakref.ref(self)\n    self._stretches.insert(index, float(stretch))\n    self._resize_children(self.rect)\n    return self\n</code></pre>"},{"location":"api/layout/#himena.layout.EmptyLayout","title":"<code>EmptyLayout</code>","text":"<p>A layout that does not contain anything.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>class EmptyLayout(Layout):\n    \"\"\"A layout that does not contain anything.\"\"\"\n\n    def __init__(self, main: BackendMainWindow | None = None):\n        super().__init__(main)\n        self._rect = WindowRect(0, 0, 0, 0)\n\n    @property\n    def rect(self):\n        return self._rect\n\n    @rect.setter\n    def rect(self, value):\n        rect_old = self._rect\n        self._rect = WindowRect.from_tuple(*value)\n        if parent := self._parent_layout_ref():\n            parent._adjust_child_resize(self, rect_old, self._rect)\n\n    def _serialize_layout(self):\n        return {\"type\": \"empty\", \"rect\": self.rect}\n\n    @classmethod\n    def _deserialize_layout(cls, obj, main: MainWindow):\n        self = cls(main._backend_main_window)\n        self.rect = obj[\"rect\"]\n        return self\n</code></pre>"},{"location":"api/layout/#himena.layout.GridLayout","title":"<code>GridLayout</code>","text":"Source code in <code>src\\himena\\layout.py</code> <pre><code>class GridLayout(LayoutContainer):\n    def __init__(\n        self,\n        main: BackendMainWindow | None = None,\n        *,\n        margins: Margins[int] | tuple[int, int, int, int] = (0, 0, 0, 0),\n        spacing: Size[int] | tuple[int, int] = 0,\n    ):\n        super().__init__(main)\n        self._margins = Margins(*margins)\n        self._spacing = Size(*spacing)\n\n    @property\n    def margins(self) -&gt; Margins[int]:\n        \"\"\"Margins around the layout.\"\"\"\n        return self._margins\n\n    @margins.setter\n    def margins(self, value: Margins[int] | tuple[int, int, int, int]):\n        self._margins = Margins(*value)\n        self._resize_children(self.rect)\n\n    @property\n    def spacing(self) -&gt; Size:\n        \"\"\"Spacing between children.\"\"\"\n        return self._spacing\n\n    @spacing.setter\n    def spacing(self, value: Size[int] | tuple[int, int]):\n        self._spacing = Size(*value)\n        self._resize_children(self.rect)\n</code></pre>"},{"location":"api/layout/#himena.layout.GridLayout.margins","title":"<code>margins</code>  <code>property</code> <code>writable</code>","text":"<p>Margins around the layout.</p>"},{"location":"api/layout/#himena.layout.GridLayout.spacing","title":"<code>spacing</code>  <code>property</code> <code>writable</code>","text":"<p>Spacing between children.</p>"},{"location":"api/layout/#himena.layout.HBoxLayout","title":"<code>HBoxLayout</code>","text":"<p>A horizontal box layout.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>class HBoxLayout(BoxLayout1D):\n    \"\"\"A horizontal box layout.\"\"\"\n\n    def _iter_edge_and_span(self, rect: WindowRect) -&gt; Iterator[tuple[int, int]]:\n        num = len(self._children)\n        if num == 0:\n            yield from ()\n            return\n        w_cumsum = np.cumsum([0] + self._stretches, dtype=np.float32)\n        edges = (w_cumsum / w_cumsum[-1] * rect.width).astype(np.int32)\n        dx = self.spacing // 2\n        edges[0] += self._margins.left - dx\n        edges[-1] += self._margins.right + dx\n        for i in range(num):\n            left = edges[i] + dx\n            width = edges[i + 1] - edges[i] - self.spacing\n            yield left, width\n\n    def _ortho_region(self, rect: WindowRect) -&gt; tuple[int, int]:\n        height = rect.height - self._margins.top - self._margins.bottom\n        top = rect.top + self._margins.top\n        return top, height\n\n    def _resize_children(self, rect: WindowRect):\n        top, height = self._ortho_region(rect)\n        with self._adjust_child_resize_context():\n            for i, (left, width) in enumerate(self._iter_edge_and_span(rect)):\n                irect = WindowRect(left, top, width, height)\n                self._children[i].rect = irect\n        return None\n\n    def _adjust_child_resize(self, child: Layout, rect_old, rect_new):\n        if self._is_calling_adjust_child_resize:\n            return\n        left_changed = rect_old.left != rect_new.left\n        right_changed = rect_old.right != rect_new.right\n        with self._adjust_child_resize_context():\n            if left_changed and right_changed:\n                return self._may_take_child(child, rect_old, rect_new)\n\n            top, height = self._ortho_region(self.rect)\n            new_rect = child.rect\n            stretches = self._stretches.copy()\n            for i, (left, width) in enumerate(self._iter_edge_and_span(self.rect)):\n                stretches[i] = width\n                if left_changed and self._children[i] is child:\n                    if i == 0:\n                        child.rect = WindowRect(left, top, width, height)\n                    else:\n                        old_sum = stretches[i - 1] + stretches[i]\n                        w0 = stretches[i - 1] = old_sum - new_rect.width\n                        self._children[i - 1].rect = self._children[\n                            i - 1\n                        ].rect.with_width(w0)\n                        stretches[i] = new_rect.width\n                elif right_changed and self._children[i - 1] is child:\n                    if i == len(self) - 1:\n                        child.rect = WindowRect(left, top, width, height)\n                    else:\n                        old_sum = stretches[i - 1] + stretches[i]\n                        w0 = stretches[i] = old_sum - new_rect.width\n                        self._children[i].rect = new_rect.with_width(w0)\n                        stretches[i - 1] = new_rect.width\n                else:\n                    child.rect = WindowRect(left, top, width, height)\n            self._stretches = stretches\n            self._resize_children(self.rect)\n</code></pre>"},{"location":"api/layout/#himena.layout.Layout","title":"<code>Layout</code>","text":"Source code in <code>src\\himena\\layout.py</code> <pre><code>class Layout(ABC):\n    def __init__(self, main: BackendMainWindow | None = None):\n        self._anchor = _anc.NoAnchor\n        if main:\n            self._main_window_ref = weakref.ref(main)\n        else:\n            self._main_window_ref = _no_ref\n        self._parent_layout_ref: Callable[[], LayoutContainer | None] = _no_ref\n\n    @property\n    @abstractmethod\n    def rect(self) -&gt; WindowRect:\n        \"\"\"Position and size of the sub-window.\"\"\"\n\n    @rect.setter\n    def rect(self, value: tuple[int, int, int, int] | WindowRect) -&gt; None: ...\n\n    @abstractmethod\n    def _serialize_layout(self) -&gt; Any:\n        \"\"\"Serialize the layout instance.\"\"\"\n\n    @classmethod\n    @abstractmethod\n    def _deserialize_layout(cls, obj, main: MainWindow) -&gt; Any:\n        \"\"\"Deserialize the layout instance.\"\"\"\n\n    @property\n    def size(self) -&gt; Size[int]:\n        \"\"\"Size of the object.\"\"\"\n        return self.rect.size()\n\n    @size.setter\n    def size(self, value: tuple[int, int]) -&gt; None:\n        self.rect = (self.rect.left, self.rect.top, *value)\n        return None\n\n    @property\n    def anchor(self) -&gt; _anc.WindowAnchor:\n        return self._anchor\n\n    @anchor.setter\n    def anchor(self, anchor: _anc.WindowAnchor | None):\n        if anchor is None:\n            anchor = _anc.NoAnchor\n        elif isinstance(anchor, str):\n            anchor = self._anchor_from_str(anchor)\n        elif not isinstance(anchor, _anc.WindowAnchor):\n            raise TypeError(f\"Expected WindowAnchor, got {type(anchor)}\")\n        self._anchor = anchor\n\n    def _reanchor(self, size: Size):\n        \"\"\"Reanchor all windows if needed (such as minimized windows).\"\"\"\n        if rect := self._anchor.apply_anchor(size, self.size):\n            self.rect = rect\n\n    def _anchor_from_str(self, anchor: str):\n        rect = self.rect\n        main = self._main_window_ref()\n        if main is None:\n            w0, h0 = 100, 100\n        else:\n            w0, h0 = main._area_size()\n        if anchor in (\"top-left\", \"top left\", \"top_left\"):\n            return _anc.TopLeftConstAnchor(rect.left, rect.top)\n        elif anchor in (\"top-right\", \"top right\", \"top_right\"):\n            return _anc.TopRightConstAnchor(w0 - rect.right, rect.top)\n        elif anchor in (\"bottom-left\", \"bottom left\", \"bottom_left\"):\n            return _anc.BottomLeftConstAnchor(rect.left, h0 - rect.bottom)\n        elif anchor in (\"bottom-right\", \"bottom right\", \"bottom_right\"):\n            return _anc.BottomRightConstAnchor(w0 - rect.right, h0 - rect.bottom)\n        else:\n            raise ValueError(f\"Unknown anchor: {anchor}\")\n</code></pre>"},{"location":"api/layout/#himena.layout.Layout.rect","title":"<code>rect</code>  <code>abstractmethod</code> <code>property</code> <code>writable</code>","text":"<p>Position and size of the sub-window.</p>"},{"location":"api/layout/#himena.layout.Layout.size","title":"<code>size</code>  <code>property</code> <code>writable</code>","text":"<p>Size of the object.</p>"},{"location":"api/layout/#himena.layout.Layout1D","title":"<code>Layout1D</code>","text":"<p>Layout container that arranges children in 1D at the constant interval.</p> <p>Properties <code>margins</code> and <code>spacing</code> are defined as follows. <pre><code>        spacing                 margin\n         &gt; &lt;                     &gt; &lt;\n[ [child1] [   child2   ] [child3] ]\n           &lt;-  stretch -&gt;\n</code></pre></p> <p>Abstract methods: - <code>_resize_children(self, rect: WindowRect) -&gt; None</code> - <code>insert(self, index: int, child: Layout) -&gt; None</code></p> Source code in <code>src\\himena\\layout.py</code> <pre><code>class Layout1D(LayoutContainer, MutableSequence[Layout]):\n    \"\"\"Layout container that arranges children in 1D at the constant interval.\n\n    Properties `margins` and `spacing` are defined as follows.\n    ```\n            spacing                 margin\n             &gt; &lt;                     &gt; &lt;\n    [ [child1] [   child2   ] [child3] ]\n               &lt;-  stretch -&gt;\n    ```\n\n    Abstract methods:\n    - `_resize_children(self, rect: WindowRect) -&gt; None`\n    - `insert(self, index: int, child: Layout) -&gt; None`\n    \"\"\"\n\n    def __init__(\n        self,\n        main: BackendMainWindow | None = None,\n        *,\n        margins: Margins[int] | tuple[int, int, int, int] = (0, 0, 0, 0),\n        spacing: int = 0,\n    ):\n        super().__init__(main)\n        self._children: list[Layout] = []\n        self._margins = Margins(*margins)\n        self._spacing = spacing\n\n    @property\n    def margins(self) -&gt; Margins[int]:\n        \"\"\"Margins around the layout.\"\"\"\n        return self._margins\n\n    @margins.setter\n    def margins(self, value: Margins[int] | tuple[int, int, int, int]):\n        self._margins = Margins(*value)\n        self._resize_children(self.rect)\n\n    @property\n    def spacing(self) -&gt; int:\n        \"\"\"Spacing between children.\"\"\"\n        return self._spacing\n\n    @spacing.setter\n    def spacing(self, value: int):\n        if value &lt; 0 or not isinstance(value, (int, np.int_)):\n            raise ValueError(f\"spacing must be non-negative integer, got {value}\")\n        self._spacing = value\n        self._resize_children(self.rect)\n\n    def set_margins(\n        self,\n        *,\n        left: int | None = None,\n        top: int | None = None,\n        right: int | None = None,\n        bottom: int | None = None,\n    ):\n        \"\"\"Update margins around the layout.\"\"\"\n        margins_old = self.margins\n        left = left if left is not None else margins_old.left\n        top = top if top is not None else margins_old.top\n        right = right if right is not None else margins_old.right\n        bottom = bottom if bottom is not None else margins_old.bottom\n        self.margins = left, top, right, bottom\n        return None\n\n    def __len__(self) -&gt; int:\n        return len(self._children)\n\n    def __iter__(self) -&gt; Iterator[Layout]:\n        for _, child in self._children:\n            yield child\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}({self._children!r})\"\n\n    def __getitem__(self, key) -&gt; Layout:\n        _assert_supports_index(key)\n        return self._children[key]\n\n    def __setitem__(self, key, layout: Layout):\n        if not isinstance(layout, Layout):\n            raise TypeError(f\"Can only set a Layout object, got {type(layout)}\")\n        _assert_supports_index(key)\n        self._children[key] = layout\n        layout._main_window_ref = self._main_window_ref\n        layout._parent_layout_ref = weakref.ref(self)\n        self._resize_children(self.rect)\n\n    def remove(self, child: Layout) -&gt; None:\n        MutableSequence.remove(self, child)\n        child._parent_layout_ref = _no_ref\n        if len(self) &gt; 1:\n            self._resize_children(self.rect)\n        elif len(self) == 1:\n            self.remove(self[0])\n\n    def _serialize_layout(self):\n        return {\n            \"type\": type(self).__name__.lower(),\n            \"children\": [child._serialize_layout() for child in self._children],\n            \"margins\": list(self.margins),\n            \"spacing\": self.spacing,\n        }\n\n    @classmethod\n    def _deserialize_layout(cls, obj, main: MainWindow) -&gt; Self:\n        self = cls(\n            main._backend_main_window, margins=obj[\"margins\"], spacing=obj[\"spacing\"]\n        )\n        for child_obj in obj[\"children\"]:\n            child = construct_layout(child_obj, main)\n            self.append(child)\n        return self\n</code></pre>"},{"location":"api/layout/#himena.layout.Layout1D.margins","title":"<code>margins</code>  <code>property</code> <code>writable</code>","text":"<p>Margins around the layout.</p>"},{"location":"api/layout/#himena.layout.Layout1D.spacing","title":"<code>spacing</code>  <code>property</code> <code>writable</code>","text":"<p>Spacing between children.</p>"},{"location":"api/layout/#himena.layout.Layout1D.set_margins","title":"<code>set_margins(*, left=None, top=None, right=None, bottom=None)</code>","text":"<p>Update margins around the layout.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>def set_margins(\n    self,\n    *,\n    left: int | None = None,\n    top: int | None = None,\n    right: int | None = None,\n    bottom: int | None = None,\n):\n    \"\"\"Update margins around the layout.\"\"\"\n    margins_old = self.margins\n    left = left if left is not None else margins_old.left\n    top = top if top is not None else margins_old.top\n    right = right if right is not None else margins_old.right\n    bottom = bottom if bottom is not None else margins_old.bottom\n    self.margins = left, top, right, bottom\n    return None\n</code></pre>"},{"location":"api/layout/#himena.layout.LayoutContainer","title":"<code>LayoutContainer</code>","text":"<p>Layout that can contain other layouts.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>class LayoutContainer(Layout):\n    \"\"\"Layout that can contain other layouts.\"\"\"\n\n    def __init__(self, main: BackendMainWindow | None = None):\n        self._rect = WindowRect(0, 0, 1000, 1000)\n        super().__init__(main)\n        self._anchor = _anc.AllCornersAnchor()\n        self._is_calling_adjust_child_resize = False\n\n    @contextmanager\n    def _adjust_child_resize_context(self):\n        was = self._is_calling_adjust_child_resize\n        self._is_calling_adjust_child_resize = True\n        try:\n            yield\n        finally:\n            self._is_calling_adjust_child_resize = was\n\n    @property\n    def rect(self):\n        return self._rect\n\n    @rect.setter\n    def rect(self, value):\n        rect = WindowRect.from_tuple(*value)\n        rect_old = self._rect\n        self._rect = rect\n        self._resize_children(rect)\n        if parent := self._parent_layout_ref():\n            parent._adjust_child_resize(self, rect_old, rect)\n\n    @abstractmethod\n    def _resize_children(self, rect: WindowRect):\n        \"\"\"Resize all children layouts based on the geometry of this layout.\"\"\"\n\n    @abstractmethod\n    def remove(self, child: Layout) -&gt; None:\n        \"\"\"Remove a child layout from this layout.\"\"\"\n\n    # @abstractmethod\n    def _adjust_child_resize(\n        self, child: Layout, rect_old: WindowRect, rect_new: WindowRect\n    ):\n        \"\"\"Adjust layout container based on the child resize/move.\"\"\"\n</code></pre>"},{"location":"api/layout/#himena.layout.LayoutContainer.remove","title":"<code>remove(child)</code>  <code>abstractmethod</code>","text":"<p>Remove a child layout from this layout.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>@abstractmethod\ndef remove(self, child: Layout) -&gt; None:\n    \"\"\"Remove a child layout from this layout.\"\"\"\n</code></pre>"},{"location":"api/layout/#himena.layout.VBoxLayout","title":"<code>VBoxLayout</code>","text":"<p>A vertical box layout.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>class VBoxLayout(BoxLayout1D):\n    \"\"\"A vertical box layout.\"\"\"\n\n    def _iter_edge_and_span(self, rect: WindowRect) -&gt; Iterator[tuple[int, int]]:\n        num = len(self._children)\n        if num == 0:\n            yield from ()\n            return\n        h_cumsum = np.cumsum([0] + self._stretches, dtype=np.float32)\n        edges = (h_cumsum / h_cumsum[-1] * rect.height).astype(np.int32)\n        dy = self.spacing // 2\n        edges[0] += self._margins.top - dy\n        edges[-1] += self._margins.bottom + dy\n        for i in range(num):\n            top = edges[i] + dy\n            height = edges[i + 1] - edges[i] - self.spacing\n            yield top, height\n\n    def _ortho_region(self, rect: WindowRect) -&gt; tuple[int, int]:\n        width = rect.width - self._margins.left - self._margins.right\n        left = rect.left + self._margins.left\n        return left, width\n\n    def _resize_children(self, rect: WindowRect):\n        left, width = self._ortho_region(rect)\n        with self._adjust_child_resize_context():\n            for i, (top, height) in enumerate(self._iter_edge_and_span(rect)):\n                irect = WindowRect(left, top, width, height)\n                self._children[i].rect = irect\n        return None\n\n    def _adjust_child_resize(self, child: Layout, rect_old, rect_new):\n        if self._is_calling_adjust_child_resize:\n            return\n        top_changed = rect_old.top != rect_new.top\n        bottom_changed = rect_old.bottom != rect_new.bottom\n        with self._adjust_child_resize_context():\n            if top_changed and bottom_changed:\n                return self._may_take_child(child, rect_old, rect_new)\n\n            top, height = self._ortho_region(self.rect)\n            new_rect = child.rect\n            stretches = self._stretches.copy()\n            for i, (left, width) in enumerate(self._iter_edge_and_span(self.rect)):\n                stretches[i] = width\n                if top_changed and self._children[i] is child:\n                    if i == 0:\n                        child.rect = WindowRect(left, top, width, height)\n                    else:\n                        old_sum = stretches[i - 1] + stretches[i]\n                        stretches[i - 1] = old_sum - new_rect.height\n                        stretches[i] = new_rect.height\n                elif bottom_changed and self._children[i - 1] is child:\n                    if i == len(self) - 1:\n                        child.rect = WindowRect(left, top, width, height)\n                    else:\n                        old_sum = stretches[i - 1] + stretches[i]\n                        stretches[i] = old_sum - new_rect.height\n                        stretches[i - 1] = new_rect.height\n                else:\n                    child.rect = WindowRect(left, top, width, height)\n            self._stretches = stretches\n            self._resize_children(self.rect)\n</code></pre>"},{"location":"api/layout/#himena.layout.VStackLayout","title":"<code>VStackLayout</code>","text":"Source code in <code>src\\himena\\layout.py</code> <pre><code>class VStackLayout(Layout1D):\n    def __init__(\n        self,\n        main: BackendMainWindow | None = None,\n        *,\n        margins: Margins[int] | tuple[int, int, int, int] = (0, 0, 0, 0),\n        spacing: int = 0,\n        inverted: bool = False,\n    ):\n        super().__init__(main, margins=margins, spacing=spacing)\n        self._inverted = inverted\n\n    @property\n    def inverted(self) -&gt; bool:\n        return self._inverted\n\n    @inverted.setter\n    def inverted(self, value: bool):\n        self._inverted = bool(value)\n        self._resize_children(self.rect)\n\n    def insert(self, index: int, child: Layout) -&gt; None:\n        \"\"\"Insert a child layout at the specified index.\"\"\"\n        self._children.insert(index, child)\n        child._main_window_ref = self._main_window_ref\n        child._parent_layout_ref = weakref.ref(self)\n        self._resize_children(self.rect)\n        return self\n\n    def append(self, child: Layout) -&gt; None:\n        return self.insert(len(self), child)\n\n    def add(self, child: Layout) -&gt; Self:\n        self.append(child)\n        return self\n\n    def __delitem__(self, key: int):\n        _assert_supports_index(key)\n        self._children[key]._parent_layout_ref = _no_ref\n        del self._children[key]\n        self._resize_children(self.rect)\n\n    def _resize_children(self, rect):\n        num = len(self._children)\n        if num == 0:\n            return\n        heights = [ch.rect.height for ch in self._children]\n        h_cumsum = np.cumsum([0] + heights, dtype=np.uint32)\n        if self._inverted:\n            bottoms = rect.bottom - h_cumsum[:-1] + self._margins.bottom\n            for i, child in enumerate(self._children):\n                child.rect = child.rect.move_bottom_left(rect.left, bottoms[i])\n        else:\n            tops = h_cumsum[:-1] + rect.top + self._margins.top\n            for i, child in enumerate(self._children):\n                child.rect = child.rect.move_top_left(rect.left, tops[i])\n</code></pre>"},{"location":"api/layout/#himena.layout.VStackLayout.insert","title":"<code>insert(index, child)</code>","text":"<p>Insert a child layout at the specified index.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>def insert(self, index: int, child: Layout) -&gt; None:\n    \"\"\"Insert a child layout at the specified index.\"\"\"\n    self._children.insert(index, child)\n    child._main_window_ref = self._main_window_ref\n    child._parent_layout_ref = weakref.ref(self)\n    self._resize_children(self.rect)\n    return self\n</code></pre>"},{"location":"api/plugins/","title":"himena.plugins","text":""},{"location":"api/plugins/#himena.plugins.register_hidden_function","title":"<code>register_hidden_function = partial(register_function, menus=[], palette=False)</code>  <code>module-attribute</code>","text":"<p>A shorthand for <code>register_function(menus=[], palette=False)</code>.</p>"},{"location":"api/plugins/#himena.plugins.AppActionRegistry","title":"<code>AppActionRegistry</code>","text":"Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>class AppActionRegistry:\n    _global_instance: AppActionRegistry | None = None\n\n    def __init__(self):\n        self._actions: dict[str, Action] = {}\n        self._actions_dynamic: set[str] = set()\n        self._submenu_titles: dict[str, str] = {\n            MenuId.FILE_NEW: \"New ...\",\n            MenuId.TOOLS_DOCK: \"Dock widgets\",\n        }\n        self._submenu_groups: dict[str, str] = {\n            MenuId.FILE_NEW: \"00_new\",\n            MenuId.TOOLS_DOCK: \"00_dock\",\n        }\n        self._submenu_order: dict[str, int] = {}\n        self._installed_plugins: list[str] = []\n        self._plugin_default_configs: dict[str, PluginConfigTuple] = {}\n        self._modification_trackers: dict[str, Callable[[_T, _T], ReproduceArgs]] = {}\n        self._app_tips: list[AppTip] = []\n        self._action_hint_reg = ActionHintRegistry()\n        self._try_load_app_tips()\n\n    @classmethod\n    def instance(cls) -&gt; AppActionRegistry:\n        \"\"\"Get the global instance of the registry.\"\"\"\n        if cls._global_instance is None:\n            cls._global_instance = cls()\n        return cls._global_instance\n\n    def _try_load_app_tips(self) -&gt; None:\n        tip_path = Path(__file__).parent.parent / \"resources\" / \"tips.json\"\n        try:\n            with tip_path.open(\"r\") as f:\n                out = json.load(f)\n            for each in out:\n                self._app_tips.append(\n                    AppTip(\n                        short=each.get(\"short\", \"\"),\n                        long=each.get(\"long\", \"\"),\n                    )\n                )\n        except Exception as e:\n            _LOGGER.error(\"Failed to load app tips: %s\", e)\n\n    def pick_a_tip(self) -&gt; AppTip | None:\n        \"\"\"Pick a random tip.\"\"\"\n        if len(self._app_tips) == 0:\n            return None\n        tip = random.choice(self._app_tips)\n        return AppTip(short=tip.short, long=tip.long)\n\n    def add_action(self, action: Action, is_dynamic: bool = False) -&gt; None:\n        \"\"\"Add an action to the registry.\"\"\"\n        id_ = action.id\n        if id_ in self._actions:\n            raise ValueError(f\"Action ID {id_} already exists.\")\n        self._actions[id_] = action\n        if is_dynamic:\n            self._actions_dynamic.add(id_)\n\n    @property\n    def installed_plugins(self) -&gt; list[str]:\n        \"\"\"List of modules or python paths that are installed as plugins.\"\"\"\n        return self._installed_plugins\n\n    def iter_actions(self, app: HimenaApplication) -&gt; Iterator[Action]:\n        for id_, action in self._actions.items():\n            if id_ not in app.commands:\n                yield action\n\n    def submenu_title(self, id: str) -&gt; str:\n        \"\"\"Get the title of a submenu.\"\"\"\n        if title := self._submenu_titles.get(id):\n            return title\n        return id.split(\"/\")[-1].title()\n\n    def submenu_group(self, id: str) -&gt; str | None:\n        \"\"\"Get the group of a submenu.\"\"\"\n        return self._submenu_groups.get(id, None)\n\n    def submenu_order(self, id: str) -&gt; str | None:\n        return self._submenu_order.get(id, None)\n\n    @property\n    def submenu_titles(self) -&gt; dict[str, str]:\n        return self._submenu_titles\n\n    def install_to(\n        self,\n        app: HimenaApplication,\n        actions: list[Action] | None = None,\n    ) -&gt; list[str]:\n        \"\"\"Install actions to the application.\n\n        This method automatically adds submenus if they are not already exists, and\n        returns the list of added root menu IDs. Note that this does NOT updates the\n        GUI menubar and toolbar.\n        \"\"\"\n        # look for existing menu items\n        if actions is None:\n            actions = list(self.iter_actions(app))\n        existing_menu_ids = {_id.value for _id in MenuId if \"/\" not in _id.value}\n        for menu_id, menu in app.menus:\n            existing_menu_ids.add(menu_id)\n            for each in menu:\n                if isinstance(each, SubmenuItem):\n                    existing_menu_ids.add(each.submenu)\n\n        added_menu_ids = OrderedSet[str]()\n        for action in actions:\n            if action.menus is not None:\n                ids = [a.id for a in action.menus]\n                added_menu_ids.update(ids)\n\n        # add submenus if not exists\n        to_add: list[tuple[str, SubmenuItem]] = []\n        new_menu_ids: list[str] = []\n\n        for place in added_menu_ids - existing_menu_ids:\n            place_components = place.split(\"/\")\n            if len(place_components) == 1:\n                new_menu_ids.append(place)\n            for i in range(1, len(place_components)):\n                menu_id = \"/\".join(place_components[:i])\n                submenu = \"/\".join(place_components[: i + 1])\n                if submenu in existing_menu_ids:\n                    continue\n                title = self.submenu_title(submenu)\n                group = self.submenu_group(submenu)\n                order = self.submenu_order(submenu)\n                item = SubmenuItem(\n                    title=title, submenu=submenu, group=group, order=order\n                )\n                to_add.append((menu_id, item))\n\n        app.register_actions(actions)\n        app.menus.append_menu_items(to_add)\n        app._dynamic_command_ids.update(self._actions_dynamic)\n        return new_menu_ids\n</code></pre>"},{"location":"api/plugins/#himena.plugins.AppActionRegistry.installed_plugins","title":"<code>installed_plugins</code>  <code>property</code>","text":"<p>List of modules or python paths that are installed as plugins.</p>"},{"location":"api/plugins/#himena.plugins.AppActionRegistry.add_action","title":"<code>add_action(action, is_dynamic=False)</code>","text":"<p>Add an action to the registry.</p> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>def add_action(self, action: Action, is_dynamic: bool = False) -&gt; None:\n    \"\"\"Add an action to the registry.\"\"\"\n    id_ = action.id\n    if id_ in self._actions:\n        raise ValueError(f\"Action ID {id_} already exists.\")\n    self._actions[id_] = action\n    if is_dynamic:\n        self._actions_dynamic.add(id_)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.AppActionRegistry.install_to","title":"<code>install_to(app, actions=None)</code>","text":"<p>Install actions to the application.</p> <p>This method automatically adds submenus if they are not already exists, and returns the list of added root menu IDs. Note that this does NOT updates the GUI menubar and toolbar.</p> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>def install_to(\n    self,\n    app: HimenaApplication,\n    actions: list[Action] | None = None,\n) -&gt; list[str]:\n    \"\"\"Install actions to the application.\n\n    This method automatically adds submenus if they are not already exists, and\n    returns the list of added root menu IDs. Note that this does NOT updates the\n    GUI menubar and toolbar.\n    \"\"\"\n    # look for existing menu items\n    if actions is None:\n        actions = list(self.iter_actions(app))\n    existing_menu_ids = {_id.value for _id in MenuId if \"/\" not in _id.value}\n    for menu_id, menu in app.menus:\n        existing_menu_ids.add(menu_id)\n        for each in menu:\n            if isinstance(each, SubmenuItem):\n                existing_menu_ids.add(each.submenu)\n\n    added_menu_ids = OrderedSet[str]()\n    for action in actions:\n        if action.menus is not None:\n            ids = [a.id for a in action.menus]\n            added_menu_ids.update(ids)\n\n    # add submenus if not exists\n    to_add: list[tuple[str, SubmenuItem]] = []\n    new_menu_ids: list[str] = []\n\n    for place in added_menu_ids - existing_menu_ids:\n        place_components = place.split(\"/\")\n        if len(place_components) == 1:\n            new_menu_ids.append(place)\n        for i in range(1, len(place_components)):\n            menu_id = \"/\".join(place_components[:i])\n            submenu = \"/\".join(place_components[: i + 1])\n            if submenu in existing_menu_ids:\n                continue\n            title = self.submenu_title(submenu)\n            group = self.submenu_group(submenu)\n            order = self.submenu_order(submenu)\n            item = SubmenuItem(\n                title=title, submenu=submenu, group=group, order=order\n            )\n            to_add.append((menu_id, item))\n\n    app.register_actions(actions)\n    app.menus.append_menu_items(to_add)\n    app._dynamic_command_ids.update(self._actions_dynamic)\n    return new_menu_ids\n</code></pre>"},{"location":"api/plugins/#himena.plugins.AppActionRegistry.instance","title":"<code>instance()</code>  <code>classmethod</code>","text":"<p>Get the global instance of the registry.</p> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>@classmethod\ndef instance(cls) -&gt; AppActionRegistry:\n    \"\"\"Get the global instance of the registry.\"\"\"\n    if cls._global_instance is None:\n        cls._global_instance = cls()\n    return cls._global_instance\n</code></pre>"},{"location":"api/plugins/#himena.plugins.AppActionRegistry.pick_a_tip","title":"<code>pick_a_tip()</code>","text":"<p>Pick a random tip.</p> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>def pick_a_tip(self) -&gt; AppTip | None:\n    \"\"\"Pick a random tip.\"\"\"\n    if len(self._app_tips) == 0:\n        return None\n    tip = random.choice(self._app_tips)\n    return AppTip(short=tip.short, long=tip.long)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.AppActionRegistry.submenu_group","title":"<code>submenu_group(id)</code>","text":"<p>Get the group of a submenu.</p> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>def submenu_group(self, id: str) -&gt; str | None:\n    \"\"\"Get the group of a submenu.\"\"\"\n    return self._submenu_groups.get(id, None)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.AppActionRegistry.submenu_title","title":"<code>submenu_title(id)</code>","text":"<p>Get the title of a submenu.</p> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>def submenu_title(self, id: str) -&gt; str:\n    \"\"\"Get the title of a submenu.\"\"\"\n    if title := self._submenu_titles.get(id):\n        return title\n    return id.split(\"/\")[-1].title()\n</code></pre>"},{"location":"api/plugins/#himena.plugins.ReaderPlugin","title":"<code>ReaderPlugin</code>","text":"Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>class ReaderPlugin(_IOPluginBase):\n    def __init__(\n        self,\n        reader: Callable[[Path | list[Path]], WidgetDataModel],\n        matcher: Callable[[Path | list[Path]], bool] | None = None,\n        *,\n        priority: int = 100,\n    ):\n        super().__init__(reader, matcher, priority=priority)\n        self._skip_if_list = False\n        if hasattr(reader, \"__annotations__\"):\n            annot_types = list(reader.__annotations__.values())\n            if len(annot_types) == 1 and annot_types[0] in (\n                Path,\n                \"Path\",\n                ForwardRef(\"Path\"),\n            ):\n                self._skip_if_list = True\n\n    def read(self, path: Path | list[Path]) -&gt; WidgetDataModel:\n        \"\"\"Read file(s) and return a data model.\"\"\"\n        if isinstance(path, list):\n            paths: list[Path] = []\n            for p in path:\n                if not p.exists():\n                    raise FileNotFoundError(f\"File {p!r} does not exist.\")\n                paths.append(p)\n            out = self._func(paths)\n        else:\n            path = Path(path)\n            if not path.exists():\n                raise FileNotFoundError(f\"File {path!r} does not exist.\")\n            out = self._func(path)\n        if not isinstance(out, WidgetDataModel):\n            raise TypeError(f\"Reader plugin {self!r} did not return a WidgetDataModel.\")\n        return out\n\n    __call__ = read\n\n    def match_model_type(self, path: Path | list[Path]) -&gt; str | None:\n        \"\"\"True if the reader can read the file.\"\"\"\n        if self._skip_if_list and isinstance(path, list):\n            return None\n        if self._matcher is None:\n            return None\n        out = self._matcher(path)\n        if out is None or isinstance(out, str):\n            return out\n        raise TypeError(f\"Matcher {self._matcher!r} did not return a string.\")\n\n    def define_matcher(self, matcher: Callable[[Path | list[Path]], str | None]):\n        \"\"\"Mark a function as a matcher.\n\n        The matcher function should return a type string if the reader can read the\n        file, or None otherwise. If the reader function is annotated with `Path`, only\n        single Path input is forwarded to the matcher function, otherwise both `Path`\n        and `list[Path]` will be considered.\n\n        Examples\n        --------\n        A reader plugin that reads only text files:\n\n        ```python\n        @my_reader.define_matcher\n        def _(path: Path):\n            if path.suffix == \".txt\":\n                return \"text\"\n            return None\n        ```\n        \"\"\"\n        # NOTE: matcher don't have to return the priority. If users want to define\n        # a plugin that has different priority for different file type, they can just\n        # split the plugin function into two.\n        if self._matcher is self._undefined_matcher:\n            raise ValueError(f\"Matcher for {self!r} is already defined.\")\n        self._matcher = matcher\n        return matcher\n\n    def read_and_update_source(self, source: Path | list[Path]) -&gt; WidgetDataModel:\n        \"\"\"Update workflow to a local-reader method if it is not set.\"\"\"\n        model = self.read(source)\n        if len(model.workflow) == 0:\n            model = model._with_source(source=source, plugin=self.plugin)\n        return model\n</code></pre>"},{"location":"api/plugins/#himena.plugins.ReaderPlugin.define_matcher","title":"<code>define_matcher(matcher)</code>","text":"<p>Mark a function as a matcher.</p> <p>The matcher function should return a type string if the reader can read the file, or None otherwise. If the reader function is annotated with <code>Path</code>, only single Path input is forwarded to the matcher function, otherwise both <code>Path</code> and <code>list[Path]</code> will be considered.</p> <p>Examples:</p> <p>A reader plugin that reads only text files:</p> <pre><code>@my_reader.define_matcher\ndef _(path: Path):\n    if path.suffix == \".txt\":\n        return \"text\"\n    return None\n</code></pre> Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>def define_matcher(self, matcher: Callable[[Path | list[Path]], str | None]):\n    \"\"\"Mark a function as a matcher.\n\n    The matcher function should return a type string if the reader can read the\n    file, or None otherwise. If the reader function is annotated with `Path`, only\n    single Path input is forwarded to the matcher function, otherwise both `Path`\n    and `list[Path]` will be considered.\n\n    Examples\n    --------\n    A reader plugin that reads only text files:\n\n    ```python\n    @my_reader.define_matcher\n    def _(path: Path):\n        if path.suffix == \".txt\":\n            return \"text\"\n        return None\n    ```\n    \"\"\"\n    # NOTE: matcher don't have to return the priority. If users want to define\n    # a plugin that has different priority for different file type, they can just\n    # split the plugin function into two.\n    if self._matcher is self._undefined_matcher:\n        raise ValueError(f\"Matcher for {self!r} is already defined.\")\n    self._matcher = matcher\n    return matcher\n</code></pre>"},{"location":"api/plugins/#himena.plugins.ReaderPlugin.match_model_type","title":"<code>match_model_type(path)</code>","text":"<p>True if the reader can read the file.</p> Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>def match_model_type(self, path: Path | list[Path]) -&gt; str | None:\n    \"\"\"True if the reader can read the file.\"\"\"\n    if self._skip_if_list and isinstance(path, list):\n        return None\n    if self._matcher is None:\n        return None\n    out = self._matcher(path)\n    if out is None or isinstance(out, str):\n        return out\n    raise TypeError(f\"Matcher {self._matcher!r} did not return a string.\")\n</code></pre>"},{"location":"api/plugins/#himena.plugins.ReaderPlugin.read","title":"<code>read(path)</code>","text":"<p>Read file(s) and return a data model.</p> Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>def read(self, path: Path | list[Path]) -&gt; WidgetDataModel:\n    \"\"\"Read file(s) and return a data model.\"\"\"\n    if isinstance(path, list):\n        paths: list[Path] = []\n        for p in path:\n            if not p.exists():\n                raise FileNotFoundError(f\"File {p!r} does not exist.\")\n            paths.append(p)\n        out = self._func(paths)\n    else:\n        path = Path(path)\n        if not path.exists():\n            raise FileNotFoundError(f\"File {path!r} does not exist.\")\n        out = self._func(path)\n    if not isinstance(out, WidgetDataModel):\n        raise TypeError(f\"Reader plugin {self!r} did not return a WidgetDataModel.\")\n    return out\n</code></pre>"},{"location":"api/plugins/#himena.plugins.ReaderPlugin.read_and_update_source","title":"<code>read_and_update_source(source)</code>","text":"<p>Update workflow to a local-reader method if it is not set.</p> Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>def read_and_update_source(self, source: Path | list[Path]) -&gt; WidgetDataModel:\n    \"\"\"Update workflow to a local-reader method if it is not set.\"\"\"\n    model = self.read(source)\n    if len(model.workflow) == 0:\n        model = model._with_source(source=source, plugin=self.plugin)\n    return model\n</code></pre>"},{"location":"api/plugins/#himena.plugins.ReproduceArgs","title":"<code>ReproduceArgs</code>  <code>dataclass</code>","text":"<p>Command and its arguments to reproduce a user modification.</p> <p>Parameters:</p> Name Type Description Default <code>command_id</code> <code>str</code> required Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>@dataclass\nclass ReproduceArgs:\n    \"\"\"Command and its arguments to reproduce a user modification.\"\"\"\n\n    command_id: str\n    with_params: dict[str, Any] = field(default_factory=dict)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.WriterPlugin","title":"<code>WriterPlugin</code>","text":"Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>class WriterPlugin(_IOPluginBase):\n    def __init__(\n        self,\n        writer: Callable[[WidgetDataModel, Path], Any],\n        matcher: Callable[[Path | list[Path]], bool] | None = None,\n        *,\n        priority: int = 100,\n    ):\n        super().__init__(writer, matcher, priority=priority)\n        if arg := get_widget_data_model_type_arg(writer):\n            self._value_type_filter = arg\n        else:\n            self._value_type_filter = None\n\n    def write(self, model: WidgetDataModel, path: Path) -&gt; None:\n        return self._func(model, path)\n\n    __call__ = write\n\n    def match_input(self, model: WidgetDataModel, path: Path) -&gt; bool:\n        if self._value_type_filter is not None and not isinstance(\n            model.value, self._value_type_filter\n        ):\n            return False\n        return self._matcher(model, path)\n\n    def define_matcher(\n        self, matcher: Callable[[WidgetDataModel, Path], bool]\n    ) -&gt; WriterPlugin:\n        \"\"\"Define how to match the input data model and the save path to this writer.\n\n        Examples\n        --------\n        ```python\n        @my_writer.define_matcher\n        def _(model: WidgetDataModel, path: Path) -&gt; bool:\n            return path.suffix == \".txt\" and model.type == \"text\"\n        \"\"\"\n        self._matcher = matcher\n        return self\n</code></pre>"},{"location":"api/plugins/#himena.plugins.WriterPlugin.define_matcher","title":"<code>define_matcher(matcher)</code>","text":"<p>Define how to match the input data model and the save path to this writer.</p> <p>Examples:</p> <p>```python @my_writer.define_matcher def _(model: WidgetDataModel, path: Path) -&gt; bool:     return path.suffix == \".txt\" and model.type == \"text\"</p> Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>def define_matcher(\n    self, matcher: Callable[[WidgetDataModel, Path], bool]\n) -&gt; WriterPlugin:\n    \"\"\"Define how to match the input data model and the save path to this writer.\n\n    Examples\n    --------\n    ```python\n    @my_writer.define_matcher\n    def _(model: WidgetDataModel, path: Path) -&gt; bool:\n        return path.suffix == \".txt\" and model.type == \"text\"\n    \"\"\"\n    self._matcher = matcher\n    return self\n</code></pre>"},{"location":"api/plugins/#himena.plugins.add_default_status_tip","title":"<code>add_default_status_tip(short, long)</code>","text":"<p>Add a status tip that will be randomly shown in the status bar.</p> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>def add_default_status_tip(\n    short: str,\n    long: str,\n) -&gt; None:\n    \"\"\"Add a status tip that will be randomly shown in the status bar.\"\"\"\n    reg = AppActionRegistry.instance()\n    reg._app_tips.append(AppTip(short=str(short), long=str(long)))\n</code></pre>"},{"location":"api/plugins/#himena.plugins.config_field","title":"<code>config_field(default=MISSING, *, default_factory=MISSING, tooltip=None, label=None, choices=None, widget_type=None, enabled=None, visible=None, **kwargs)</code>","text":"<p>Field used for plugin config dataclass.</p> <pre><code>@dataclass\nclass MyPluginConfig:\n    my_field: str = config_field(\"abc\", tooltip=\"how to use this\")\n</code></pre> Source code in <code>src\\himena\\plugins\\config.py</code> <pre><code>def config_field(\n    default=MISSING,\n    *,\n    default_factory=MISSING,\n    tooltip: str | None = None,\n    label: str | None = None,\n    choices: list[str] | list[tuple[str, Any]] | None = None,\n    widget_type: Any | None = None,\n    enabled: bool | None = None,\n    visible: bool | None = None,\n    **kwargs,\n):\n    \"\"\"Field used for plugin config dataclass.\n\n    ```python\n    @dataclass\n    class MyPluginConfig:\n        my_field: str = config_field(\"abc\", tooltip=\"how to use this\")\n    ```\n    \"\"\"\n    metadata = kwargs.copy()\n    if tooltip is not None:\n        metadata[\"tooltip\"] = tooltip\n    if label is not None:\n        metadata[\"label\"] = label\n    if choices is not None:\n        metadata[\"choices\"] = choices\n    if enabled is not None:\n        metadata[\"enabled\"] = enabled\n    if visible is not None:\n        metadata[\"visible\"] = visible\n    if widget_type is not None:\n        metadata[\"widget_type\"] = widget_type\n\n    return field(\n        default=default,\n        default_factory=default_factory,\n        compare=False,\n        metadata=metadata,\n    )\n</code></pre>"},{"location":"api/plugins/#himena.plugins.configure_gui","title":"<code>configure_gui(f=None, *, title=None, preview=False, auto_close=True, show_parameter_labels=True, gui_options=None, result_as='window', **kwargs)</code>","text":"<pre><code>configure_gui(f: _F, *, title: str | None = None, preview: bool = False, auto_close: bool = True, show_parameter_labels: bool = True, gui_options: dict[str, Any] | None = None, result_as: Literal['window', 'below', 'right'] = 'window', **kwargs) -&gt; _F\n</code></pre><pre><code>configure_gui(*, title: str | None = None, preview: bool = False, auto_close: bool = True, show_parameter_labels: bool = True, gui_options: dict[str, Any] | None = None, result_as: Literal['window', 'below', 'right'] = 'window', **kwargs) -&gt; Callable[[_F], _F]\n</code></pre> <p>Configure the parametric GUI.</p> <p>This decorator sets the configuration options for the parametric GUI window.</p> <pre><code>@configure_gui(a={\"label\": \"A\", \"widget_type\": \"FloatSlider\"})\ndef my_func(a: float):\n    pass\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title of the parametric GUI window. If not provided, this title will be determined by the action title where this function is returned.</p> <code>None</code> <code>preview</code> <code>bool</code> <p>If true, a preview toggle switch will be added to the GUI window. When the switch is on, the function will be called and the result will be displayed. Note that <code>configure_gui</code> does not consider whether the preview is a heavy operation.</p> <code>False</code> <code>auto_close</code> <code>bool</code> <p>If true, the parametric GUI window will be closed automatically after the function is executed.</p> <code>True</code> <code>show_parameter_labels</code> <code>bool</code> <p>If true, the parameter names will be shown in the GUI window.</p> <code>True</code> <code>gui_options</code> <code>dict</code> <p>Additional GUI options to be passed to the <code>magicgui</code> decorator. Keys can also be passed as variable keyword arguments **kwargs.</p> <code>None</code> Source code in <code>src\\himena\\plugins\\_signature.py</code> <pre><code>def configure_gui(\n    f=None,\n    *,\n    title: str | None = None,\n    preview: bool = False,\n    auto_close: bool = True,\n    show_parameter_labels: bool = True,\n    gui_options: dict[str, Any] | None = None,\n    result_as: Literal[\"window\", \"below\", \"right\"] = \"window\",\n    **kwargs,\n):\n    \"\"\"Configure the parametric GUI.\n\n    This decorator sets the configuration options for the parametric GUI window.\n\n    ``` python\n    @configure_gui(a={\"label\": \"A\", \"widget_type\": \"FloatSlider\"})\n    def my_func(a: float):\n        pass\n    ```\n\n    Parameters\n    ----------\n    title : str, optional\n        The title of the parametric GUI window. If not provided, this title will be\n        determined by the action title where this function is returned.\n    preview : bool, default False\n        If true, a preview toggle switch will be added to the GUI window. When the\n        switch is on, the function will be called and the result will be displayed. Note\n        that `configure_gui` does not consider whether the preview is a heavy operation.\n    auto_close : bool, default True\n        If true, the parametric GUI window will be closed automatically after the\n        function is executed.\n    show_parameter_labels : bool, default True\n        If true, the parameter names will be shown in the GUI window.\n    gui_options : dict, optional\n        Additional GUI options to be passed to the `magicgui` decorator. Keys can also\n        be passed as variable keyword arguments **kwargs.\n    \"\"\"\n    kwargs = dict(**kwargs, **(gui_options or {}))\n\n    def _inner(f):\n        sig = inspect.signature(f)\n        new_params = sig.parameters.copy()\n        if var_kwargs_name := _get_var_kwargs_name(sig):\n            new_params.pop(var_kwargs_name)\n\n        for k, v in kwargs.items():\n            if k not in new_params:\n                if var_kwargs_name is None:\n                    raise TypeError(f\"{k!r} is not a valid parameter for {f!r}.\")\n                # This allows using **kwargs in the target function so that magicgui\n                # widget can be created for a variable number of parameters.\n                param = inspect.Parameter(name=k, kind=inspect.Parameter.KEYWORD_ONLY)\n            else:\n                param = sig.parameters[k]\n            if isinstance(v, dict) and \"annotation\" in v:\n                param_annotation = v.pop(\"annotation\")\n            else:\n                param_annotation = param.annotation\n            # unwrap Annotated types\n            if not _is_annotated(param_annotation):\n                annot = _prioritize_choices(param_annotation, v)\n                param = param.replace(annotation=Annotated[annot, v])\n            else:\n                typ, meta = _split_annotated_type(param_annotation)\n                meta.update(v)\n                typ = _prioritize_choices(typ, meta)\n                param = param.replace(annotation=Annotated[typ, meta])\n            new_params[k] = param\n        # update the signature with the normalize one\n        sig = sig.replace(parameters=list(new_params.values()))\n        f.__signature__ = sig\n        f.__annotations__ = {k: v.annotation for k, v in sig.parameters.items()}\n        if sig.return_annotation is not inspect.Parameter.empty:\n            f.__annotations__[\"return\"] = sig.return_annotation\n\n        GuiConfiguration(\n            title=title,\n            preview=preview,\n            auto_close=auto_close,\n            show_parameter_labels=show_parameter_labels,\n            result_as=result_as,\n        ).set(f)\n        return f\n\n    return _inner if f is None else _inner(f)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.configure_submenu","title":"<code>configure_submenu(submenu_id, title=None, *, group=None, order=None)</code>","text":"<p>Register a configuration for submenu(s).</p> <p>Parameters:</p> Name Type Description Default <code>submenu_id</code> <code>str or iterable of str</code> <p>Submenu ID(s) to configure.</p> required <code>title</code> <code>str</code> <p>Specify the title of the submenu.</p> <code>None</code> <code>group</code> <code>str</code> <p>Specify the group ID of the submenu.</p> <code>None</code> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>def configure_submenu(\n    submenu_id: str | Iterable[str],\n    title: str | None = None,\n    *,\n    group: str | None = None,\n    order: int | None = None,\n) -&gt; None:\n    \"\"\"Register a configuration for submenu(s).\n\n    Parameters\n    ----------\n    submenu_id : str or iterable of str\n        Submenu ID(s) to configure.\n    title : str, optional\n        Specify the title of the submenu.\n    group : str, optional\n        Specify the group ID of the submenu.\n    \"\"\"\n    if isinstance(submenu_id, str):\n        submenu_id = [submenu_id]\n    for sid in submenu_id:\n        if title is not None:\n            AppActionRegistry.instance()._submenu_titles[sid] = title\n        if group is not None:\n            AppActionRegistry.instance()._submenu_groups[sid] = group\n        if order is not None:\n            AppActionRegistry.instance()._submenu_order[sid] = order\n</code></pre>"},{"location":"api/plugins/#himena.plugins.install_plugins","title":"<code>install_plugins(app, plugins)</code>","text":"<p>Install plugins to the application.</p> Source code in <code>src\\himena\\plugins\\install.py</code> <pre><code>def install_plugins(\n    app: HimenaApplication, plugins: list[str]\n) -&gt; list[PluginInstallResult]:\n    \"\"\"Install plugins to the application.\"\"\"\n    from himena.plugins import AppActionRegistry\n    from himena.profile import load_app_profile\n\n    reg = AppActionRegistry.instance()\n    results = []\n    show_import_time = app.attributes.get(\"print_import_time\", False)\n    if show_import_time:\n        print(\"==================\")\n        print(\"Plugin import time\")\n        print(\"==================\")\n    for name in plugins:\n        if name in reg._installed_plugins:\n            continue\n        _time_0 = timer()\n        _exc = None\n        if isinstance(name, str):\n            if name.endswith(\".py\"):\n                if not Path(name).exists():\n                    _LOGGER.error(\n                        f\"Plugin file {name} does not exists but is listed in the \"\n                        \"application profile.\"\n                    )\n                    continue\n                import runpy\n\n                runpy.run_path(name)\n            else:\n                try:\n                    import_module(name)\n                except ModuleNotFoundError:\n                    _LOGGER.error(\n                        f\"Plugin module {name} is not installed but is listed in the \"\n                        \"application profile.\"\n                    )\n                    continue\n                except Exception as e:\n                    msg = \"\".join(\n                        traceback.format_exception(type(e), e, e.__traceback__)\n                    )\n                    _LOGGER.error(\n                        f\"Error installing plugin {name}, traceback follows:\\n{msg}\"\n                    )\n                    _exc = e\n        else:\n            raise TypeError(f\"Invalid plugin type: {type(name)}\")\n        _msec = (timer() - _time_0) * 1000\n        if show_import_time and _exc is None:\n            color = _color_for_time(_msec)\n            print(f\"{color}{name}\\t{_msec:.3f} msec\\033[0m\")\n        results.append(PluginInstallResult(name, _msec, _exc))\n    reg.install_to(app)\n    reg._installed_plugins.extend(plugins)\n    prof = load_app_profile(app.name)\n\n    for k, cfg in reg._plugin_default_configs.items():\n        prof.plugin_configs.setdefault(k, cfg.as_dict())\n\n    prof.save()\n    return results\n</code></pre>"},{"location":"api/plugins/#himena.plugins.override_keybindings","title":"<code>override_keybindings(app, prof)</code>","text":"<p>Override keybindings in the application.</p> Source code in <code>src\\himena\\plugins\\install.py</code> <pre><code>def override_keybindings(app: HimenaApplication, prof: AppProfile) -&gt; None:\n    \"\"\"Override keybindings in the application.\"\"\"\n    for ko in prof.keybinding_overrides:\n        if kb := app.keybindings.get_keybinding(ko.command_id):\n            app.keybindings._keybindings.remove(kb)\n        app.keybindings.register_keybinding_rule(\n            ko.command_id,\n            KeyBindingRule(primary=ko.key),\n        )\n</code></pre>"},{"location":"api/plugins/#himena.plugins.register_conversion_rule","title":"<code>register_conversion_rule(*args, **kwargs)</code>","text":"<pre><code>register_conversion_rule(func: _F, type_from: str, type_to: str, *, keybindings: KeyBindingsType | None = None, command_id: str | None = None) -&gt; _F\n</code></pre><pre><code>register_conversion_rule(type_from: str, type_to: str, *, keybindings: KeyBindingsType | None = None, command_id: str | None = None) -&gt; Callable[[_F], _F]\n</code></pre> <p>Register a function as a conversion rule.</p> <p>A conversion rule will be added to the model menu under \"Convert &gt; ...\" submenu. Essentially, this method does nothing more than <code>register_function</code>, but using this registration method is recommended for the sake of clarity and following the conventions.</p> <pre><code>from himena.plugins import register_conversion_rule\n\n@register_conversion_rule(\"text\", \"table\")\ndef convert_text_to_table(model: WidgetDataModel) -&gt; WidgetDataModel:\n    ...  # convert the data type\n</code></pre> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>def register_conversion_rule(*args, **kwargs):\n    \"\"\"Register a function as a conversion rule.\n\n    A conversion rule will be added to the model menu under \"Convert &gt; ...\" submenu.\n    Essentially, this method does nothing more than `register_function`, but using this\n    registration method is recommended for the sake of clarity and following the\n    conventions.\n\n    ```python\n    from himena.plugins import register_conversion_rule\n\n    @register_conversion_rule(\"text\", \"table\")\n    def convert_text_to_table(model: WidgetDataModel) -&gt; WidgetDataModel:\n        ...  # convert the data type\n    ```\n    \"\"\"\n    if len(args) == 0:\n        no_func = True\n    else:\n        if isinstance(args[0], str):\n            return register_conversion_rule(None, *args, **kwargs)\n        no_func = args[0] is None\n\n    def inner(func):\n        annot = getattr(func, \"__annotations__\", {})\n        annot.setdefault(\"return\", WidgetDataModel)\n        func.__annotations__ = annot\n        action = _make_conversion_rule(func, *args, **kwargs)\n        AppActionRegistry.instance().add_action(action)\n        return func\n\n    return inner if no_func else inner(args[0])\n</code></pre>"},{"location":"api/plugins/#himena.plugins.register_dock_widget_action","title":"<code>register_dock_widget_action(widget_factory=None, *, menus=None, title=None, area=DockArea.RIGHT, allowed_areas=None, keybindings=None, singleton=False, plugin_configs=None, command_id=None, icon=None)</code>","text":"<pre><code>register_dock_widget_action(widget_factory: _F, *, menus: str | Sequence[str] | None = None, title: str | None = None, area: DockArea | DockAreaString = DockArea.RIGHT, allowed_areas: Sequence[DockArea | DockAreaString] | None = None, keybindings: KeyBindingsType | None = None, singleton: bool = False, plugin_configs: PluginConfigType | None = None, command_id: str | None = None, icon: str | None = None) -&gt; _F\n</code></pre><pre><code>register_dock_widget_action(widget_factory: None = None, *, menus: str | Sequence[str] | None = None, title: str | None = None, area: DockArea | DockAreaString = DockArea.RIGHT, allowed_areas: Sequence[DockArea | DockAreaString] | None = None, keybindings: KeyBindingsType | None = None, singleton: bool = False, plugin_configs: PluginConfigType | None = None, command_id: str | None = None, icon: str | None = None) -&gt; Callable[[_F], _F]\n</code></pre> <p>Register a widget factory as a dock widget function.</p> <p>Parameters:</p> Name Type Description Default <code>widget_factory</code> <code>callable</code> <p>Class of dock widget, or a factory function for the dock widget.</p> <code>None</code> <code>menus</code> <code>str or sequence of str</code> <p>Menu ID or list of menu IDs where the action will be added.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title of the dock widget.</p> <code>None</code> <code>area</code> <code>DockArea or DockAreaString</code> <p>Initial area of the dock widget.</p> <code>RIGHT</code> <code>allowed_areas</code> <code>sequence of DockArea or DockAreaString</code> <p>List of areas that is allowed for the dock widget.</p> <code>None</code> <code>keybindings</code> <code>sequence of keybinding rule</code> <p>Keybindings to trigger the dock widget.</p> <code>None</code> <code>singleton</code> <code>bool</code> <p>If true, the registered dock widget will constructed only once.</p> <code>False</code> <code>plugin_configs</code> <code>(dict, dataclass or BaseModel)</code> <p>Default configuration for the plugin. This config will be saved in the application profile and will be used to update the dock widget via the method <code>update_configs(self, cfg) -&gt; None</code>. This argument must be a dict, dataclass or pydantic.BaseModel. If a dict, the format must be like:</p> <pre><code>plugin_configs = {\n   \"config_0\": {\"value\": 0, \"tooltip\": ...},\n   \"config_1\": {\"value\": \"xyz\", \"tooltip\": ...},\n}\n</code></pre> <p>where only \"value\" is required. If a dataclass or pydantic.BaseModel, field objects will be used instead of the dict.</p> <pre><code>@dataclass\nclass MyPluginConfig:\n    config_0: int = Field(default=0, metadata={\"tooltip\": ...})\n    config_1: str = Field(default=\"xyz\", metadata={\"tooltip\": ...})\nplugin_configs = MyPluginConfig()\n</code></pre> <code>None</code> <code>command_id</code> <code>str</code> <p>Command ID. If not given, the function name will be used.</p> <code>None</code> <code>icon</code> <code>str</code> <p>Iconify icon key.</p> <code>None</code> Source code in <code>src\\himena\\plugins\\widget_plugins.py</code> <pre><code>def register_dock_widget_action(\n    widget_factory=None,\n    *,\n    menus: str | Sequence[str] | None = None,\n    title: str | None = None,\n    area: DockArea | DockAreaString = DockArea.RIGHT,\n    allowed_areas: Sequence[DockArea | DockAreaString] | None = None,\n    keybindings=None,\n    singleton: bool = False,\n    plugin_configs: PluginConfigType | None = None,\n    command_id: str | None = None,\n    icon: str | None = None,\n):\n    \"\"\"Register a widget factory as a dock widget function.\n\n    Parameters\n    ----------\n    widget_factory : callable, optional\n        Class of dock widget, or a factory function for the dock widget.\n    menus : str or sequence of str, optional\n        Menu ID or list of menu IDs where the action will be added.\n    title : str, optional\n        Title of the dock widget.\n    area : DockArea or DockAreaString, optional\n        Initial area of the dock widget.\n    allowed_areas : sequence of DockArea or DockAreaString, optional\n        List of areas that is allowed for the dock widget.\n    keybindings : sequence of keybinding rule, optional\n        Keybindings to trigger the dock widget.\n    singleton : bool, default False\n        If true, the registered dock widget will constructed only once.\n    plugin_configs : dict, dataclass or pydantic.BaseModel, optional\n        Default configuration for the plugin. This config will be saved in the\n        application profile and will be used to update the dock widget via the method\n        `update_configs(self, cfg) -&gt; None`. This argument must be a dict, dataclass\n        or pydantic.BaseModel. If a dict, the format must be like:\n\n        ``` python\n        plugin_configs = {\n           \"config_0\": {\"value\": 0, \"tooltip\": ...},\n           \"config_1\": {\"value\": \"xyz\", \"tooltip\": ...},\n        }\n        ```\n\n        where only \"value\" is required. If a dataclass or pydantic.BaseModel, field\n        objects will be used instead of the dict.\n\n        ``` python\n        @dataclass\n        class MyPluginConfig:\n            config_0: int = Field(default=0, metadata={\"tooltip\": ...})\n            config_1: str = Field(default=\"xyz\", metadata={\"tooltip\": ...})\n        plugin_configs = MyPluginConfig()\n        ```\n    command_id : str, optional\n        Command ID. If not given, the function name will be used.\n    icon : str, optional\n        Iconify icon key.\n    \"\"\"\n    kbs = normalize_keybindings(keybindings)\n    if menus is None:\n        menus = [MenuId.TOOLS_DOCK]\n\n    def _inner(wf: Callable):\n        _command_id = command_id_from_func(wf, command_id)\n        _callback = DockWidgetCallback(\n            wf,\n            title=title,\n            area=area,\n            allowed_areas=allowed_areas,\n            singleton=singleton,\n            uuid=uuid.uuid4(),\n            command_id=_command_id,\n        )\n        if singleton:\n            toggle_rule = ToggleRule(get_current=_callback.widget_visible)\n        else:\n            toggle_rule = None\n        action = Action(\n            id=_command_id,\n            title=_callback._title,\n            tooltip=tooltip_from_func(wf),\n            callback=_callback,\n            menus=norm_menus(menus),\n            keybindings=kbs,\n            toggled=toggle_rule,\n            icon=icon,\n            icon_visible_in_menu=False,\n        )\n        reg = AppActionRegistry.instance()\n        reg.add_action(action)\n        if plugin_configs:\n            cfg_type = type(plugin_configs)\n            reg._plugin_default_configs[_command_id] = PluginConfigTuple(\n                _callback._title,\n                plugin_configs,\n                cfg_type,\n            )\n        return wf\n\n    return _inner if widget_factory is None else _inner(widget_factory)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.register_function","title":"<code>register_function(func=None, *, menus='plugins', title=None, types=None, enablement=None, keybindings=None, run_async=False, command_id=None, group=None, icon=None, palette=True)</code>","text":"<pre><code>register_function(*, menus: str | Sequence[str] = 'plugins', title: str | None = None, types: str | Sequence[str] | None = None, enablement: BoolOp | None = None, keybindings: Sequence[KeyBindingRule] | None = None, run_async: bool = False, command_id: str | None = None, group: str | None = None, icon: str | None = None, palette: bool = True) -&gt; None\n</code></pre><pre><code>register_function(func: _F, *, menus: str | Sequence[str] = 'plugins', title: str | None = None, types: str | Sequence[str] | None = None, enablement: BoolOp | None = None, keybindings: Sequence[KeyBindingRule] | None = None, run_async: bool = False, command_id: str | None = None, group: str | None = None, icon: str | None = None, palette: bool = True) -&gt; _F\n</code></pre> <p>Register a function as a callback of a plugin action.</p> <p>This function can be used either as a decorator or a simple function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>Function to register as an action.</p> <code>None</code> <code>menus</code> <code>str or sequence of str</code> <p>Menu(s) to add the action. Submenus are separated by <code>/</code>.</p> <code>\"plugins\"</code> <code>title</code> <code>str</code> <p>Title of the action. Name of the function will be used if not given.</p> <code>None</code> <code>types</code> <p>The <code>type</code> parameter(s) allowed as the WidgetDataModel. If this parameter is given, action will be grayed out if the active window does not satisfy the listed types.</p> <code>None</code> <code>enablement</code> <p>Expression that describes when the action will be enabled. As this argument is a generalized version of <code>types</code> argument, you cannot use both of them.</p> <code>None</code> <code>run_async</code> <code>bool</code> <p>If true, the function will be executed asynchronously. Note that if the function updates the GUI, running it asynchronously may cause issues.</p> <code>False</code> <code>command_id</code> <code>str</code> <p>Command ID. If not given, the function qualname will be used.</p> <code>None</code> <code>group</code> <code>str</code> <p>Group name to which this command belongs. This parameter follows the app-model rule.</p> <code>None</code> <code>icon</code> <code>str</code> <p>Iconify icon key to use for the action.</p> <code>None</code> <code>palette</code> <code>bool</code> <p>If true, the action will be added to the command palette.</p> <code>True</code> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>def register_function(\n    func=None,\n    *,\n    menus=\"plugins\",\n    title=None,\n    types=None,\n    enablement=None,\n    keybindings=None,\n    run_async=False,\n    command_id=None,\n    group=None,\n    icon=None,\n    palette=True,\n):\n    \"\"\"Register a function as a callback of a plugin action.\n\n    This function can be used either as a decorator or a simple function.\n\n    Parameters\n    ----------\n    func : callable, optional\n        Function to register as an action.\n    menus : str or sequence of str, default \"plugins\"\n        Menu(s) to add the action. Submenus are separated by `/`.\n    title : str, optional\n        Title of the action. Name of the function will be used if not given.\n    types: str or sequence of str, optional\n        The `type` parameter(s) allowed as the WidgetDataModel. If this parameter\n        is given, action will be grayed out if the active window does not satisfy\n        the listed types.\n    enablement: Expr, optional\n        Expression that describes when the action will be enabled. As this argument\n        is a generalized version of `types` argument, you cannot use both of them.\n    run_async : bool, default False\n        If true, the function will be executed asynchronously. Note that if the function\n        updates the GUI, running it asynchronously may cause issues.\n    command_id : str, optional\n        Command ID. If not given, the function qualname will be used.\n    group : str, optional\n        Group name to which this command belongs. This parameter follows the app-model\n        rule.\n    icon : str, optional\n        Iconify icon key to use for the action.\n    palette : bool, default True\n        If true, the action will be added to the command palette.\n    \"\"\"\n\n    def _inner(f: _F) -&gt; _F:\n        action = make_action_for_function(\n            f,\n            menus=menus,\n            title=title,\n            types=types,\n            enablement=enablement,\n            keybindings=keybindings,\n            run_async=run_async,\n            command_id=command_id,\n            group=group,\n            icon=icon,\n            palette=palette,\n        )\n        AppActionRegistry.instance().add_action(action)\n        return f\n\n    return _inner if func is None else _inner(func)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.register_modification_tracker","title":"<code>register_modification_tracker(type)</code>","text":"<p>Register a modification tracker.</p> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>def register_modification_tracker(\n    type: str,\n) -&gt; Callable[[Callable[[_T, _T], ReproduceArgs]], Callable[[_T, _T], ReproduceArgs]]:\n    \"\"\"Register a modification tracker.\"\"\"\n    reg = AppActionRegistry.instance()\n    if type in reg._modification_trackers:\n        raise ValueError(f\"Modification tracker for {type} already exists.\")\n\n    def inner(fn):\n        reg._modification_trackers[type] = fn\n        return fn\n\n    return inner\n</code></pre>"},{"location":"api/plugins/#himena.plugins.register_previewer_class","title":"<code>register_previewer_class(type_, widget_class)</code>","text":"<p>Register a widget class for previewing the given model type.</p> Source code in <code>src\\himena\\plugins\\widget_class.py</code> <pre><code>def register_previewer_class(type_: str, widget_class: type):\n    \"\"\"Register a widget class for previewing the given model type.\"\"\"\n\n    def inner(wcls):\n        import himena.qt\n\n        widget_id = get_widget_class_id(wcls)\n        if existing_class := _WIDGET_ID_TO_WIDGET_CLASS.get(widget_id):\n            raise ValueError(\n                f\"Widget class with ID {widget_id!r} already exists ({existing_class}).\"\n            )\n        _WIDGET_ID_TO_WIDGET_CLASS[widget_id] = wcls\n        himena.qt.register_widget_class(type_, wcls, priority=-10)\n        fn = OpenDataInFunction(type_, wcls)\n        AppActionRegistry.instance().add_action(fn.to_action(), is_dynamic=True)\n        fn = PreviewDataInFunction(type_, wcls)\n        AppActionRegistry.instance().add_action(fn.to_action(), is_dynamic=True)\n        return type_\n\n    return inner if widget_class is None else inner(widget_class)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.register_reader_plugin","title":"<code>register_reader_plugin(reader=None, *, priority=100)</code>","text":"<pre><code>register_reader_plugin(reader: Callable[[Path | list[Path]], WidgetDataModel], *, priority: int = 100) -&gt; ReaderPlugin\n</code></pre><pre><code>register_reader_plugin(*, priority: int = 100) -&gt; Callable[[Callable[[Path | list[Path]], WidgetDataModel]], ReaderPlugin]\n</code></pre> <p>Register a reader plugin function.</p> <p>Decorate a function to register it as a reader plugin. The function should take a <code>Path</code> or a list of <code>Path</code>s as input and return a WidgetDataModel.</p> <pre><code>from himena.plugins import register_reader_plugin\n\n@register_reader_plugin\ndef my_reader(path) -&gt; WidgetDataModel:\n    ...  # read file and return a WidgetDataModel\n</code></pre> <p>You will need to define a matcher function to tell whether this function can read a path using <code>define_matcher</code> method.</p> <pre><code>from himena import StandardType\n\n@my_reader.define_matcher\ndef _(path: Path):\n    if path.suffix == \".txt\":\n        return StandardType.TEXT  # StandardType.TEXT == \"text\"\n    return None\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>int</code> <p>Priority of choosing this reader when multiple readers are available. The default value 100 is higher than the himena builtin readers, so that your reader will prioritized over the default ones. If priority is less than 0, it will not be used unless users intentionally choose this plugin.</p> <code>100</code> Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>def register_reader_plugin(reader=None, *, priority=100):\n    \"\"\"Register a reader plugin function.\n\n    Decorate a function to register it as a reader plugin. The function should take a\n    `Path` or a list of `Path`s as input and return a WidgetDataModel.\n\n    ``` python\n    from himena.plugins import register_reader_plugin\n\n    @register_reader_plugin\n    def my_reader(path) -&gt; WidgetDataModel:\n        ...  # read file and return a WidgetDataModel\n    ```\n\n    You will need to define a matcher function to tell whether this function can read\n    a path using `define_matcher` method.\n\n    ```python\n    from himena import StandardType\n\n    @my_reader.define_matcher\n    def _(path: Path):\n        if path.suffix == \".txt\":\n            return StandardType.TEXT  # StandardType.TEXT == \"text\"\n        return None\n    ```\n\n    Parameters\n    ----------\n    priority : int, default 100\n        Priority of choosing this reader when multiple readers are available. The\n        default value 100 is higher than the himena builtin readers, so that your reader\n        will prioritized over the default ones. If priority is less than 0, it will not\n        be used unless users intentionally choose this plugin.\n    \"\"\"\n\n    def _inner(func):\n        if not callable(func):\n            raise ValueError(\"Reader plugin must be callable.\")\n        ins = ReaderStore().instance()\n\n        reader_plugin = ReaderPlugin(func, priority=priority)\n        ins.add_reader(reader_plugin)\n        return reader_plugin\n\n    return _inner if reader is None else _inner(reader)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.register_widget_class","title":"<code>register_widget_class(type_, widget_class=None, priority=100, plugin_configs=None)</code>","text":"<pre><code>register_widget_class(type_: str, widget_class: _T, priority: int = 100, plugin_configs: PluginConfigType | None = None) -&gt; _T\n</code></pre><pre><code>register_widget_class(type_: str, widget_class: None, priority: int = 100, plugin_configs: PluginConfigType | None = None) -&gt; Callable[[_T], _T]\n</code></pre> <p>Register a frontend widget class for the given model type.</p> <p>The <code>__init__</code> method of the registered class must not take any argument. The class must implement <code>update_model</code> method to update the widget state from a WidgetDataModel.</p> <pre><code>@register_widget(\"text\")\nclass MyTextEdit(QtW.QPlainTextEdit):\n    def update_model(self, model: WidgetDataModel):\n        self.setPlainText(model.value)\n</code></pre> <p>There are other method names that can be implemented to make the widget more functional.</p> <ul> <li><code>to_model(self) -&gt; WidgetDataModel</code>:</li> <li><code>model_type(self) -&gt; str</code>:</li> <li><code>control_widget(self) -&gt; &lt;widget&gt;</code>:</li> <li><code>is_modified(self) -&gt; bool</code>:</li> <li><code>set_modified(self, modified: bool)</code>:</li> <li><code>size_hint(self) -&gt; tuple[int, int]</code>:</li> <li><code>is_editable(self) -&gt; bool</code>:</li> <li><code>set_editable(self, editable: bool)</code>:</li> <li><code>dropped_callback(self, other: WidgetDataModel)</code>:</li> <li><code>allowed_drop_types(self) -&gt; list[str]</code>:</li> <li><code>display_name(cls) -&gt; str</code>:</li> <li><code>theme_changed_callback(self, theme: Theme)</code>:</li> <li><code>widget_activated_callback(self)</code>:</li> <li><code>widget_closed_callback(self)</code>:</li> <li><code>widget_resized_callback(self, size_old, size_new)</code>:</li> </ul> Source code in <code>src\\himena\\plugins\\widget_class.py</code> <pre><code>def register_widget_class(type_, widget_class=None, priority=100, plugin_configs=None):\n    \"\"\"Register a frontend widget class for the given model type.\n\n    The `__init__` method of the registered class must not take any argument. The class\n    must implement `update_model` method to update the widget state from a\n    WidgetDataModel.\n\n    ``` python\n    @register_widget(\"text\")\n    class MyTextEdit(QtW.QPlainTextEdit):\n        def update_model(self, model: WidgetDataModel):\n            self.setPlainText(model.value)\n    ```\n\n    There are other method names that can be implemented to make the widget more\n    functional.\n\n    - `to_model(self) -&gt; WidgetDataModel`:\n    - `model_type(self) -&gt; str`:\n    - `control_widget(self) -&gt; &lt;widget&gt;`:\n    - `is_modified(self) -&gt; bool`:\n    - `set_modified(self, modified: bool)`:\n    - `size_hint(self) -&gt; tuple[int, int]`:\n    - `is_editable(self) -&gt; bool`:\n    - `set_editable(self, editable: bool)`:\n    - `dropped_callback(self, other: WidgetDataModel)`:\n    - `allowed_drop_types(self) -&gt; list[str]`:\n    - `display_name(cls) -&gt; str`:\n    - `theme_changed_callback(self, theme: Theme)`:\n    - `widget_activated_callback(self)`:\n    - `widget_closed_callback(self)`:\n    - `widget_resized_callback(self, size_old, size_new)`:\n    \"\"\"\n\n    def inner(wcls):\n        import himena.qt\n\n        widget_id = get_widget_class_id(wcls)\n        is_multi_registration = False\n        if existing_class := _WIDGET_ID_TO_WIDGET_CLASS.get(widget_id):\n            if existing_class is wcls:\n                is_multi_registration = True\n            else:\n                raise ValueError(\n                    f\"Widget class with ID {widget_id!r} already assigned for \"\n                    f\"{existing_class}; you must assign a unique ID for each class.\"\n                )\n        _WIDGET_ID_TO_WIDGET_CLASS[widget_id] = wcls\n        himena.qt.register_widget_class(type_, wcls, priority=priority)\n        fn = OpenDataInFunction(type_, wcls)\n        reg = AppActionRegistry.instance()\n        reg.add_action(fn.to_action(), is_dynamic=True)\n        if not is_multi_registration:\n            wcls.__himena_model_type__ = type_\n\n        if plugin_configs:\n            cfg_type = type(plugin_configs)\n            if widget_id in reg._plugin_default_configs:\n                warnings.warn(\n                    f\"Plugin config for {widget_id!r} already registered; \"\n                    f\"overwriting with new config {plugin_configs}.\",\n                    UserWarning,\n                    stacklevel=2,\n                )\n            reg._plugin_default_configs[widget_id] = PluginConfigTuple(\n                get_display_name(wcls, sep=\" \", class_id=False),\n                plugin_configs,\n                cfg_type,\n            )\n        return wcls\n\n    return inner if widget_class is None else inner(widget_class)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.register_writer_plugin","title":"<code>register_writer_plugin(writer=None, *, priority=100)</code>","text":"<pre><code>register_writer_plugin(writer: Callable[[WidgetDataModel, Path], Any], *, priority: int = 100) -&gt; WriterPlugin\n</code></pre><pre><code>register_writer_plugin(*, priority: int = 100) -&gt; Callable[[Callable[[WidgetDataModel, Path], Any]], WriterPlugin]\n</code></pre> <p>Register a writer plugin function.</p> <p>Decorate a function to register it as a writer plugin. The function should take a <code>Path</code> as a save path and a <code>WidgetDataModel</code>.</p> <pre><code>from himena.plugins import register_writer_plugin\n\n@register_writer_plugin\ndef my_writer(path, model) -&gt; None:\n    ...  # read file and return a WidgetDataModel\n</code></pre> <p>You will need to define a matcher function to tell whether this function can write a data model to the specified path using <code>define_matcher</code> method. Unlike reader plugins, matchers should return bool.</p> <pre><code>from himena import StandardType, WidgetDataModel\n\n@my_writer.define_matcher\ndef _(path: Path, model: WidgetDataModel):\n    if path.suffix == \".txt\":\n        return True\n    return False\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>int</code> <p>Priority of choosing this writer when multiple writers are available. The default value 100 is higher than the himena builtin writers, so that your writer will prioritized over the default ones. If priority is less than 0, it will not be used unless users intentionally choose this plugin.</p> <code>100</code> Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>def register_writer_plugin(writer=None, *, priority=100):\n    \"\"\"Register a writer plugin function.\n\n    Decorate a function to register it as a writer plugin. The function should take a\n    `Path` as a save path and a `WidgetDataModel`.\n\n    ``` python\n    from himena.plugins import register_writer_plugin\n\n    @register_writer_plugin\n    def my_writer(path, model) -&gt; None:\n        ...  # read file and return a WidgetDataModel\n    ```\n\n    You will need to define a matcher function to tell whether this function can write\n    a data model to the specified path using `define_matcher` method. Unlike reader\n    plugins, matchers should return bool.\n\n    ```python\n    from himena import StandardType, WidgetDataModel\n\n    @my_writer.define_matcher\n    def _(path: Path, model: WidgetDataModel):\n        if path.suffix == \".txt\":\n            return True\n        return False\n    ```\n\n    Parameters\n    ----------\n    priority : int, default 100\n        Priority of choosing this writer when multiple writers are available. The\n        default value 100 is higher than the himena builtin writers, so that your writer\n        will prioritized over the default ones. If priority is less than 0, it will not\n        be used unless users intentionally choose this plugin.\n    \"\"\"\n\n    def _inner(func):\n        if not callable(func):\n            raise ValueError(\"Writer plugin must be callable.\")\n        ins = WriterStore().instance()\n\n        writer_plugin = WriterPlugin(func, priority=priority)\n        ins.add_writer(writer_plugin)\n        return writer_plugin\n\n    return _inner if writer is None else _inner(writer)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.update_config_context","title":"<code>update_config_context(config_class, plugin_id=None, *, update_widget=False)</code>","text":"<pre><code>update_config_context(plugin_id: str, *, update_widget: bool = False) -&gt; Iterator[PluginConfigType]\n</code></pre><pre><code>update_config_context(config_class: type[_C], plugin_id: str | None = None, *, update_widget: bool = False) -&gt; Iterator[_C]\n</code></pre> <p>Context manager for updating plugin config.</p> Source code in <code>src\\himena\\plugins\\widget_plugins.py</code> <pre><code>@contextmanager\ndef update_config_context(\n    config_class: type | str,\n    plugin_id: str | None = None,\n    *,\n    update_widget: bool = False,\n):\n    \"\"\"Context manager for updating plugin config.\"\"\"\n    from himena.widgets import current_instance\n\n    ui = current_instance()\n    if isinstance(config_class, str):\n        if plugin_id is not None:\n            raise TypeError(\"No overload matches the input.\")\n        _config_class, _plugin_id = None, config_class\n    else:\n        _config_class = config_class\n        _plugin_id = plugin_id\n\n    reg = AppActionRegistry.instance()\n    if _plugin_id is None:\n        for _id, _config in reg._plugin_default_configs.items():\n            if isinstance(_config.config, _config_class):\n                _plugin_id = _id\n                break\n        else:\n            raise ValueError(\n                f\"Cannot find plugin ID for the config class: {config_class}.\"\n            )\n    plugin_config = reg._plugin_default_configs[_plugin_id]\n    if not isinstance(plugin_config.config, _config_class):\n        raise TypeError(\n            f\"Plugin ID {_plugin_id} does not match the config class {config_class}.\"\n        )\n    cur_config = plugin_config.config\n    yield cur_config\n    prof = ui.app_profile\n    all_configs = prof.plugin_configs.copy()\n\n    cfg_dict = all_configs[_plugin_id] = plugin_config.as_dict()\n    prof.with_plugin_configs(all_configs).save()\n\n    # update existing dock widgets with the new config\n    if update_widget and (cb := WidgetCallbackBase.instance_for_command_id(_plugin_id)):\n        params = {}\n        for key, opt in cfg_dict.items():\n            params[key] = opt[\"value\"]\n        for widget in cb._all_widgets:\n            # the internal widget should always has the method \"update_configs\"\n            widget.update_configs(params)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.validate_protocol","title":"<code>validate_protocol(f)</code>","text":"<p>Check if the method is allowed as a himena protocol.</p> Source code in <code>src\\himena\\plugins\\_checker.py</code> <pre><code>def validate_protocol(f: _T) -&gt; _T:\n    \"\"\"Check if the method is allowed as a himena protocol.\"\"\"\n    if f.__name__ not in _ALLOWED_METHODS:\n        raise ValueError(f\"Method {f} is not an allowed protocol name.\")\n    return f\n</code></pre>"},{"location":"api/plugins/#himena.plugins.when_command_executed","title":"<code>when_command_executed(model_type, command_id)</code>","text":"<p>Create an interface for adding command suggestions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; (\n...     reg.when_command_executed(\"table\", \"sort-table\")\n...        .add_command_suggestion(\"scatter-plot\")\n...        .add_command_suggestion(\"line-plot\")\n... )\n</code></pre> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>def when_command_executed(\n    model_type: str,\n    command_id: str,\n):\n    \"\"\"Create an interface for adding command suggestions.\n\n    Examples\n    --------\n    &gt;&gt;&gt; (\n    ...     reg.when_command_executed(\"table\", \"sort-table\")\n    ...        .add_command_suggestion(\"scatter-plot\")\n    ...        .add_command_suggestion(\"line-plot\")\n    ... )\n    \"\"\"\n    reg = AppActionRegistry.instance()._action_hint_reg\n    return reg.when_command_executed(model_type, command_id)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.when_reader_used","title":"<code>when_reader_used(model_type, plugins=None)</code>","text":"<p>Create an interface for adding command suggestions when a reader is used.</p> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>def when_reader_used(\n    model_type: str,\n    plugins: list[str] | None = None,\n):\n    \"\"\"Create an interface for adding command suggestions when a reader is used.\"\"\"\n    reg = AppActionRegistry.instance()._action_hint_reg\n    return reg.when_reader_used(model_type, plugins=plugins)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.widget_classes","title":"<code>widget_classes()</code>","text":"<p>Get the mapping of widget ID to widget class.</p> Source code in <code>src\\himena\\plugins\\widget_class.py</code> <pre><code>def widget_classes() -&gt; MappingProxyType[str, type]:\n    \"\"\"Get the mapping of widget ID to widget class.\"\"\"\n    from himena.qt.registry._api import _APP_TYPE_TO_QWIDGET\n\n    out = {}\n    for widget_list in _APP_TYPE_TO_QWIDGET.values():\n        for item in widget_list:\n            out[item.type] = item.widget_class\n    return MappingProxyType(out)\n</code></pre>"},{"location":"api/profile/","title":"himena.profile","text":""},{"location":"api/profile/#himena.profile.AppProfile","title":"<code>AppProfile</code>","text":"<p>Model of a profile.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the profile.</p> <code>'default'</code> <code>version</code> <code>str</code> <p>Version of this profile created.</p> <code>'0.0.12'</code> <code>plugins</code> <code>list[str]</code> <p>List of plugins to load.</p> <code>['himena_builtins.qt.console', 'himena_builtins.qt.explorer', 'himena_builtins.qt.favorites', 'himena_builtins.qt.history', 'himena_builtins.qt.output', 'himena_builtins.qt.plot', 'himena_builtins.qt.array', 'himena_builtins.qt.basic', 'himena_builtins.qt.dataframe', 'himena_builtins.qt.image', 'himena_builtins.qt.ipynb', 'himena_builtins.qt.rois', 'himena_builtins.qt.stack', 'himena_builtins.qt.table', 'himena_builtins.qt.text', 'himena_builtins.tools.array', 'himena_builtins.tools.conversions', 'himena_builtins.tools.dataframe', 'himena_builtins.tools.dict', 'himena_builtins.tools.image', 'himena_builtins.tools.others', 'himena_builtins.tools.plot', 'himena_builtins.tools.table', 'himena_builtins.tools.text', 'himena_builtins.io', 'himena_builtins.new', 'himena_builtins.user_modifications']</code> <code>theme</code> <code>str</code> <p>Theme to use.</p> <code>'light-green'</code> <code>startup_commands</code> <code>list[tuple[str, Optional[dict[str, Any]]]]</code> <p>Startup commands that will be executed when the app starts.</p> <code>&lt;dynamic&gt;</code> <code>keybinding_overrides</code> <code>list[KeyBindingOverride]</code> <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\profile.py</code> <pre><code>class AppProfile(BaseModel):\n    \"\"\"Model of a profile.\"\"\"\n\n    name: str = Field(\n        default=\"default\",\n        description=\"Name of the profile.\",\n        frozen=True,\n    )\n    version: str = Field(\n        default_factory=_current_version,\n        description=\"Version of this profile created.\",\n        frozen=True,\n    )\n    plugins: list[str] = Field(\n        default_factory=_default_plugins, description=\"List of plugins to load.\"\n    )\n    theme: str = Field(default=\"light-green\", description=\"Theme to use.\")\n    startup_commands: list[tuple[str, dict[str, Any] | None]] = Field(\n        default_factory=list,\n        description=\"Startup commands that will be executed when the app starts.\",\n    )\n    keybinding_overrides: list[KeyBindingOverride] = Field(default_factory=list)\n    plugin_configs: dict[str, dict[str, Any]] = Field(default_factory=dict)\n\n    @classmethod\n    def from_json(cls, path) -&gt; \"AppProfile\":\n        \"\"\"Construct an AppProfile from a json file.\"\"\"\n        with open(path) as f:\n            data = json.load(f)\n        version_saved = Version(data.get(\"version\", \"0.0.1\"))\n        self = cls(**data)\n        if version_saved &lt; Version(_current_version()):\n            for place, version_added in DEFAULT_PLUGINS:\n                if version_added &gt; version_saved and place not in self.plugins:\n                    # Add the default plugin that is implemented after the profile was\n                    # saved.\n                    self.plugins.append(place)\n        return self\n\n    @classmethod\n    def default(cls, save: bool = False) -&gt; \"AppProfile\":\n        \"\"\"Return the default profile.\"\"\"\n        prof = AppProfile()\n        if save and not (profile_dir() / f\"{prof.name}.json\").exists():\n            prof.save()\n        return prof\n\n    def save(self, path: str | Path | None = None) -&gt; None:\n        \"\"\"Save profile as a json file.\"\"\"\n        if path is None:\n            path = self.profile_path()\n        json_string = json.dumps(self.model_dump(), indent=4)\n        with open(path, \"w\") as f:\n            f.write(json_string)\n        return None\n\n    def profile_path(self) -&gt; Path:\n        \"\"\"Path to this profile.\"\"\"\n        return profile_dir() / f\"{self.name}.json\"\n\n    def with_name(self, name: str) -&gt; \"AppProfile\":\n        \"\"\"Return a new profile with a new name.\"\"\"\n        return self.model_copy(update={\"name\": name})\n\n    def with_plugins(self, plugins: list[str]) -&gt; \"AppProfile\":\n        \"\"\"Return a new profile with new plugins.\"\"\"\n        return self.model_copy(update={\"plugins\": plugins})\n\n    def with_plugin_configs(self, configs: dict[str, dict[str, Any]]) -&gt; \"AppProfile\":\n        \"\"\"Return a new profile with new plugin configs.\"\"\"\n        return self.model_copy(update={\"plugin_configs\": configs})\n\n    def with_keybinding_override(self, key: str, command_id: str) -&gt; \"AppProfile\":\n        \"\"\"Return a new profile with new keybind overrides.\"\"\"\n        _overrides = self.keybinding_overrides.copy()\n        for entry in _overrides:\n            if entry.command_id == command_id:\n                if key:\n                    entry.key = key\n                else:\n                    _overrides.remove(entry)\n                break\n        else:\n            if key:\n                _overrides.append(KeyBindingOverride(key=key, command_id=command_id))\n        return self.model_copy(update={\"keybinding_overrides\": _overrides})\n\n    def update_plugin_config(self, plugin_id: str, **kwargs) -&gt; None:\n        \"\"\"Update the config of the plugin specified by `plugin_id`\"\"\"\n        from himena.plugins import AppActionRegistry\n        from himena.plugins.widget_plugins import WidgetCallbackBase\n\n        reg = AppActionRegistry.instance()\n        configs = self.plugin_configs.copy()\n        # NOTE: during development, keys of cur_config and configs[plugin_id] may\n        # differ. `cur_config` has all the keys that should exist in the current\n        # implementation.\n        cur_config = reg._plugin_default_configs[plugin_id].as_dict()\n        if plugin_id in configs:\n            # Profile already has the plugin config\n            for ckey, cval in configs[plugin_id].items():\n                if ckey in cur_config:\n                    cur_config[ckey] = cval\n        for k, v in kwargs.items():\n            if k in cur_config:\n                cur_config[k][\"value\"] = v\n        configs[plugin_id] = cur_config\n        self.with_plugin_configs(configs).save()\n\n        # update existing dock widgets with the new config\n        params = {}\n        for key, opt in cur_config.items():\n            params[key] = opt[\"value\"]\n        if cb := WidgetCallbackBase.instance_for_command_id(plugin_id):\n            for dock in cb._all_widgets:\n                # the internal widget should always has the method \"update_configs\"\n                dock.update_configs(params)\n\n    @field_validator(\"name\")\n    def _validate_name(cls, value):\n        # check if value is a valid file name\n        if not all(c in ALLOWED_LETTERS for c in value):\n            raise ValueError(f\"Invalid profile name: {value}\")\n        return value\n</code></pre>"},{"location":"api/profile/#himena.profile.AppProfile.default","title":"<code>default(save=False)</code>  <code>classmethod</code>","text":"<p>Return the default profile.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>@classmethod\ndef default(cls, save: bool = False) -&gt; \"AppProfile\":\n    \"\"\"Return the default profile.\"\"\"\n    prof = AppProfile()\n    if save and not (profile_dir() / f\"{prof.name}.json\").exists():\n        prof.save()\n    return prof\n</code></pre>"},{"location":"api/profile/#himena.profile.AppProfile.from_json","title":"<code>from_json(path)</code>  <code>classmethod</code>","text":"<p>Construct an AppProfile from a json file.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>@classmethod\ndef from_json(cls, path) -&gt; \"AppProfile\":\n    \"\"\"Construct an AppProfile from a json file.\"\"\"\n    with open(path) as f:\n        data = json.load(f)\n    version_saved = Version(data.get(\"version\", \"0.0.1\"))\n    self = cls(**data)\n    if version_saved &lt; Version(_current_version()):\n        for place, version_added in DEFAULT_PLUGINS:\n            if version_added &gt; version_saved and place not in self.plugins:\n                # Add the default plugin that is implemented after the profile was\n                # saved.\n                self.plugins.append(place)\n    return self\n</code></pre>"},{"location":"api/profile/#himena.profile.AppProfile.profile_path","title":"<code>profile_path()</code>","text":"<p>Path to this profile.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def profile_path(self) -&gt; Path:\n    \"\"\"Path to this profile.\"\"\"\n    return profile_dir() / f\"{self.name}.json\"\n</code></pre>"},{"location":"api/profile/#himena.profile.AppProfile.save","title":"<code>save(path=None)</code>","text":"<p>Save profile as a json file.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def save(self, path: str | Path | None = None) -&gt; None:\n    \"\"\"Save profile as a json file.\"\"\"\n    if path is None:\n        path = self.profile_path()\n    json_string = json.dumps(self.model_dump(), indent=4)\n    with open(path, \"w\") as f:\n        f.write(json_string)\n    return None\n</code></pre>"},{"location":"api/profile/#himena.profile.AppProfile.update_plugin_config","title":"<code>update_plugin_config(plugin_id, **kwargs)</code>","text":"<p>Update the config of the plugin specified by <code>plugin_id</code></p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def update_plugin_config(self, plugin_id: str, **kwargs) -&gt; None:\n    \"\"\"Update the config of the plugin specified by `plugin_id`\"\"\"\n    from himena.plugins import AppActionRegistry\n    from himena.plugins.widget_plugins import WidgetCallbackBase\n\n    reg = AppActionRegistry.instance()\n    configs = self.plugin_configs.copy()\n    # NOTE: during development, keys of cur_config and configs[plugin_id] may\n    # differ. `cur_config` has all the keys that should exist in the current\n    # implementation.\n    cur_config = reg._plugin_default_configs[plugin_id].as_dict()\n    if plugin_id in configs:\n        # Profile already has the plugin config\n        for ckey, cval in configs[plugin_id].items():\n            if ckey in cur_config:\n                cur_config[ckey] = cval\n    for k, v in kwargs.items():\n        if k in cur_config:\n            cur_config[k][\"value\"] = v\n    configs[plugin_id] = cur_config\n    self.with_plugin_configs(configs).save()\n\n    # update existing dock widgets with the new config\n    params = {}\n    for key, opt in cur_config.items():\n        params[key] = opt[\"value\"]\n    if cb := WidgetCallbackBase.instance_for_command_id(plugin_id):\n        for dock in cb._all_widgets:\n            # the internal widget should always has the method \"update_configs\"\n            dock.update_configs(params)\n</code></pre>"},{"location":"api/profile/#himena.profile.AppProfile.with_keybinding_override","title":"<code>with_keybinding_override(key, command_id)</code>","text":"<p>Return a new profile with new keybind overrides.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def with_keybinding_override(self, key: str, command_id: str) -&gt; \"AppProfile\":\n    \"\"\"Return a new profile with new keybind overrides.\"\"\"\n    _overrides = self.keybinding_overrides.copy()\n    for entry in _overrides:\n        if entry.command_id == command_id:\n            if key:\n                entry.key = key\n            else:\n                _overrides.remove(entry)\n            break\n    else:\n        if key:\n            _overrides.append(KeyBindingOverride(key=key, command_id=command_id))\n    return self.model_copy(update={\"keybinding_overrides\": _overrides})\n</code></pre>"},{"location":"api/profile/#himena.profile.AppProfile.with_name","title":"<code>with_name(name)</code>","text":"<p>Return a new profile with a new name.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def with_name(self, name: str) -&gt; \"AppProfile\":\n    \"\"\"Return a new profile with a new name.\"\"\"\n    return self.model_copy(update={\"name\": name})\n</code></pre>"},{"location":"api/profile/#himena.profile.AppProfile.with_plugin_configs","title":"<code>with_plugin_configs(configs)</code>","text":"<p>Return a new profile with new plugin configs.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def with_plugin_configs(self, configs: dict[str, dict[str, Any]]) -&gt; \"AppProfile\":\n    \"\"\"Return a new profile with new plugin configs.\"\"\"\n    return self.model_copy(update={\"plugin_configs\": configs})\n</code></pre>"},{"location":"api/profile/#himena.profile.AppProfile.with_plugins","title":"<code>with_plugins(plugins)</code>","text":"<p>Return a new profile with new plugins.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def with_plugins(self, plugins: list[str]) -&gt; \"AppProfile\":\n    \"\"\"Return a new profile with new plugins.\"\"\"\n    return self.model_copy(update={\"plugins\": plugins})\n</code></pre>"},{"location":"api/profile/#himena.profile.KeyBindingOverride","title":"<code>KeyBindingOverride</code>","text":"<p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> required <code>command_id</code> <code>str</code> required Source code in <code>src\\himena\\profile.py</code> <pre><code>class KeyBindingOverride(BaseModel):\n    key: str\n    command_id: str\n</code></pre>"},{"location":"api/profile/#himena.profile.data_dir","title":"<code>data_dir()</code>","text":"<p>Get the user data directory.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def data_dir() -&gt; Path:\n    \"\"\"Get the user data directory.\"\"\"\n    if not USER_DATA_DIR.exists():\n        USER_DATA_DIR.mkdir(parents=True)\n    return USER_DATA_DIR\n</code></pre>"},{"location":"api/profile/#himena.profile.new_app_profile","title":"<code>new_app_profile(name)</code>","text":"<p>Create a new profile.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def new_app_profile(name: str) -&gt; AppProfile:\n    \"\"\"Create a new profile.\"\"\"\n    path = profile_dir() / f\"{name}.json\"\n    if path.exists():\n        raise ValueError(f\"Profile {name!r} already exists.\")\n    profile = AppProfile.default().with_name(name)\n    profile.save(path)\n    return profile\n</code></pre>"},{"location":"api/profile/#himena.profile.patch_user_data_dir","title":"<code>patch_user_data_dir(path)</code>","text":"<p>Change the user data directory to avoid pytest updates the local state.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>@contextmanager\ndef patch_user_data_dir(path: str | Path):\n    \"\"\"Change the user data directory to avoid pytest updates the local state.\"\"\"\n    global USER_DATA_DIR\n    old = USER_DATA_DIR\n    USER_DATA_DIR = Path(path)\n    try:\n        yield\n    finally:\n        USER_DATA_DIR = old\n</code></pre>"},{"location":"api/profile/#himena.profile.remove_app_profile","title":"<code>remove_app_profile(name)</code>","text":"<p>Remove an existing profile.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def remove_app_profile(name: str) -&gt; None:\n    \"\"\"Remove an existing profile.\"\"\"\n    path = profile_dir() / f\"{name}.json\"\n    return path.unlink()\n</code></pre>"},{"location":"api/types/","title":"himena.types","text":""},{"location":"api/types/#himena.types.Parametric","title":"<code>Parametric = NewType('Parametric', Any)</code>  <code>module-attribute</code>","text":"<p>Callback for a parametric function.</p> <p>This type can be interpreted by the injection store processor. For example, in the following code, <code>my_plugin_function</code> will be converted into a parametric widget with inputs <code>a</code> and <code>b</code>..</p> <pre><code>from himena.plugin import register_function\n@register_function(...)\ndef my_plugin_function(...) -&gt; Parametric:\n    def callback_func(a: int, b: str) -&gt; WidgetDataModel:\n        ...\n    return my_plugin_function\n</code></pre>"},{"location":"api/types/#himena.types.WidgetConstructor","title":"<code>WidgetConstructor = NewType('WidgetConstructor', object)</code>  <code>module-attribute</code>","text":"<p>This type is used for the return annotation.</p> <pre><code>from himena.plugin import register_function\n@register_function(...)\ndef my_plugin_function() -&gt; WidgetConstructor:\n    return MyWidget\n</code></pre>"},{"location":"api/types/#himena.types.WidgetType","title":"<code>WidgetType = NewType('WidgetType', object)</code>  <code>module-attribute</code>","text":"<p>This type is used for the return annotation.</p> <pre><code>from himena.plugin import register_function\n@register_function(...)\ndef my_plugin_function() -&gt; WidgetType:\n    return MyWidget()\n</code></pre>"},{"location":"api/types/#himena.types.BackendInstructions","title":"<code>BackendInstructions</code>","text":"<p>Instructions for the backend that are only relevant to user interface.</p> <p>Parameters:</p> Name Type Description Default <code>animate</code> <code>bool</code> <p>Whether to animate</p> <code>True</code> <code>confirm</code> <code>bool</code> <p>Whether to show a confirmation dialog</p> <code>True</code> <code>choose_one_dialog_response</code> <code>Callable[list, Any] | None</code> <p>If provided, choose-one dialog will be skipped and this function will be called to get the response.</p> <code>None</code> <code>file_dialog_response</code> <code>Callable[list, Any] | None</code> <p>If provided, file dialog will be skipped and this function will be called to get the response.</p> <code>None</code> <code>gui_execution</code> <code>bool</code> <code>True</code> <code>process_model_output</code> <code>bool</code> <code>True</code> <code>unwrap_future</code> <code>bool</code> <code>False</code> Source code in <code>src\\himena\\types.py</code> <pre><code>class BackendInstructions(BaseModel):\n    \"\"\"Instructions for the backend that are only relevant to user interface.\"\"\"\n\n    model_config = PYDANTIC_CONFIG_STRICT\n\n    animate: bool = Field(\n        default=True,\n        description=\"Whether to animate\",\n        frozen=True,\n    )\n    confirm: bool = Field(\n        default=True,\n        description=\"Whether to show a confirmation dialog\",\n        frozen=True,\n    )\n    choose_one_dialog_response: Callable[[], Any] | None = Field(\n        default=None,\n        description=\"If provided, choose-one dialog will be skipped and this function \"\n        \"will be called to get the response.\",\n        frozen=True,\n    )\n    file_dialog_response: Callable[[], Any] | None = Field(\n        default=None,\n        description=\"If provided, file dialog will be skipped and this function will \"\n        \"be called to get the response.\",\n        frozen=True,\n    )\n    gui_execution: bool = Field(default=True)\n    process_model_output: bool = Field(default=True)\n    unwrap_future: bool = Field(default=False)\n\n    def updated(self, **kwargs) -&gt; \"BackendInstructions\":\n        return self.model_copy(update=kwargs)\n</code></pre>"},{"location":"api/types/#himena.types.ClipboardDataModel","title":"<code>ClipboardDataModel</code>","text":"<p>Data model for a clipboard data.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>Text in the clipboard if exists.</p> <code>None</code> <code>html</code> <code>str | None</code> <p>HTML in the clipboard if exists.</p> <code>None</code> <code>image</code> <code>Any | None</code> <p>Image in the clipboard if exists.</p> <code>None</code> <code>files</code> <code>list[Path]</code> <p>List of file paths in the clipboard if exists.</p> <code>&lt;dynamic&gt;</code> <code>internal_data</code> <code>Any | None</code> <p>Application specific data in the clipboard if exists. This data cannot be used across application, but is useful to send Python object to other widgets.</p> <code>None</code> Source code in <code>src\\himena\\types.py</code> <pre><code>class ClipboardDataModel(BaseModel):\n    \"\"\"Data model for a clipboard data.\"\"\"\n\n    model_config = PYDANTIC_CONFIG_STRICT\n\n    text: str | None = Field(\n        default=None,\n        description=\"Text in the clipboard if exists.\",\n    )\n    html: str | None = Field(\n        default=None,\n        description=\"HTML in the clipboard if exists.\",\n    )\n    image: Any | None = Field(\n        default=None,\n        description=\"Image in the clipboard if exists.\",\n    )\n    files: list[Path] = Field(\n        default_factory=list,\n        description=\"List of file paths in the clipboard if exists.\",\n    )\n    internal_data: Any | None = Field(\n        default=None,\n        description=\"Application specific data in the clipboard if exists. This data \"\n        \"cannot be used across application, but is useful to send Python object to \"\n        \"other widgets.\",\n    )\n\n    def with_internal_data(self, internal_data) -&gt; \"ClipboardDataModel\":\n        return self.model_copy(update={\"internal_data\": internal_data})\n</code></pre>"},{"location":"api/types/#himena.types.DockArea","title":"<code>DockArea</code>","text":"<p>Area of the dock widget.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>class DockArea(StrEnum):\n    \"\"\"Area of the dock widget.\"\"\"\n\n    TOP = \"top\"\n    BOTTOM = \"bottom\"\n    LEFT = \"left\"\n    RIGHT = \"right\"\n</code></pre>"},{"location":"api/types/#himena.types.DragDataModel","title":"<code>DragDataModel</code>","text":"<p>Parameters:</p> Name Type Description Default <code>getter</code> <code>Callable[list, WidgetDataModel] | WidgetDataModel</code> <p>Getter function to get the data model.</p> required <code>type</code> <code>str | None</code> <p>Type of the internal data.</p> <code>None</code> Source code in <code>src\\himena\\types.py</code> <pre><code>class DragDataModel(BaseModel):\n    model_config = PYDANTIC_CONFIG_STRICT\n    getter: Callable[[], WidgetDataModel] | WidgetDataModel = Field(\n        ..., description=\"Getter function to get the data model.\"\n    )\n    type: str | None = Field(None, description=\"Type of the internal data.\")\n\n    def data_model(self) -&gt; WidgetDataModel:\n        if isinstance(self.getter, WidgetDataModel):\n            model = self.getter\n        else:\n            model = self.getter()\n        return model\n\n    def widget_accepts_me(self, widget: Any) -&gt; bool:\n        \"\"\"Return true if the widget accepts this data model to be dropped.\"\"\"\n        if hasattr(widget, \"allowed_drop_types\"):\n            types = widget.allowed_drop_types()\n            if self.type is None:\n                return True  # not specified. Just allow it.\n            if self.type in types:\n                return True\n        elif hasattr(widget, \"dropped_callback\"):\n            return True\n        return False\n</code></pre>"},{"location":"api/types/#himena.types.DragDataModel.widget_accepts_me","title":"<code>widget_accepts_me(widget)</code>","text":"<p>Return true if the widget accepts this data model to be dropped.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def widget_accepts_me(self, widget: Any) -&gt; bool:\n    \"\"\"Return true if the widget accepts this data model to be dropped.\"\"\"\n    if hasattr(widget, \"allowed_drop_types\"):\n        types = widget.allowed_drop_types()\n        if self.type is None:\n            return True  # not specified. Just allow it.\n        if self.type in types:\n            return True\n    elif hasattr(widget, \"dropped_callback\"):\n        return True\n    return False\n</code></pre>"},{"location":"api/types/#himena.types.DropResult","title":"<code>DropResult</code>  <code>dataclass</code>","text":"<p>Model that can be returned by <code>dropped_callback</code> protocol.</p> <p>Parameters:</p> Name Type Description Default <code>delete_input</code> <code>bool</code> <code>False</code> <code>command_id</code> <code>str | None</code> <code>None</code> <code>with_params</code> <code>dict[str, object] | None</code> <code>None</code> <p>Attributes:</p> Name Type Description <code>delete_input</code> <code>bool</code> <p>Whether to delete the input data if drop succeeded.</p> <code>command_id</code> <code>str | None</code> <p>Command that will be executed when the drop succeeded.</p> <code>with_params</code> <code>dict[str, object] | None</code> <p>Parameters that will be passed to the command.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>@dataclass(frozen=True)\nclass DropResult:\n    \"\"\"Model that can be returned by `dropped_callback` protocol.\n\n    Attributes\n    ----------\n    delete_input : bool\n        Whether to delete the input data if drop succeeded.\n    command_id : str | None\n        Command that will be executed when the drop succeeded.\n    with_params : dict[str, object] | None\n        Parameters that will be passed to the command.\n    \"\"\"\n\n    delete_input: bool = False\n    command_id: str | None = None\n    with_params: dict[str, object] | None = None\n</code></pre>"},{"location":"api/types/#himena.types.FutureInfo","title":"<code>FutureInfo</code>  <code>dataclass</code>","text":"<p>FutureInfo(type_hint: Any, track: himena.types.ModelTrack | None = None, kwargs: dict[str, typing.Any] = , top_left: tuple[int, int] | None = None, size: Optional[himena.types.Size[int]] = None) <p>Parameters:</p> Name Type Description Default <code>type_hint</code> <code>Any</code> required <code>track</code> <code>ModelTrack | None</code> <code>None</code> <code>top_left</code> <code>tuple[int, int] | None</code> <code>None</code> <code>size</code> <code>Size[int] | None</code> <code>None</code> Source code in <code>src\\himena\\types.py</code> <pre><code>@dataclass(frozen=True)\nclass FutureInfo(_HasDynamicAttribute):\n    _ATTR_NAME: ClassVar[str] = \"__himena_future_info__\"\n\n    type_hint: Any\n    track: ModelTrack | None = None\n    kwargs: dict[str, Any] = field(default_factory=dict)\n    top_left: tuple[int, int] | None = None\n    size: Size[int] | None = None\n\n    def resolve_type_hint(self, ns: dict[str, Any]) -&gt; \"FutureInfo\":\n        if isinstance(self.type_hint, str):\n            typ = ns.get(self.type_hint)\n            if typ is None:\n                raise ValueError(f\"Could not resolve the type hint: {self.type_hint}\")\n            type_hint = typ\n        else:\n            type_hint = self.type_hint\n        return FutureInfo(\n            type_hint=type_hint,\n            track=self.track,\n            kwargs=self.kwargs,\n            top_left=self.top_left,\n            size=self.size,\n        )\n</code></pre>"},{"location":"api/types/#himena.types.GenericModel","title":"<code>GenericModel</code>","text":"Source code in <code>src\\himena\\types.py</code> <pre><code>class GenericModel(BaseModel):\n    def __class_getitem__(cls, item):\n        return cls\n</code></pre>"},{"location":"api/types/#himena.types.GuiConfiguration","title":"<code>GuiConfiguration</code>  <code>dataclass</code>","text":"<p>Configuration for parametric widget (interpreted by the injection processor)</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str | None</code> <code>None</code> <code>preview</code> <code>bool</code> <code>False</code> <code>auto_close</code> <code>bool</code> <code>True</code> <code>show_parameter_labels</code> <code>bool</code> <code>True</code> <code>run_async</code> <code>bool</code> <code>False</code> <code>result_as</code> <code>Literal['window', 'below', 'right']</code> <code>'window'</code> Source code in <code>src\\himena\\types.py</code> <pre><code>@dataclass\nclass GuiConfiguration(_HasDynamicAttribute):\n    \"\"\"Configuration for parametric widget (interpreted by the injection processor)\"\"\"\n\n    _ATTR_NAME: ClassVar[str] = \"__himena_gui_config__\"\n\n    title: str | None = None\n    preview: bool = False\n    auto_close: bool = True\n    show_parameter_labels: bool = True\n    run_async: bool = False\n    result_as: Literal[\"window\", \"below\", \"right\"] = \"window\"\n\n    def asdict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the configuration as a dictionary.\"\"\"\n        return asdict(self)\n</code></pre>"},{"location":"api/types/#himena.types.GuiConfiguration.asdict","title":"<code>asdict()</code>","text":"<p>Return the configuration as a dictionary.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def asdict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the configuration as a dictionary.\"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"api/types/#himena.types.Margins","title":"<code>Margins</code>  <code>dataclass</code>","text":"<p>Margins(left: ~_V, top: ~_V, right: ~_V, bottom: ~_V)</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>TypeVar</code> required <code>top</code> <code>TypeVar</code> required <code>right</code> <code>TypeVar</code> required <code>bottom</code> <code>TypeVar</code> required Source code in <code>src\\himena\\types.py</code> <pre><code>@dataclass(frozen=True)\nclass Margins(Generic[_V]):\n    left: _V\n    top: _V\n    right: _V\n    bottom: _V\n\n    def __iter__(self):\n        \"\"\"Iterate over the field to make this class tuple-like.\"\"\"\n        return iter((self.left, self.top, self.right, self.bottom))\n\n    @classmethod\n    def from_rects(cls, inner: Rect[_V], outer: Rect[_V]) -&gt; \"Margins[_V]\":\n        \"\"\"Calculate the margins from the inner and outer rectangles.\"\"\"\n        return cls(\n            inner.left - outer.left,\n            inner.top - outer.top,\n            outer.right - inner.right,\n            outer.bottom - inner.bottom,\n        )\n</code></pre>"},{"location":"api/types/#himena.types.Margins.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the field to make this class tuple-like.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over the field to make this class tuple-like.\"\"\"\n    return iter((self.left, self.top, self.right, self.bottom))\n</code></pre>"},{"location":"api/types/#himena.types.Margins.from_rects","title":"<code>from_rects(inner, outer)</code>  <code>classmethod</code>","text":"<p>Calculate the margins from the inner and outer rectangles.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>@classmethod\ndef from_rects(cls, inner: Rect[_V], outer: Rect[_V]) -&gt; \"Margins[_V]\":\n    \"\"\"Calculate the margins from the inner and outer rectangles.\"\"\"\n    return cls(\n        inner.left - outer.left,\n        inner.top - outer.top,\n        outer.right - inner.right,\n        outer.bottom - inner.bottom,\n    )\n</code></pre>"},{"location":"api/types/#himena.types.ModelTrack","title":"<code>ModelTrack</code>  <code>dataclass</code>","text":"<p>Model to track how model is created.</p> <p>Parameters:</p> Name Type Description Default <code>command_id</code> <code>str</code> required <code>contexts</code> <code>list[Union[ModelParameter, WindowParameter]]</code> <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p> <code>&lt;dynamic&gt;</code> <code>workflow</code> <code>Workflow</code> <p>Container of WorkflowStep instances.</p> <p>The data structure of a workflow is a directed acyclic graph. Each node is a WorkflowStep instance, and the edges are defined inside each CommandExecution instance. Each node is tagged with a unique ID named <code>id</code>, which is used as a mathematical identifier for the node.</p> <code>&lt;dynamic&gt;</code> <code>time_start</code> <code>float</code> <code>0.0</code> Source code in <code>src\\himena\\types.py</code> <pre><code>@dataclass(frozen=True)\nclass ModelTrack(_HasDynamicAttribute):\n    \"\"\"Model to track how model is created.\"\"\"\n\n    _ATTR_NAME: ClassVar[str] = \"__himena_model_track__\"\n\n    command_id: str\n    contexts: list[ModelParameter | WindowParameter] = field(default_factory=list)\n    workflow: Workflow = field(default_factory=Workflow)\n    time_start: float = field(default=0.0)\n\n    def to_workflow(self, parameters: dict[str, Any]) -&gt; Workflow:\n        \"\"\"Construct a workflow based on the given parameters.\"\"\"\n        params = []\n        more_workflows: list[Workflow] = []\n        for k, v in parameters.items():\n            if k == \"is_previewing\":\n                continue\n            param, wf = parse_parameter(k, v)\n            params.append(param)\n            more_workflows.append(wf)\n        workflow = Workflow.concat([self.workflow] + more_workflows)\n        return workflow.with_step(\n            CommandExecution(\n                command_id=self.command_id,\n                contexts=self.contexts,\n                parameters=params,\n                execution_time=timeit.default_timer() - self.time_start,\n            )\n        )\n</code></pre>"},{"location":"api/types/#himena.types.ModelTrack.to_workflow","title":"<code>to_workflow(parameters)</code>","text":"<p>Construct a workflow based on the given parameters.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def to_workflow(self, parameters: dict[str, Any]) -&gt; Workflow:\n    \"\"\"Construct a workflow based on the given parameters.\"\"\"\n    params = []\n    more_workflows: list[Workflow] = []\n    for k, v in parameters.items():\n        if k == \"is_previewing\":\n            continue\n        param, wf = parse_parameter(k, v)\n        params.append(param)\n        more_workflows.append(wf)\n    workflow = Workflow.concat([self.workflow] + more_workflows)\n    return workflow.with_step(\n        CommandExecution(\n            command_id=self.command_id,\n            contexts=self.contexts,\n            parameters=params,\n            execution_time=timeit.default_timer() - self.time_start,\n        )\n    )\n</code></pre>"},{"location":"api/types/#himena.types.NewWidgetBehavior","title":"<code>NewWidgetBehavior</code>","text":"<p>Behavior of adding a widget.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>class NewWidgetBehavior(StrEnum):\n    \"\"\"Behavior of adding a widget.\"\"\"\n\n    TAB = \"tab\"\n    WINDOW = \"window\"\n</code></pre>"},{"location":"api/types/#himena.types.ParametricWidgetProtocol","title":"<code>ParametricWidgetProtocol</code>","text":"<p>Protocol used for return annotation of a parametric widget.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>class ParametricWidgetProtocol:\n    \"\"\"Protocol used for return annotation of a parametric widget.\"\"\"\n\n    def __new__(cls, *args, **kwargs) -&gt; None:\n        if cls is ParametricWidgetProtocol:\n            raise TypeError(\"ParametricWidgetProtocol cannot be instantiated.\")\n        return super().__new__(cls)\n\n    def get_output(self, *args, **kwargs) -&gt; Any:\n        raise NotImplementedError\n</code></pre>"},{"location":"api/types/#himena.types.Rect","title":"<code>Rect</code>  <code>dataclass</code>","text":"<p>Rectangle use for any place.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>TypeVar</code> required <code>top</code> <code>TypeVar</code> required <code>width</code> <code>TypeVar</code> required <code>height</code> <code>TypeVar</code> required Source code in <code>src\\himena\\types.py</code> <pre><code>@dataclass(frozen=True)\nclass Rect(Generic[_V]):\n    \"\"\"Rectangle use for any place.\"\"\"\n\n    left: _V\n    top: _V\n    width: _V\n    height: _V\n\n    @property\n    def right(self):\n        return self.left + self.width\n\n    @property\n    def bottom(self):\n        return self.top + self.height\n\n    def with_left(self, left: _V) -&gt; \"Rect[_V]\":\n        return Rect(left, self.top, self.width, self.height)\n\n    def with_top(self, top: _V) -&gt; \"Rect[_V]\":\n        return Rect(self.left, top, self.width, self.height)\n\n    def with_width(self, width: _V) -&gt; \"Rect[_V]\":\n        return Rect(self.left, self.top, width, self.height)\n\n    def with_height(self, height: _V) -&gt; \"Rect[_V]\":\n        return Rect(self.left, self.top, self.width, height)\n\n    def with_right(self, right: _V) -&gt; \"Rect[_V]\":\n        return Rect(right - self.width, self.top, self.width, self.height)\n\n    def with_bottom(self, bottom: _V) -&gt; \"Rect[_V]\":\n        return Rect(self.left, bottom - self.height, self.width, self.height)\n\n    def __iter__(self):\n        \"\"\"Iterate over the field to make this class tuple-like.\"\"\"\n        return iter((self.left, self.top, self.width, self.height))\n\n    def size(self) -&gt; Size[_V]:\n        return Size(self.width, self.height)\n\n    def adjust_to_int(\n        self,\n        how: Literal[\"inner\", \"outer\"] = \"inner\",\n    ) -&gt; \"Rect[int]\":\n        right = self.right\n        bottom = self.bottom\n        if how == \"inner\":\n            left = int(math.ceil(self.left))\n            top = int(math.ceil(self.top))\n            right = int(math.floor(right))\n            bottom = int(math.floor(bottom))\n        else:\n            left = int(math.floor(self.left))\n            top = int(math.floor(self.top))\n            right = int(math.ceil(right))\n            bottom = int(math.ceil(bottom))\n        return Rect(left, top, right - left, bottom - top)\n\n    def limit_to(self, xmax: _T, ymax: _T) -&gt; \"Rect[_T]\":\n        \"\"\"Limit the size of the Rect to the given maximum size.\"\"\"\n        left = max(self.left, 0)\n        top = max(self.top, 0)\n        right = min(self.right, xmax)\n        bottom = min(self.bottom, ymax)\n        return Rect(left, top, right - left, bottom - top)\n\n    def move_top_left(self, left: _V, top: _V) -&gt; \"Rect[_V]\":\n        return Rect(left, top, self.width, self.height)\n\n    def move_top_right(self, right: _V, top: _V) -&gt; \"Rect[_V]\":\n        return Rect(right - self.width, top, self.width, self.height)\n\n    def move_bottom_left(self, left: _V, bottom: _V) -&gt; \"Rect[_V]\":\n        return Rect(left, bottom - self.height, self.width, self.height)\n\n    def move_bottom_right(self, right: _V, bottom: _V) -&gt; \"Rect[_V]\":\n        return Rect(right - self.width, bottom - self.height, self.width, self.height)\n</code></pre>"},{"location":"api/types/#himena.types.Rect.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the field to make this class tuple-like.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over the field to make this class tuple-like.\"\"\"\n    return iter((self.left, self.top, self.width, self.height))\n</code></pre>"},{"location":"api/types/#himena.types.Rect.limit_to","title":"<code>limit_to(xmax, ymax)</code>","text":"<p>Limit the size of the Rect to the given maximum size.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def limit_to(self, xmax: _T, ymax: _T) -&gt; \"Rect[_T]\":\n    \"\"\"Limit the size of the Rect to the given maximum size.\"\"\"\n    left = max(self.left, 0)\n    top = max(self.top, 0)\n    right = min(self.right, xmax)\n    bottom = min(self.bottom, ymax)\n    return Rect(left, top, right - left, bottom - top)\n</code></pre>"},{"location":"api/types/#himena.types.Size","title":"<code>Size</code>  <code>dataclass</code>","text":"<p>Size use for any place.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>TypeVar</code> required <code>height</code> <code>TypeVar</code> required Source code in <code>src\\himena\\types.py</code> <pre><code>@dataclass(frozen=True)\nclass Size(Generic[_V]):\n    \"\"\"Size use for any place.\"\"\"\n\n    width: _V\n    height: _V\n\n    def __iter__(self):\n        \"\"\"Iterate over the field to make this class tuple-like.\"\"\"\n        return iter((self.width, self.height))\n\n    def __getitem__(self, index: int):\n        if index == 0:\n            return self.width\n        elif index == 1:\n            return self.height\n        raise IndexError(f\"Index {index!r} out of range.\")\n\n    def with_width(self, width: _V) -&gt; \"Size[_V]\":\n        return Size(width, self.height)\n\n    def with_height(self, height: _V) -&gt; \"Size[_V]\":\n        return Size(self.width, height)\n</code></pre>"},{"location":"api/types/#himena.types.Size.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the field to make this class tuple-like.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over the field to make this class tuple-like.\"\"\"\n    return iter((self.width, self.height))\n</code></pre>"},{"location":"api/types/#himena.types.WidgetClassTuple","title":"<code>WidgetClassTuple</code>","text":"<p>Class for storing registered widget class.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <code>None</code> <code>widget_class</code> <code>ForwardRef(type | Callable)</code> <code>None</code> <code>priority</code> <code>int</code> <code>100</code> <code>widget_id</code> <code>str | None</code> <code>None</code> Source code in <code>src\\himena\\types.py</code> <pre><code>class WidgetClassTuple(NamedTuple):\n    \"\"\"Class for storing registered widget class.\"\"\"\n\n    type: str\n    widget_class: \"type | Callable\"  # factory function\n    priority: int = 100\n    widget_id: str | None = None\n</code></pre>"},{"location":"api/types/#himena.types.WidgetDataModel","title":"<code>WidgetDataModel</code>","text":"<p>A data model that represents a widget containing an internal data.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>TypeVar</code> <p>Internal value.</p> required <code>type</code> <code>str</code> <p>Type of the internal data.</p> required <code>title</code> <code>str | None</code> <p>Default title for the widget.</p> <code>None</code> <code>extension_default</code> <code>str | None</code> <p>Default file extension for saving.</p> <code>None</code> <code>extensions</code> <code>list[str]</code> <p>List of allowed file extensions.</p> <code>&lt;dynamic&gt;</code> <code>metadata</code> <code>object | None</code> <p>Metadata that may be used for storing additional information of the internal data or describing the state of the widget.</p> <code>None</code> <code>workflow</code> <code>Workflow</code> <p>Container of WorkflowStep instances.</p> <p>The data structure of a workflow is a directed acyclic graph. Each node is a WorkflowStep instance, and the edges are defined inside each CommandExecution instance. Each node is tagged with a unique ID named <code>id</code>, which is used as a mathematical identifier for the node.</p> <code>&lt;dynamic&gt;</code> <code>force_open_with</code> <code>str | None</code> <p>Force open with a specific plugin if given.</p> <code>None</code> <code>save_behavior_override</code> <code>SaveBehavior | None</code> <p>Override the default save behavior.</p> <code>None</code> <code>editable</code> <code>bool</code> <p>Whether the widget is editable.</p> <code>True</code> <code>update_inplace</code> <code>bool</code> <p>Whether to update the input data instead of creating a new window.</p> <code>False</code> <code>window_rect_override</code> <code>Callable[list, WindowRect] | None</code> <code>None</code> <p>Attributes:</p> Name Type Description <code>value</code> <code>Any</code> <p>Internal value.</p> <code>type</code> <code>(str, optional)</code> <p>Type of the internal data. Type hierarchy is separated by dots. For example, \"text.plain\" is a subtype of \"text\".</p> <code>title</code> <code>(str, optional)</code> <p>Title for the widget. If not given, the title will be generated from the source path when this model is added to the GUI.</p> <code>extension_default</code> <code>(str, optional)</code> <p>Default file extension for saving. This is used when the user saves the data without specifying the file extension.</p> <code>extensions</code> <code>(list[str], optional)</code> <p>List of allowed file extensions to save this data.</p> <code>metadata</code> <code>(Any, optional)</code> <p>Metadata that may be used for storing additional information of the internal data or describing the state of the widget.</p> <code>workflow</code> <code>(WorkflowList, optional)</code> <p>History of how this data is created.</p> <code>force_open_with</code> <code>(str, optional)</code> <p>Force open with a specific plugin if given.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>class WidgetDataModel(GenericModel[_T]):\n    \"\"\"A data model that represents a widget containing an internal data.\n\n    Attributes\n    ----------\n    value : Any\n        Internal value.\n    type : str, optional\n        Type of the internal data. Type hierarchy is separated by dots. For example,\n        \"text.plain\" is a subtype of \"text\".\n    title : str, optional\n        Title for the widget. If not given, the title will be generated from the source\n        path when this model is added to the GUI.\n    extension_default : str, optional\n        Default file extension for saving. This is used when the user saves the data\n        without specifying the file extension.\n    extensions : list[str], optional\n        List of allowed file extensions to save this data.\n    metadata : Any, optional\n        Metadata that may be used for storing additional information of the internal\n        data or describing the state of the widget.\n    workflow : WorkflowList, optional\n        History of how this data is created.\n    force_open_with : str, optional\n        Force open with a specific plugin if given.\n    \"\"\"\n\n    model_config = PYDANTIC_CONFIG_STRICT\n\n    value: _T = Field(..., description=\"Internal value.\")\n    type: str = Field(..., description=\"Type of the internal data.\")\n    title: str | None = Field(\n        default=None,\n        description=\"Default title for the widget.\",\n    )\n    extension_default: str | None = Field(\n        default=None,\n        description=\"Default file extension for saving.\",\n    )\n    extensions: list[str] = Field(\n        default_factory=list,\n        description=\"List of allowed file extensions.\",\n    )\n    metadata: object | None = Field(\n        default=None,\n        description=\"Metadata that may be used for storing additional information of \"\n        \"the internal data or describing the state of the widget.\",\n    )  # fmt: skip\n    workflow: Workflow = Field(default_factory=Workflow)\n    force_open_with: str | None = Field(\n        default=None,\n        description=\"Force open with a specific plugin if given.\",\n    )\n    save_behavior_override: SaveBehavior | None = Field(\n        default=None,\n        description=\"Override the default save behavior.\",\n    )\n    editable: bool = Field(True, description=\"Whether the widget is editable.\")\n    update_inplace: bool = Field(\n        False,\n        description=\"Whether to update the input data instead of creating a new window.\",\n    )\n    window_rect_override: Callable[[\"Size\"], \"WindowRect\"] | None = Field(None)\n\n    def with_value(\n        self,\n        value: _U,\n        type: str | None = None,\n        *,\n        title: str | None = None,\n        metadata: object | None = _void,\n        save_behavior_override: SaveBehavior | _Void | None = _void,\n        update_inplace: bool = False,\n    ) -&gt; \"WidgetDataModel[_U]\":\n        \"\"\"Return a model with the new value.\"\"\"\n        update = {\"value\": value}\n        if type is not None:\n            update[\"type\"] = type\n        if metadata is not _void:\n            update[\"metadata\"] = metadata\n        if title is not None:\n            update[\"title\"] = title\n        if save_behavior_override is not _void:\n            update[\"save_behavior_override\"] = save_behavior_override\n        update.update(\n            workflow=Workflow(),\n            force_open_with=None,\n            update_inplace=update_inplace,\n        )  # these parameters must be reset\n        return self.model_copy(update=update)\n\n    def astype(self, new_type: str):\n        update = {\"type\": new_type}\n        return self.model_copy(update=update)\n\n    def _with_source(\n        self,\n        source: str | Path | list[str | Path],\n        plugin: \"PluginInfo | None\" = None,\n        id: uuid.UUID | None = None,\n    ) -&gt; \"WidgetDataModel[_T]\":\n        \"\"\"Return a new instance with the source path.\"\"\"\n        if plugin is None:\n            plugin_name = None\n        else:\n            plugin_name = plugin.to_str()\n        if isinstance(source, list):\n            path = [Path(s).resolve() for s in source]\n        else:\n            path = Path(source).resolve()\n        wf = LocalReaderMethod(\n            path=path,\n            plugin=plugin_name,\n            output_model_type=self.type,\n            id=id or uuid.uuid4(),\n        ).construct_workflow()\n        to_update = {\"workflow\": wf}\n        if self.title is None:\n            if isinstance(path, list):\n                to_update.update({\"title\": \"File group\"})\n            else:\n                to_update.update({\"title\": path.name})\n        return self.model_copy(update=to_update)\n\n    def with_open_plugin(\n        self,\n        open_with: str,\n        *,\n        workflow: Workflow | _Void | None = _void,\n        save_behavior_override: SaveBehavior | _Void | None = _void,\n    ) -&gt; \"WidgetDataModel[_T]\":\n        update = {\"force_open_with\": open_with}\n        if workflow is not _void:\n            update[\"workflow\"] = workflow\n        if save_behavior_override is not _void:\n            update[\"save_behavior_override\"] = save_behavior_override\n        return self.model_copy(update=update)\n\n    def with_metadata(\n        self,\n        metadata: Any,\n        update_inplace: bool = False,\n    ) -&gt; \"WidgetDataModel[_T]\":\n        \"\"\"Return a new instance with the given metadata.\"\"\"\n        update = {\"metadata\": metadata, \"update_inplace\": update_inplace}\n        return self.model_copy(update=update)\n\n    def write_to_directory(\n        self,\n        directory: str | Path,\n        *,\n        plugin: str | None = None,\n    ) -&gt; Path:\n        from himena import _providers\n\n        ins = _providers.WriterStore.instance()\n        title = self.title or \"Untitled\"\n        path = Path(directory) / title\n        if path.suffix == \"\":\n            if ext := self.extension_default:\n                path = path.with_suffix(ext)\n            elif exts := self.extensions:\n                path = path.with_suffix(exts[0])\n            else:\n                raise ValueError(\"Could not determine the file extension.\")\n        ins.run(self, path, min_priority=0, plugin=plugin)\n        return path\n\n    @property\n    def source(self) -&gt; Path | list[Path] | None:\n        \"\"\"The direct source path of the data.\"\"\"\n        if isinstance(step := self.workflow.last(), LocalReaderMethod):\n            return step.path\n        return None\n\n    def is_subtype_of(self, supertype: str) -&gt; bool:\n        \"\"\"Check if the type is a subtype of the given type.\"\"\"\n        return is_subtype(self.type, supertype)\n\n    def with_title_numbering(self, copy: bool = False) -&gt; \"WidgetDataModel[_T]\":\n        \"\"\"Add [n] suffix to the title.\"\"\"\n        title = self.title\n        if title is None:\n            title = \"Untitled\"\n        if \".\" in title:\n            stem, ext = title.rsplit(\".\", 1)\n            ext = f\".{ext}\"\n        else:\n            stem = title\n            ext = \"\"\n        if (\n            (last_part := stem.rsplit(\" \", 1)[-1]).startswith(\"[\")\n            and last_part.endswith(\"]\")\n            and last_part[1:-1].isdigit()\n        ):\n            nth = int(last_part[1:-1])\n            stem = stem.rsplit(\" \", 1)[0] + f\" [{nth + 1}]\"\n        else:\n            stem = stem + \" [1]\"\n        new_title = stem + ext\n        if copy:\n            return self.model_copy(update={\"title\": new_title})\n        else:\n            self.title = new_title\n            return self\n\n    @field_validator(\"extension_default\", mode=\"after\")\n    def _validate_extension_default(cls, v: str, values):\n        if v is None:\n            return None\n        if not v.startswith(\".\"):\n            return f\".{v}\"\n        return v\n\n    @field_validator(\"extensions\", mode=\"before\")\n    def _validate_extensions(cls, v):\n        if isinstance(v, str):\n            v = [v]\n        if not all(isinstance(ext, str) for ext in v):\n            raise TypeError(f\"Invalid type for `extensions`: {type(v)}\")\n        return [s if s.startswith(\".\") else f\".{s}\" for s in v]\n\n    def __repr__(self):\n        value_repr = f\"&lt;{type(self.value).__name__}&gt;\"\n        if isinstance(source := self.source, Path):\n            source_repr = source.as_posix()\n        elif isinstance(source, list):\n            if len(source) &gt; 0:\n                source_repr = f\"[{source[0].as_posix()}, ...]\"\n            else:\n                source_repr = \"[]\"\n        else:\n            source_repr = None\n        return (\n            f\"{self.__class__.__name__}(value={value_repr}, source={source_repr}, \"\n            f\"type={self.type!r}, title={self.title!r})\"\n        )\n</code></pre>"},{"location":"api/types/#himena.types.WidgetDataModel.source","title":"<code>source</code>  <code>property</code>","text":"<p>The direct source path of the data.</p>"},{"location":"api/types/#himena.types.WidgetDataModel.is_subtype_of","title":"<code>is_subtype_of(supertype)</code>","text":"<p>Check if the type is a subtype of the given type.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def is_subtype_of(self, supertype: str) -&gt; bool:\n    \"\"\"Check if the type is a subtype of the given type.\"\"\"\n    return is_subtype(self.type, supertype)\n</code></pre>"},{"location":"api/types/#himena.types.WidgetDataModel.with_metadata","title":"<code>with_metadata(metadata, update_inplace=False)</code>","text":"<p>Return a new instance with the given metadata.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def with_metadata(\n    self,\n    metadata: Any,\n    update_inplace: bool = False,\n) -&gt; \"WidgetDataModel[_T]\":\n    \"\"\"Return a new instance with the given metadata.\"\"\"\n    update = {\"metadata\": metadata, \"update_inplace\": update_inplace}\n    return self.model_copy(update=update)\n</code></pre>"},{"location":"api/types/#himena.types.WidgetDataModel.with_title_numbering","title":"<code>with_title_numbering(copy=False)</code>","text":"<p>Add [n] suffix to the title.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def with_title_numbering(self, copy: bool = False) -&gt; \"WidgetDataModel[_T]\":\n    \"\"\"Add [n] suffix to the title.\"\"\"\n    title = self.title\n    if title is None:\n        title = \"Untitled\"\n    if \".\" in title:\n        stem, ext = title.rsplit(\".\", 1)\n        ext = f\".{ext}\"\n    else:\n        stem = title\n        ext = \"\"\n    if (\n        (last_part := stem.rsplit(\" \", 1)[-1]).startswith(\"[\")\n        and last_part.endswith(\"]\")\n        and last_part[1:-1].isdigit()\n    ):\n        nth = int(last_part[1:-1])\n        stem = stem.rsplit(\" \", 1)[0] + f\" [{nth + 1}]\"\n    else:\n        stem = stem + \" [1]\"\n    new_title = stem + ext\n    if copy:\n        return self.model_copy(update={\"title\": new_title})\n    else:\n        self.title = new_title\n        return self\n</code></pre>"},{"location":"api/types/#himena.types.WidgetDataModel.with_value","title":"<code>with_value(value, type=None, *, title=None, metadata=_void, save_behavior_override=_void, update_inplace=False)</code>","text":"<p>Return a model with the new value.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def with_value(\n    self,\n    value: _U,\n    type: str | None = None,\n    *,\n    title: str | None = None,\n    metadata: object | None = _void,\n    save_behavior_override: SaveBehavior | _Void | None = _void,\n    update_inplace: bool = False,\n) -&gt; \"WidgetDataModel[_U]\":\n    \"\"\"Return a model with the new value.\"\"\"\n    update = {\"value\": value}\n    if type is not None:\n        update[\"type\"] = type\n    if metadata is not _void:\n        update[\"metadata\"] = metadata\n    if title is not None:\n        update[\"title\"] = title\n    if save_behavior_override is not _void:\n        update[\"save_behavior_override\"] = save_behavior_override\n    update.update(\n        workflow=Workflow(),\n        force_open_with=None,\n        update_inplace=update_inplace,\n    )  # these parameters must be reset\n    return self.model_copy(update=update)\n</code></pre>"},{"location":"api/types/#himena.types.WindowRect","title":"<code>WindowRect</code>  <code>dataclass</code>","text":"<p>Rectangle of a window.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>TypeVar</code> required <code>top</code> <code>TypeVar</code> required <code>width</code> <code>TypeVar</code> required <code>height</code> <code>TypeVar</code> required Source code in <code>src\\himena\\types.py</code> <pre><code>@dataclass(frozen=True)\nclass WindowRect(Rect[int]):\n    \"\"\"Rectangle of a window.\"\"\"\n\n    @classmethod\n    def from_tuple(cls, left, top, width, height) -&gt; \"WindowRect\":\n        return cls(int(left), int(top), int(width), int(height))\n\n    def align_left(self, area_size: Size[int]) -&gt; \"WindowRect\":\n        return WindowRect(0, self.top, self.width, self.height)\n\n    def align_right(self, area_size: Size[int]) -&gt; \"WindowRect\":\n        w0, _ = area_size\n        return WindowRect(w0 - self.width, self.top, self.width, self.height)\n\n    def align_top(self, area_size: Size[int]) -&gt; \"WindowRect\":\n        return WindowRect(self.left, 0, self.width, self.height)\n\n    def align_bottom(self, area_size: Size[int]) -&gt; \"WindowRect\":\n        _, h0 = area_size\n        return WindowRect(self.left, h0 - self.height, self.width, self.height)\n\n    def align_center(self, area_size: Size[int]) -&gt; \"WindowRect\":\n        w0, h0 = area_size\n        return WindowRect(\n            (w0 - self.width) / 2,\n            (h0 - self.height) / 2,\n            self.width,\n            self.height,\n        )\n\n    def resize_relative(self, wratio: float, hratio: float) -&gt; \"WindowRect\":\n        if wratio &lt;= 0 or hratio &lt;= 0:\n            raise ValueError(\"Ratios must be positive.\")\n        return WindowRect(\n            self.left,\n            self.top,\n            round(self.width * wratio),\n            round(self.height * hratio),\n        )\n</code></pre>"},{"location":"api/types/#himena.types.WindowState","title":"<code>WindowState</code>","text":"<p>State of the sub window.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>class WindowState(StrEnum):\n    \"\"\"State of the sub window.\"\"\"\n\n    MIN = \"min\"\n    MAX = \"max\"\n    NORMAL = \"normal\"\n    FULL = \"full\"\n</code></pre>"},{"location":"api/widgets/","title":"himena.widgets","text":""},{"location":"api/widgets/#himena.widgets.BackendMainWindow","title":"<code>BackendMainWindow</code>","text":"Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>class BackendMainWindow(Generic[_W]):  # pragma: no cover\n    _himena_main_window: MainWindow[_W]\n    _event_loop_handler: EventLoopHandler\n\n    def __init_subclass__(cls) -&gt; None:\n        for name in dir(BackendMainWindow):\n            if not hasattr(cls, name):\n                raise NotImplementedError(f\"Method {name} is not implemented.\")\n\n    def _update_widget_theme(self, theme: Theme):\n        \"\"\"Update the theme of the main window.\"\"\"\n\n    def _main_window_rect(self) -&gt; WindowRect:\n        \"\"\"Get the rect of the main window.\"\"\"\n\n    def _set_main_window_rect(self, rect: WindowRect) -&gt; None:\n        \"\"\"Set the rect of the main window.\"\"\"\n\n    def _current_tab_index(self) -&gt; int | None:\n        \"\"\"Get the current tab index.\n\n        If there is no tab, return None.\n        \"\"\"\n\n    def _set_current_tab_index(self, i_tab: int) -&gt; None:\n        \"\"\"Update the current tab index.\"\"\"\n\n    def _tab_hash(self, i_tab: int) -&gt; Hashable:\n        \"\"\"Get a hashable value of the tab at the index.\"\"\"\n\n    def _tab_hash_for_window(self, widget: _W) -&gt; Hashable:\n        \"\"\"Get a hashable value of the tab containing the window.\"\"\"\n\n    def _num_tabs(self) -&gt; int:\n        \"\"\"Get the number of tabs.\"\"\"\n\n    def _current_sub_window_index(self, i_tab: int) -&gt; int | None:\n        \"\"\"Get the current sub window index in the given tab.\n\n        If there is no sub window, or the tab area itself is selected, return None.\n        \"\"\"\n\n    def _set_current_sub_window_index(self, i_tab: int, i_window: int | None) -&gt; None:\n        \"\"\"Update the current sub window index in the given tab.\n\n        if `i_window` is None, the tab area itself will be selected (all the windows\n        will be deselected). `i_window` is asserted to be non-negative.\n        \"\"\"\n\n    def _set_control_widget(self, widget: _W, control: _W | None) -&gt; None:\n        \"\"\"Set the control widget for the given sub window widget.\n\n        A control widget appears on the top-right corner of the toolbar, which will be\n        used to display the state of the widget, edit the widget efficiently, etc. For\n        example, a font size spinbox for a text editor widget.\n        \"\"\"\n\n    def _update_control_widget(self, current: _W | None) -&gt; None:\n        \"\"\"Switch the control widget to another one in the existing ones.\n\n        If None is given, the control widget will be just hidden.\n        \"\"\"\n\n    def _remove_control_widget(self, widget: _W) -&gt; None:\n        \"\"\"Remove the control widget for the given sub window widget from the stack.\"\"\"\n\n    def _window_state(self, widget: _W) -&gt; WindowState:\n        \"\"\"The state (min, normal, etc.) of the window.\"\"\"\n\n    def _set_window_state(\n        self,\n        widget: _W,\n        state: WindowState,\n        inst: BackendInstructions,\n    ) -&gt; None:\n        \"\"\"Update the state of the window.\n\n        The BackendInstructions indicates the animation or other effects to be applied.\n        \"\"\"\n\n    def _tab_title(self, i_tab: int) -&gt; str:\n        \"\"\"Get the title of the tab at the index.\"\"\"\n\n    def _set_tab_title(self, i_tab: int, title: str) -&gt; None:\n        \"\"\"Update the title of the tab at the index.\"\"\"\n\n    def _window_title(self, widget: _W) -&gt; str:\n        \"\"\"Get the title of the window.\"\"\"\n\n    def _set_window_title(self, widget: _W, title: str) -&gt; None:\n        \"\"\"Update the title of the window.\"\"\"\n\n    def _window_rect(self, widget: _W) -&gt; WindowRect:\n        \"\"\"Get the rectangle relative to the tab area of the window.\"\"\"\n\n    def _set_window_rect(\n        self,\n        widget: _W,\n        rect: WindowRect,\n        inst: BackendInstructions,\n    ) -&gt; None:\n        \"\"\"Update the rectangle of the window.\n\n        The BackendInstructions indicates the animation or other effects to be applied.\n        \"\"\"\n\n    def _area_size(self) -&gt; tuple[int, int]:\n        \"\"\"Get the size of the tab area.\"\"\"\n\n    @overload\n    def _open_file_dialog(\n        self,\n        mode: Literal[\"r\", \"d\", \"w\"] = \"r\",\n        extension_default: str | None = None,\n        allowed_extensions: list[str] | None = None,\n        caption: str | None = None,\n        start_path: Path | None = None,\n    ) -&gt; Path | None: ...\n    @overload\n    def _open_file_dialog(\n        self,\n        mode: Literal[\"rm\"],\n        extension_default: str | None = None,\n        allowed_extensions: list[str] | None = None,\n        caption: str | None = None,\n        start_path: Path | None = None,\n    ) -&gt; list[Path] | None: ...\n\n    def _open_file_dialog(\n        self,\n        mode,\n        extension_default=None,\n        allowed_extensions=None,\n        caption=None,\n        start_path=None,\n    ):\n        \"\"\"Open a file dialog.\"\"\"\n\n    def _request_choice_dialog(\n        self,\n        title: str,\n        message: str,\n        choices: list[tuple[str, _T]],\n        how: Literal[\"buttons\", \"radiobuttons\"] = \"buttons\",\n    ) -&gt; _T | None:\n        \"\"\"Request a choice dialog and return the clicked text.\"\"\"\n\n    def _show_command_palette(self, kind: str) -&gt; None:\n        \"\"\"Show the command palette widget of the given kind.\"\"\"\n\n    def _exit_main_window(self, confirm: bool = False) -&gt; None:\n        \"\"\"Close the main window (confirm if needed).\"\"\"\n\n    def _get_widget_list(self, i_tab: int) -&gt; list[tuple[str, _W]]:\n        \"\"\"Get the list of widgets in the tab.\"\"\"\n\n    def _del_widget_at(self, i_tab: int, i_window: int) -&gt; None:\n        \"\"\"Delete the `i_window`-th window in the `i_tab`-th tab.\"\"\"\n\n    def _get_tab_name_list(self) -&gt; list[str]:\n        \"\"\"Get the list of tab names.\"\"\"\n\n    def _del_tab_at(self, i_tab: int) -&gt; None:\n        \"\"\"Delete the `i_tab`-th tab.\n\n        Backend does not need to close the subwindows one by one (will be done on the\n        wrapper side).\n        \"\"\"\n\n    def _rename_window_at(self, i_tab: int, i_window: int) -&gt; None:\n        \"\"\"Start renaming the `i_window`-th window in the `i_tab`-th tab.\"\"\"\n\n    def add_widget(self, widget: _W, i_tab: int, title: str) -&gt; _W:\n        \"\"\"Add a sub window containing the widget to the tab at the index.\n\n        Return the backend widget.\n        \"\"\"\n\n    def set_widget_as_preview(self, widget: _W):\n        \"\"\"Set the widget state as the preview mode.\"\"\"\n\n    def add_tab(self, title: str) -&gt; None:\n        \"\"\"Add a empty tab with the title.\"\"\"\n\n    def add_dock_widget(\n        self,\n        widget: _W,\n        title: str | None,\n        area: DockAreaString | DockArea | None = DockArea.RIGHT,\n        allowed_areas: list[DockAreaString | DockArea] | None = None,\n    ) -&gt; _W:\n        \"\"\"Add a dock widget containing the widget to the main window.\n\n        Return the backend dock widget.\n        \"\"\"\n\n    ### dock widgets ###\n    def _dock_widget_visible(self, widget: _W) -&gt; bool:\n        \"\"\"Whether the dock widget is visible.\"\"\"\n\n    def _set_dock_widget_visible(self, widget: _W, visible: bool) -&gt; None:\n        \"\"\"Update the visibility of the dock widget.\"\"\"\n\n    def _dock_widget_title(self, widget: _W) -&gt; str:\n        \"\"\"Get the title of the dock widget.\"\"\"\n\n    def _set_dock_widget_title(self, widget: _W, title: str) -&gt; None:\n        \"\"\"Update the title of the dock widget.\"\"\"\n\n    def _del_dock_widget(self, widget: _W) -&gt; None:\n        \"\"\"Delete the dock widget.\"\"\"\n\n    ### others ###\n    def show(self, run: bool = False) -&gt; None:\n        \"\"\"Show the main window and run the app immediately if `run` is True\"\"\"\n\n    def _list_widget_class(\n        self,\n        type: str,\n    ) -&gt; tuple[list[WidgetClassTuple], type[_W]]:\n        \"\"\"List the available widget classes of the given type.\n\n        The method will return (list of (widget model type, widget_class, priority),\n        fallback class)\n        \"\"\"\n\n    def _connect_main_window_signals(self, main_window: MainWindow[_W]):\n        \"\"\"Connect the signal of the backend main window to the callbacks.\"\"\"\n\n    def _connect_window_events(\n        self,\n        wrapper: SubWindow[_W],\n        backend: _W,\n    ):\n        \"\"\"Connect the events between the wrapper sub window and the backend widget.\"\"\"\n\n    def _update_context(self) -&gt; None:\n        \"\"\"Update the application context.\"\"\"\n\n    def _clipboard_data(self) -&gt; ClipboardDataModel | None:\n        \"\"\"Get the clipboard data.\"\"\"\n\n    def _set_clipboard_data(self, data: ClipboardDataModel) -&gt; None:\n        \"\"\"Set the clipboard data.\"\"\"\n\n    def _screenshot(self, target: str) -&gt; NDArray[np.uint8]:\n        \"\"\"Take a screenshot of the target area.\"\"\"\n\n    def _process_parametric_widget(self, widget: _W) -&gt; _W:\n        \"\"\"Process a parametric widget so that it can be added to the main window.\n\n        The incoming widget must implements the `get_params` method, which gives the\n        dictionary of parameters.\n        \"\"\"\n\n    def _connect_parametric_widget_events(\n        self,\n        wrapper: ParametricWindow[_W],\n        widget: _W,\n    ) -&gt; None:\n        \"\"\"Connect the events between the wrapper parametric window and the backend.\"\"\"\n\n    def _signature_to_widget(\n        self,\n        sig: inspect.Signature,\n        show_parameter_labels: bool = True,\n        preview: bool = False,\n    ) -&gt; _W:\n        \"\"\"Convert a function signature to a widget that can run it.\"\"\"\n\n    def _add_widget_to_parametric_window(\n        self,\n        wrapper: ParametricWindow[_W],\n        widget: _W,\n        result_as: Literal[\"below\", \"right\"],\n    ) -&gt; None:\n        \"\"\"Add a widget to the parametric window.\"\"\"\n\n    def _remove_widget_from_parametric_window(\n        self,\n        wrapper: ParametricWindow[_W],\n    ) -&gt; None:\n        \"\"\"Remove a widget from the parametric window.\"\"\"\n\n    def _move_focus_to(self, widget: _W) -&gt; None:\n        \"\"\"Move the focus to the widget.\"\"\"\n\n    def _set_status_tip(self, tip: str, duration: float) -&gt; None:\n        \"\"\"Set the status tip of the main window for a duration (sec).\"\"\"\n\n    def _show_notification(self, text: str, duration: float) -&gt; None:\n        \"\"\"Show notification for a duration (sec).\"\"\"\n\n    def _rebuild_for_runtime(self, new_menus: list[str]) -&gt; None:\n        \"\"\"Register the actions at runtime.\"\"\"\n\n    def _process_future_done_callback(\n        self,\n        cb: Callable[[Future], None],\n        cb_errored: Callable[[Exception], None],\n        **kwargs,\n    ) -&gt; Callable[[Future], None]:\n        \"\"\"Wrap the callback of the future done event so that it can be run in the main\n        thread.\"\"\"\n\n    def _set_parametric_widget_busy(self, wrapper: ParametricWindow[_W], busy: bool):\n        \"\"\"Set the parametric widget busy status (disable call button etc).\"\"\"\n\n    def _add_job_progress(self, future: Future, desc: str, total: int = 0) -&gt; None:\n        \"\"\"Add a job to the job stack.\"\"\"\n\n    def _add_whats_this(self, text: str, style: Literal[\"plain\", \"markdown\", \"html\"]):\n        \"\"\"Add a what's this text to the main window.\"\"\"\n\n    def _append_result(self, item: dict[str, object]) -&gt; None:\n        \"\"\"Append a new result to the result stack.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow.add_dock_widget","title":"<code>add_dock_widget(widget, title, area=DockArea.RIGHT, allowed_areas=None)</code>","text":"<p>Add a dock widget containing the widget to the main window.</p> <p>Return the backend dock widget.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def add_dock_widget(\n    self,\n    widget: _W,\n    title: str | None,\n    area: DockAreaString | DockArea | None = DockArea.RIGHT,\n    allowed_areas: list[DockAreaString | DockArea] | None = None,\n) -&gt; _W:\n    \"\"\"Add a dock widget containing the widget to the main window.\n\n    Return the backend dock widget.\n    \"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow.add_tab","title":"<code>add_tab(title)</code>","text":"<p>Add a empty tab with the title.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def add_tab(self, title: str) -&gt; None:\n    \"\"\"Add a empty tab with the title.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow.add_widget","title":"<code>add_widget(widget, i_tab, title)</code>","text":"<p>Add a sub window containing the widget to the tab at the index.</p> <p>Return the backend widget.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def add_widget(self, widget: _W, i_tab: int, title: str) -&gt; _W:\n    \"\"\"Add a sub window containing the widget to the tab at the index.\n\n    Return the backend widget.\n    \"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow.set_widget_as_preview","title":"<code>set_widget_as_preview(widget)</code>","text":"<p>Set the widget state as the preview mode.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def set_widget_as_preview(self, widget: _W):\n    \"\"\"Set the widget state as the preview mode.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow.show","title":"<code>show(run=False)</code>","text":"<p>Show the main window and run the app immediately if <code>run</code> is True</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def show(self, run: bool = False) -&gt; None:\n    \"\"\"Show the main window and run the app immediately if `run` is True\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.DockWidget","title":"<code>DockWidget</code>","text":"<p>Dock widget wrapper.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>class DockWidget(WidgetWrapper[_W]):\n    \"\"\"Dock widget wrapper.\"\"\"\n\n    def __init__(\n        self,\n        widget: _W,\n        main_window: BackendMainWindow[_W],\n        identifier: uuid.UUID | None = None,\n    ):\n        super().__init__(widget, main_window)\n        if identifier is not None:\n            self._identifier = identifier\n        self._has_update_configs = hasattr(widget, \"update_configs\")\n        self._parse_config_cache: Callable[[dict], Any] | None = None\n        self._command_id: str | None = None\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"{type(self).__name__}(title={self.title!r}, widget={_widget_repr(self)})\"\n        )\n\n    @property\n    def visible(self) -&gt; bool:\n        \"\"\"Visibility of the dock widget.\"\"\"\n        return self._main_window()._dock_widget_visible(self._frontend_widget())\n\n    @visible.setter\n    def visible(self, visible: bool) -&gt; bool:\n        return self._main_window()._set_dock_widget_visible(\n            self._frontend_widget(), visible\n        )\n\n    def show(self) -&gt; None:\n        \"\"\"Show the dock widget.\"\"\"\n        self.visible = True\n\n    def hide(self) -&gt; None:\n        \"\"\"Hide the dock widget.\"\"\"\n        self.visible = False\n\n    @property\n    def title(self) -&gt; str:\n        \"\"\"Title of the dock widget.\"\"\"\n        return self._main_window()._dock_widget_title(self._frontend_widget())\n\n    @title.setter\n    def title(self, title: str) -&gt; None:\n        return self._main_window()._set_dock_widget_title(\n            self._frontend_widget(), str(title)\n        )\n\n    def _parse_config(self, cfg_dict: dict[str, Any]) -&gt; Any:\n        if self._parse_config_cache is not None:\n            return self._parse_config_cache(**cfg_dict)\n        cfgs = AppActionRegistry.instance()._plugin_default_configs\n        cfg_type = cfgs[self._command_id].config_class\n        self._parse_config_cache = cfg_type\n        return cfg_type(**cfg_dict)\n\n    def update_configs(self, cfg: Any):\n        \"\"\"Update the configuration of the dock widget.\"\"\"\n        if self._has_update_configs:\n            if isinstance(cfg, dict):\n                cfg = self._parse_config(cfg)\n            self.widget.update_configs(cfg)\n        return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.DockWidget.title","title":"<code>title</code>  <code>property</code> <code>writable</code>","text":"<p>Title of the dock widget.</p>"},{"location":"api/widgets/#himena.widgets.DockWidget.visible","title":"<code>visible</code>  <code>property</code> <code>writable</code>","text":"<p>Visibility of the dock widget.</p>"},{"location":"api/widgets/#himena.widgets.DockWidget.hide","title":"<code>hide()</code>","text":"<p>Hide the dock widget.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def hide(self) -&gt; None:\n    \"\"\"Hide the dock widget.\"\"\"\n    self.visible = False\n</code></pre>"},{"location":"api/widgets/#himena.widgets.DockWidget.show","title":"<code>show()</code>","text":"<p>Show the dock widget.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Show the dock widget.\"\"\"\n    self.visible = True\n</code></pre>"},{"location":"api/widgets/#himena.widgets.DockWidget.update_configs","title":"<code>update_configs(cfg)</code>","text":"<p>Update the configuration of the dock widget.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def update_configs(self, cfg: Any):\n    \"\"\"Update the configuration of the dock widget.\"\"\"\n    if self._has_update_configs:\n        if isinstance(cfg, dict):\n            cfg = self._parse_config(cfg)\n        self.widget.update_configs(cfg)\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow","title":"<code>MainWindow</code>","text":"<p>The main window handler object.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>class MainWindow(Generic[_W]):\n    \"\"\"The main window handler object.\"\"\"\n\n    def __init__(\n        self,\n        backend: BackendMainWindow[_W],\n        app: HimenaApplication,  # must be initialized\n        theme: Theme,\n    ) -&gt; None:\n        from himena.widgets._initialize import set_current_instance\n\n        self._events = MainWindowEvents()\n        self._backend_main_window = backend\n        self._internal_clipboard_data: Any | None = None\n        self._tab_list = TabList(backend)\n        self._new_widget_behavior = NewWidgetBehavior.WINDOW\n        self._model_app = app\n        self._instructions = BackendInstructions()\n        self._history_tab = HistoryContainer[int](max_size=20)\n        self._history_command = HistoryContainer[str](max_size=200)\n        self._history_closed = HistoryContainer[tuple[Path, str | None]](max_size=10)\n        self._file_dialog_hist = FileDialogHistoryDict()\n        app.commands.executed.connect(self._on_command_execution)\n        backend._connect_main_window_signals(self)\n        self._ctx_keys = AppContext(create_context(self, max_depth=0))\n        self._tab_list.changed.connect(backend._update_context)\n        self._dock_widget_list = DockWidgetList(backend)\n        self._recent_manager = RecentFileManager.default(app)\n        self._recent_session_manager = RecentSessionManager.default(app)\n        if \".\" not in app.name:\n            # likely a mock instance\n            set_current_instance(app.name, self)\n            self._recent_manager.update_menu()\n            self._recent_session_manager.update_menu()\n        self._executor = ThreadPoolExecutor(max_workers=5)\n        self._global_lock = threading.Lock()\n        self._object_type_map = ObjectTypeMap()\n        self.theme = theme\n        register_defaults(self._object_type_map)\n\n    @property\n    def events(self) -&gt; MainWindowEvents[_W]:\n        \"\"\"Main window events.\"\"\"\n        return self._events\n\n    @property\n    def object_type_map(self) -&gt; ObjectTypeMap:\n        \"\"\"Mapping object to string that describes the type.\"\"\"\n        return self._object_type_map\n\n    @property\n    def action_hint_registry(self) -&gt; ActionHintRegistry:\n        \"\"\"Action hint registry.\"\"\"\n        return _actions.AppActionRegistry.instance()._action_hint_reg\n\n    @property\n    def socket_info(self) -&gt; SocketInfo:\n        \"\"\"Socket information.\"\"\"\n        eh = self._backend_main_window._event_loop_handler\n        return SocketInfo(host=eh._host, port=eh._port)\n\n    @property\n    def theme(self) -&gt; Theme:\n        \"\"\"Get the current color theme of the main window.\"\"\"\n        return self._theme\n\n    @theme.setter\n    def theme(self, theme: str | Theme) -&gt; None:\n        \"\"\"Set the style of the main window.\"\"\"\n        if isinstance(theme, str):\n            theme = Theme.from_global(theme)\n        self._theme = theme\n        self._backend_main_window._update_widget_theme(theme)\n\n        # if child implements \"theme_changed_callback\", call it\n        for win in self.iter_windows():\n            _checker.call_theme_changed_callback(win.widget, theme)\n        for dock in self.dock_widgets:\n            _checker.call_theme_changed_callback(dock.widget, theme)\n        return None\n\n    @property\n    def app_profile(self) -&gt; AppProfile:\n        \"\"\"Get the current application profile object.\"\"\"\n        return load_app_profile(self._model_app.name)\n\n    def submit_async_task(\n        self,\n        func: Callable,\n        *args,\n        progress_description: str | None = None,\n        **kwargs,\n    ) -&gt; Future:\n        \"\"\"Submit a task to the thread pool.\n\n        Parameters\n        ----------\n        func : callable\n            Function to run in the background.\n        progress_description : str, optional\n            Description of the task in the progress bar.\n        \"\"\"\n        future = self._executor.submit(func, *args, **kwargs)\n        if progress_description is None:\n            progress_description = f\"Running {func!r}\"\n        self._backend_main_window._add_job_progress(\n            future, desc=progress_description, total=0\n        )\n        self.model_app.injection_store.process(future)\n        return future\n\n    @property\n    def tabs(self) -&gt; TabList[_W]:\n        \"\"\"Tab list object.\"\"\"\n        return self._tab_list\n\n    def windows_for_type(self, types: str | list[str]) -&gt; list[SubWindow[_W]]:\n        \"\"\"Get all sub-windows for the given types.\"\"\"\n        windows = []\n        if isinstance(types, str):\n            types = [types]\n        if tab := self.tabs.current():\n            for win in tab:\n                mtype = win.model_type()\n                if mtype and any(is_subtype(mtype, t) for t in types):\n                    windows.append(win)\n        return windows\n\n    @property\n    def dock_widgets(self) -&gt; DockWidgetList[_W]:\n        \"\"\"Dock widget list object.\"\"\"\n        return self._dock_widget_list\n\n    @property\n    def model_app(self) -&gt; HimenaApplication:\n        \"\"\"The app-model application instance.\"\"\"\n        return self._model_app\n\n    @property\n    def area_size(self) -&gt; tuple[int, int]:\n        \"\"\"(width, height) of the main window tab area.\"\"\"\n        return self._backend_main_window._area_size()\n\n    @property\n    def rect(self) -&gt; WindowRect:\n        \"\"\"Window rect (left, top, width, height) of the main window.\"\"\"\n        return self._backend_main_window._main_window_rect()\n\n    @rect.setter\n    def rect(self, value) -&gt; None:\n        rect = WindowRect.from_tuple(*value)\n        return self._backend_main_window._set_main_window_rect(rect)\n\n    @property\n    def size(self) -&gt; Size:\n        \"\"\"Size (width, height) of the main window.\"\"\"\n        return self.rect.size()\n\n    @size.setter\n    def size(self, size) -&gt; None:\n        r0 = self.rect\n        s0 = Size(*size)\n        self.rect = WindowRect(r0.left, r0.top, s0.width, s0.height)\n\n    @property\n    def clipboard(self) -&gt; ClipboardDataModel | None:\n        \"\"\"Get the clipboard data as a ClipboardDataModel instance.\"\"\"\n        model = self._backend_main_window._clipboard_data()\n        model.internal_data = self._internal_clipboard_data\n        return model\n\n    @clipboard.setter\n    def clipboard(self, data: str | ClipboardDataModel) -&gt; None:\n        \"\"\"Set the clipboard data.\"\"\"\n        if isinstance(data, str):\n            data = ClipboardDataModel(text=data)\n        elif not isinstance(data, ClipboardDataModel):\n            raise ValueError(\"Clipboard data must be a ClipboardDataModel instance.\")\n        _LOGGER.info(\"Setting clipboard data: %r\", data)\n        self._backend_main_window._set_clipboard_data(data)\n        self._internal_clipboard_data = data.internal_data\n\n    def set_clipboard(\n        self,\n        *,\n        text: str | None = None,\n        html: str | None = None,\n        image: Any | None = None,\n        files: list[str | Path] | None = None,\n        internal_data: Any | None = None,\n    ) -&gt; None:\n        \"\"\"Set clipboard data.\"\"\"\n        self.clipboard = ClipboardDataModel(\n            text=text,\n            html=html,\n            image=image,\n            files=files or [],\n            internal_data=internal_data,\n        )\n\n    def add_tab(self, title: str | None = None) -&gt; TabArea[_W]:\n        \"\"\"Add a new tab of given name.\"\"\"\n        return self.tabs.add(title)\n\n    def window_for_id(self, identifier: uuid.UUID) -&gt; SubWindow[_W] | None:\n        \"\"\"Retrieve a sub-window by its identifier.\"\"\"\n        if not isinstance(identifier, uuid.UUID):\n            raise ValueError(f\"Expected UUID, got {identifier!r}.\")\n        for win in self.iter_windows():\n            if win._identifier == identifier:\n                return win\n\n    def _window_for_workflow_id(self, identifier: uuid.UUID) -&gt; SubWindow[_W] | None:\n        \"\"\"Retrieve a sub-window by its workflow identifier.\"\"\"\n        for win in self.iter_windows():\n            try:\n                last_id = win._widget_workflow.last_id()\n            except Exception:\n                return None\n            if last_id == identifier:\n                return win\n\n    def _current_or_new_tab(self) -&gt; tuple[int, TabArea[_W]]:\n        if self._new_widget_behavior is NewWidgetBehavior.WINDOW:\n            if len(self.tabs) == 0:\n                self.add_tab()\n                idx = 0\n            else:\n                idx = self._backend_main_window._current_tab_index()\n            tabarea = self.tabs[idx]\n        else:\n            tabarea = self.add_tab()\n            idx = len(self.tabs) - 1\n        return idx, tabarea\n\n    def add_widget(\n        self,\n        widget: _W,\n        *,\n        title: str | None = None,\n    ) -&gt; SubWindow[_W]:\n        \"\"\"Add a widget to the sub window.\n\n        Any widget that can be interpreted by the backend can be added. For example, for\n        Qt application, you can add any QWidget instance:\n\n        ```python\n        ui.add_widget(QtW.QLabel(\"Hello world!\"), title=\"my widget!\")\n        ```\n\n        Parameters\n        ----------\n        widget : Any\n            Widget to add.\n        title : str, optional\n            Title of the sub-window. If not given, its name will be automatically\n            generated.\n\n        Returns\n        -------\n        SubWindow\n            The sub-window handler.\n        \"\"\"\n        _, tabarea = self._current_or_new_tab()\n        return tabarea.add_widget(widget, title=title)\n\n    def add_dock_widget(\n        self,\n        widget: _W,\n        *,\n        title: str | None = None,\n        area: DockAreaString | DockArea | None = DockArea.RIGHT,\n        allowed_areas: list[DockAreaString | DockArea] | None = None,\n        _identifier: uuid.UUID | None = None,\n    ) -&gt; DockWidget[_W]:\n        \"\"\"Add a custom widget as a dock widget of the main window.\n\n        Parameters\n        ----------\n        widget : Widget type\n            Widget instance that is allowed for the backend.\n        title : str, optional\n            Title of the dock widget.\n        area : dock area, default DockArea.RIGHT\n            String or DockArea enum that describes where the dock widget initially\n            appears.\n        allowed_areas : list of dock area, optional\n            List of allowed dock areas for the widget.\n\n        Returns\n        -------\n        DockWidget\n            The dock widget handler.\n        \"\"\"\n        dock = DockWidget(widget, self._backend_main_window, identifier=_identifier)\n        dock_native = dock._split_interface_and_frontend()[1]\n        self._backend_main_window.add_dock_widget(\n            dock_native, title=title, area=area, allowed_areas=allowed_areas\n        )\n        self._dock_widget_list._add_dock_widget(dock)\n        _checker.call_widget_added_callback(widget)\n        _checker.call_theme_changed_callback(widget, self.theme)\n        return dock\n\n    def add_object(\n        self,\n        value: Any,\n        *,\n        type: str | None = None,\n        title: str | None = None,\n        force_open_with: str | None = None,\n        metadata: Any | None = None,\n    ) -&gt; SubWindow[_W]:\n        \"\"\"Add any data as a widget data model.\n\n        CAUTION: result of this method may not be stable between different sessions. If\n        type is not given, the application will look for the proper widget data type in\n        the type map. If this type map was modified, the result will be different.\n\n        Parameters\n        ----------\n        value : Any\n            Any object. Whether it can be represented as a widget is dependent on the\n            plugins that are installed.\n        type : str, optional\n            Any str that describes the type of the object. This type must be registered\n            with a proper widget class.\n        title : str, optional\n            Title of the sub-window.\n\n        Returns\n        -------\n        SubWindow\n            The sub-window handler.\n        \"\"\"\n        if type is None:\n            if isinstance(metadata, BaseMetadata):\n                type = metadata.expected_type()\n        if type is None:\n            type = self._object_type_map.pick_type(value)\n        wd = WidgetDataModel(\n            value=value,\n            type=type,\n            title=title,\n            force_open_with=force_open_with,\n            metadata=metadata,\n            workflow=ProgrammaticMethod(output_model_type=type).construct_workflow(),\n        )\n        return self.add_data_model(wd)\n\n    def add_data_model(self, model_data: WidgetDataModel) -&gt; SubWindow[_W]:\n        \"\"\"Add a widget data model as a widget.\"\"\"\n        _, tabarea = self._current_or_new_tab()\n        return tabarea.add_data_model(model_data)\n\n    def add_function(\n        self,\n        func: Callable[..., _T],\n        *,\n        preview: bool = False,\n        title: str | None = None,\n        show_parameter_labels: bool = True,\n        auto_close: bool = True,\n        run_async: bool = False,\n        result_as: Literal[\"window\", \"below\", \"right\"] = \"window\",\n    ) -&gt; ParametricWindow[_W]:\n        \"\"\"Add a function as a parametric sub-window.\n\n        The input function must return a `WidgetDataModel` instance, which can be\n        interpreted by the application.\n\n        Parameters\n        ----------\n        func : function (...) -&gt; WidgetDataModel\n            Function that generates a model from the input parameters.\n        title : str, optional\n            Title of the sub-window.\n\n        Returns\n        -------\n        SubWindow\n            The sub-window instance that represents the output model.\n        \"\"\"\n        _, tabarea = self._current_or_new_tab()\n        return tabarea.add_function(\n            func, title=title, preview=preview, result_as=result_as,\n            show_parameter_labels=show_parameter_labels, auto_close=auto_close,\n            run_async=run_async,\n        )  # fmt: skip\n\n    def add_parametric_widget(\n        self,\n        widget: _W,\n        callback: Callable | None = None,\n        *,\n        title: str | None = None,\n        preview: bool = False,\n        auto_close: bool = True,\n        auto_size: bool = True,\n        run_async: bool = False,\n        result_as: Literal[\"window\", \"below\", \"right\"] = \"window\",\n    ) -&gt; ParametricWindow[_W]:\n        _, area = self._current_or_new_tab()\n        return area.add_parametric_widget(\n            widget, callback, title=title, preview=preview, auto_close=auto_close,\n            auto_size=auto_size, result_as=result_as, run_async=run_async,\n        )  # fmt: skip\n\n    def read_file(\n        self,\n        file_path: PathOrPaths,\n        plugin: str | None = None,\n    ) -&gt; SubWindow[_W]:\n        \"\"\"Read local file(s) and open as a new sub-window.\"\"\"\n        _, tabarea = self._current_or_new_tab()\n        return tabarea.read_file(file_path, plugin=plugin)\n\n    def read_files(self, file_paths: PathOrPaths):\n        \"\"\"Read multiple files one by one and open as new sub-windows in a same tab.\"\"\"\n        _, tabarea = self._current_or_new_tab()\n        return tabarea.read_files(file_paths)\n\n    def read_files_async(self, file_paths: PathOrPaths, plugin: str | None = None):\n        \"\"\"Read multiple files asynchronously and open as new sub-windows.\"\"\"\n        _, tabarea = self._current_or_new_tab()\n        return tabarea.read_files_async(file_paths, plugin=plugin)\n\n    def load_session(self, path: str | Path) -&gt; None:\n        \"\"\"Read a session file and update the main window based on the content.\"\"\"\n        from himena.session import update_from_zip, update_from_directory\n\n        fp = Path(path)\n        if fp.suffix == \".zip\":\n            update_from_zip(self, fp)\n        elif fp.is_dir():\n            update_from_directory(self, fp)\n        else:\n            raise ValueError(f\"Session must be a zip file or a directory, got {fp}.\")\n        # always plugin=None for reading a session file as a session\n        self._recent_session_manager.append_recent_files([(fp, None)])\n        self.set_status_tip(f\"Session loaded: {fp}\", duration=5)\n\n    def save_session(\n        self,\n        path: str | Path,\n        *,\n        save_copies: bool = False,\n        allow_calculate: Sequence[str] = (),\n    ) -&gt; None:\n        \"\"\"Save the current session to a zip file as a stand-along file.\"\"\"\n        from himena.session import dump_zip, dump_directory\n\n        path = Path(path)\n        if path.suffix == \".zip\":\n            dump_zip(\n                self, path, save_copies=save_copies, allow_calculate=allow_calculate\n            )\n        else:\n            dump_directory(\n                self, path, save_copies=save_copies, allow_calculate=allow_calculate\n            )\n        self.set_status_tip(f\"Session saved to {path}\")\n        self._recent_session_manager.append_recent_files([(path, None)])\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear all widgets in the main window.\"\"\"\n        self.tabs.clear()\n        self.dock_widgets.clear()\n\n    def set_status_tip(self, text: str, duration: float = 10.0) -&gt; None:\n        \"\"\"Set the status tip of the main window.\n\n        This method can be safely called from any thread.\n\n        Parameters\n        ----------\n        text : str\n            Text to show in the status bar.\n        duration : float, default 10.0\n            Duration (seconds) to show the status tip.\n        \"\"\"\n        self._backend_main_window._set_status_tip(text, duration)\n        return None\n\n    def show_notification(self, text: str, duration: float = 5.0) -&gt; None:\n        \"\"\"Show a temporary notification in the main window.\"\"\"\n        self._backend_main_window._show_notification(text, duration)\n\n    @overload\n    def register_function(\n        self,\n        func: None = None,\n        *,\n        menus: str | Sequence[str] = \"plugins\",\n        title: str | None = None,\n        types: str | Sequence[str] | None = None,\n        enablement: BoolOp | None = None,\n        keybindings: Sequence[KeyBindingRule] | None = None,\n        command_id: str | None = None,\n    ) -&gt; None: ...  # noqa: E501\n    @overload\n    def register_function(\n        self,\n        func: _F,\n        *,\n        menus: str | Sequence[str] = \"plugins\",\n        title: str | None = None,\n        types: str | Sequence[str] | None = None,\n        enablement: BoolOp | None = None,\n        keybindings: Sequence[KeyBindingRule] | None = None,\n        command_id: str | None = None,\n    ) -&gt; _F: ...  # noqa: E501\n\n    def register_function(\n        self,\n        func=None,\n        *,\n        menus=\"plugins\",\n        title=None,\n        types=None,\n        enablement=None,\n        keybindings=None,\n        command_id=None,\n    ):\n        \"\"\"Register a function as a callback in runtime.\n\n        Example\n        -------\n        ``` python\n        @ui.register_function(menus=\"plugins\", title=\"Test functions)\n        def test_function():\n            print(\"test\")\n        ```\n\n        Parameters\n        ----------\n        func : callable, optional\n            Function to register as an action.\n        menus : str or sequence of str, default \"plugins\"\n            Menu(s) to add the action. Submenus are separated by `/`.\n        title : str, optional\n            Title of the action. Name of the function will be used if not given.\n        types: str or sequence of str, optional\n            The `type` parameter(s) allowed as the WidgetDataModel. If this parameter\n            is given, action will be grayed out if the active window does not satisfy\n            the listed types.\n        enablement: Expr, optional\n            Expression that describes when the action will be enabled. As this argument\n            is a generalized version of `types` argument, you cannot use both of them.\n        command_id : str, optional\n            Command ID. If not given, the function qualname will be used.\n        \"\"\"\n\n        def _inner(f):\n            action = _actions.make_action_for_function(\n                f,\n                menus=menus,\n                title=title,\n                types=types,\n                enablement=enablement,\n                keybindings=keybindings,\n                command_id=command_id,\n            )\n            _actions.AppActionRegistry.instance().add_action(action)\n            added_menus = _actions.AppActionRegistry.instance().install_to(\n                self.model_app, [action]\n            )\n            self._backend_main_window._rebuild_for_runtime(added_menus)\n            return f\n\n        return _inner(func) if func else _inner\n\n    def exec_action(\n        self,\n        id: str,\n        *,\n        model_context: WidgetDataModel | None = None,\n        window_context: SubWindow | None = None,\n        with_params: dict[str, Any] | None = None,\n        with_defaults: dict[str, Any] | None = None,\n        process_model_output: bool = True,\n    ) -&gt; Any:\n        \"\"\"Execute an action by its ID.\n\n        Parameters\n        ----------\n        id : str\n            Action ID.\n        model_context : WidgetDataModel, optional\n            If given, this model will override the application context for the type\n            `WidgetDataModel` before the execution.\n        window_context : SubWindow, optional\n            If given, this window will override the application context for the type\n            `SubWindow` before the execution.\n        with_params : dict, optional\n            Parameters to pass to the parametric action. These parameters will directly\n            be passed to the parametric window created after the action is executed.\n        with_defaults : dict, optional\n            If given, the resulting parametric window will be updated with these values.\n        process_model_output : bool, default True\n            If True, the output result will be processed by the application context. If\n            the command return a `WidgetDataModel` instance, it will be converted to a\n            sub-window.\n        \"\"\"\n        if with_params is not None and with_defaults is not None:\n            raise TypeError(\n                \"Cannot use both `with_params` and `with_defaults` at the same time.\"\n            )\n        providers: list[tuple[Any, type]] = []\n        if model_context is not None:\n            providers.append((model_context, WidgetDataModel, 1000))\n        if window_context is not None:\n            if isinstance(window_context, SubWindow):\n                _window_context = window_context\n            else:\n                raise TypeError(\n                    f\"`window_context` must be SubWindow or UUID, got {window_context}\"\n                )\n            providers.append((_window_context, SubWindow, 1000))\n            if model_context is None and _window_context.supports_to_model:\n                providers.append((_window_context.to_model(), WidgetDataModel, 100))\n        # execute the command under the given context\n        with (\n            self.model_app.injection_store.register(providers=providers),\n            self._execute_in_context(\n                is_gui=with_params is None, process_model_output=process_model_output\n            ),\n        ):\n            result = self.model_app.commands.execute_command(id).result()\n            if with_params is not None:\n                if (tab := self.tabs.current()) is not None and len(tab) &gt; 0:\n                    param_widget = tab[-1]\n                else:  # pragma: no cover\n                    raise RuntimeError(\"Unreachable code.\")\n                if not isinstance(param_widget, ParametricWindow):\n                    if len(with_params) == 0:\n                        if isinstance(result, Future):\n                            return result.result()  # or appropriate handling\n                        return result\n                    raise ValueError(\n                        f\"Parametric widget expected but got {param_widget}.\"\n                    )\n                # run the callback with the given parameters synchronously\n                result = param_widget._callback_with_params(\n                    with_params,\n                    force_sync=True,\n                    force_close=True,\n                )\n            elif with_defaults is not None:\n                if (tab := self.tabs.current()) is not None and len(tab) &gt; 0:\n                    param_widget = tab[-1]\n                else:  # pragma: no cover\n                    raise ValueError(\n                        f\"Command {id!r} did not create a parametric window.\"\n                    )\n                if not isinstance(param_widget, ParametricWindow):\n                    if with_defaults:\n                        raise ValueError(\n                            f\"Parametric widget expected but got {param_widget}.\"\n                        )\n                else:\n                    param_widget.update_params(with_defaults)\n        return result\n\n    @overload\n    def exec_choose_one_dialog(\n        self,\n        title: str,\n        message: str,\n        choices: list[tuple[str, _T]],\n        how: Literal[\"buttons\", \"radiobuttons\"] = \"buttons\",\n    ) -&gt; _T | None: ...\n    @overload\n    def exec_choose_one_dialog(\n        self,\n        title: str,\n        message: str,\n        choices: list[str],\n        how: Literal[\"buttons\", \"radiobuttons\"] = \"buttons\",\n    ) -&gt; str | None: ...\n\n    def exec_choose_one_dialog(self, title, message, choices, how=\"buttons\"):\n        \"\"\"Execute a dialog to choose one from the given choices.\n\n        Parameters\n        ----------\n        title : str\n            Window title of the dialog.\n        message : str\n            HTML Message to show in the dialog.\n        choices : list\n            List of choices. Each choice can be a string or a tuple of (text, value).\n            This method will return the selected value.\n        how : str, default \"buttons\"\n            How to show the choices. \"buttons\" for horizontal buttons, \"radiobuttons\"\n            for vertically arranged radio buttons.\n        \"\"\"\n        if res := self._instructions.choose_one_dialog_response:\n            return res()\n        _choices_normed = []\n        for choice in choices:\n            if isinstance(choice, str):\n                _choices_normed.append((choice, choice))\n            else:\n                text, value = choice\n                _choices_normed.append((text, value))\n        return self._backend_main_window._request_choice_dialog(\n            title, message, _choices_normed, how=how\n        )\n\n    @overload\n    def exec_file_dialog(\n        self,\n        mode: Literal[\"r\", \"d\", \"w\"] = \"r\",\n        *,\n        extension_default: str | None = None,\n        allowed_extensions: list[str] | None = None,\n        caption: str | None = None,\n        start_path: str | Path | None = None,\n        group: str | None = None,\n    ) -&gt; Path | None: ...\n    @overload\n    def exec_file_dialog(\n        self,\n        mode: Literal[\"rm\"],\n        *,\n        extension_default: str | None = None,\n        allowed_extensions: list[str] | None = None,\n        caption: str | None = None,\n        start_path: str | Path | None = None,\n        group: str | None = None,\n    ) -&gt; list[Path] | None: ...\n\n    def exec_file_dialog(\n        self,\n        mode: Literal[\"r\", \"d\", \"w\", \"rm\"] = \"r\",\n        *,\n        extension_default=None,\n        allowed_extensions=None,\n        caption=None,\n        start_path=None,\n        group: str | None = None,\n    ):\n        \"\"\"Execute a file dialog to get file path(s).\"\"\"\n        if mode not in {\"r\", \"d\", \"w\", \"rm\"}:\n            raise ValueError(f\"`mode` must be 'r', 'd', 'w' or 'rm', got {mode!r}.\")\n        if res := self._instructions.file_dialog_response:\n            return res()\n        if group is None:\n            group = mode\n\n        if mode == \"w\":\n            if start_path is None:\n                _start_path = self._file_dialog_hist.get_path(group)\n            elif Path(start_path).parent != Path(\".\"):\n                _start_path = Path(start_path)\n            else:  # filename only is given\n                _start_path = self._file_dialog_hist.get_path(group, str(start_path))\n        else:\n            _start_path = Path(start_path or self._file_dialog_hist.get_path(group))\n        result = self._backend_main_window._open_file_dialog(\n            mode,\n            extension_default=extension_default,\n            allowed_extensions=allowed_extensions,\n            caption=caption,\n            start_path=_start_path,\n        )\n        if result is None:\n            return None\n        if mode in [\"r\", \"w\", \"d\"]:\n            self._file_dialog_hist.update(group, result.parent)\n        elif result:\n            self._file_dialog_hist.update(group, result[0].parent)\n        return result\n\n    def show(self, run: bool = False) -&gt; None:\n        \"\"\"\n        Show the main window.\n\n        Parameters\n        ----------\n        run : bool, default False\n            If True, run the application event loop.\n        \"\"\"\n        self._backend_main_window.show(run)\n        return None\n\n    def close(self) -&gt; None:\n        \"\"\"Close the main window.\"\"\"\n        self._backend_main_window._exit_main_window(confirm=False)\n        remove_instance(self.model_app.name, self)\n        return None\n\n    @property\n    def current_window(self) -&gt; SubWindow[_W] | None:\n        \"\"\"Get the current sub-window.\"\"\"\n        idx_tab = self._backend_main_window._current_tab_index()\n        if idx_tab is None:\n            return None\n        idx_win = self._backend_main_window._current_sub_window_index(idx_tab)\n        if idx_win is None:\n            return None\n        return self.tabs[idx_tab][idx_win]\n\n    @current_window.setter\n    def current_window(self, win: SubWindow[_W] | None) -&gt; None:\n        \"\"\"Set the current sub-window.\"\"\"\n        _main = self._backend_main_window\n        if win is None:\n            _main._set_current_tab_index(None)\n            i_tab = _main._current_tab_index()\n            if i_tab is not None:\n                _main._set_current_sub_window_index(i_tab, None)\n        else:\n            for i_tab, tab in self.tabs.enumerate():\n                for i_win, sub in tab.enumerate():\n                    if sub is win:\n                        _main._set_current_tab_index(i_tab)\n                        _main._set_current_sub_window_index(i_tab, i_win)\n                        return None\n        return None\n\n    @property\n    def current_model(self) -&gt; WidgetDataModel | None:\n        \"\"\"Get the current model of the active sub-window.\"\"\"\n        if sub := self.current_window:\n            return sub.to_model()\n        return None\n\n    def iter_windows(self) -&gt; Iterator[SubWindow[_W]]:\n        \"\"\"Iterate over all the sub-windows in this main window.\"\"\"\n        for tab in self.tabs:\n            yield from tab\n\n    def _provide_file_output(self) -&gt; tuple[WidgetDataModel, SubWindow[_W]]:\n        if sub := self.current_window:\n            model = sub.to_model()\n            return model, sub\n        else:\n            raise ValueError(\"No active window.\")\n\n    def _tab_activated(self, i: int):\n        if i &lt; 0:\n            return None\n        tab = self.tabs.get(i)\n        if tab is not None:\n            self.events.tab_activated.emit(tab)\n            self._main_window_resized(self.area_size)  # update layout and anchor\n        if self._history_tab.get_from_last(1) != i:\n            self._history_tab.add(i)\n        return None\n\n    def move_window(self, sub: SubWindow[_W], target_index: int) -&gt; None:\n        \"\"\"Move the sub-window to the target tab index.\"\"\"\n        i_tab = i_win = None\n        for _i_tab, tab in self.tabs.enumerate():\n            for _i_win, win in tab.enumerate():\n                if win is sub:\n                    i_tab = _i_tab\n                    i_win = _i_win\n                    break\n\n        if i_tab is None or i_win is None or target_index == i_tab:\n            return None\n        title = self.tabs[i_tab][i_win].title\n        old_rect = self.tabs[i_tab][i_win].rect\n        win, widget = self.tabs[i_tab]._pop_no_emit(i_win)\n        if target_index &lt; 0:\n            self.add_tab()\n        self.tabs[target_index].append(win, title)\n        win.rect = old_rect\n        if layout := win._parent_layout_ref():\n            layout.remove(win)\n        self.tabs.current_index = i_tab\n        return None\n\n    def _window_activated(self):\n        back = self._backend_main_window\n        back._update_context()\n        i_tab = back._current_tab_index()\n        if i_tab is None:\n            return back._update_control_widget(None)\n        tab = self.tabs.get(i_tab)\n        if tab is None or len(tab) == 0:\n            return back._update_control_widget(None)\n        i_win = back._current_sub_window_index(i_tab)\n        if i_win is None or len(tab) &lt;= i_win:\n            return back._update_control_widget(None)\n        win = tab[i_win]\n        back._update_control_widget(win.widget)\n        _checker.call_widget_activated_callback(win.widget)\n        self.events.window_activated.emit(win)\n\n    def _main_window_resized(self, size: Size):\n        if tab := self.tabs.current():\n            for layout in tab.layouts:\n                layout.anchor = layout.anchor.update_for_window_rect(size, layout.rect)\n                layout._reanchor(size)\n            for win in tab:\n                win.anchor = win.anchor.update_for_window_rect(size, win.rect)\n                win._reanchor(size)\n\n    @contextmanager\n    def _execute_in_context(\n        self,\n        is_gui: bool = False,\n        process_model_output: bool = True,\n        unwrap_future: bool = True,\n    ):\n        with self._global_lock:\n            old_inst = self._instructions.model_copy()\n            self._instructions = self._instructions.updated(\n                gui_execution=is_gui,\n                process_model_output=process_model_output,\n                unwrap_future=unwrap_future,\n            )\n            try:\n                yield None\n            finally:\n                self._instructions = old_inst\n\n    def _iter_widget_class(self, model: WidgetDataModel) -&gt; Iterator[type[_W]]:\n        \"\"\"Pick the most suitable widget class for the given model.\"\"\"\n        if model.force_open_with:\n            yield import_object(model.force_open_with)\n            return\n        widget_classes, fallback_class = self._backend_main_window._list_widget_class(\n            model.type\n        )\n        if not widget_classes:\n            warnings.warn(\n                f\"No widget class is registered for model type {model.type!r}.\",\n                RuntimeWarning,\n                stacklevel=2,\n            )\n            yield fallback_class\n            return\n        complete_match = [\n            (tup.priority, tup.widget_class)\n            for tup in widget_classes\n            if tup.type == model.type and tup.priority &gt;= 0\n        ]\n        if complete_match:\n            yield from _iter_sorted(complete_match)\n        subtype_match = [\n            ((tup.type.count(\".\"), tup.priority), tup.widget_class)\n            for tup in widget_classes\n            if tup.priority &gt;= 0\n        ]\n        yield from _iter_sorted(subtype_match)\n\n    def _pick_widget(self, model: WidgetDataModel) -&gt; _W:\n        \"\"\"Pick the most suitable widget for the given model.\"\"\"\n        exceptions: list[tuple[Any, Exception]] = []\n        for factory in self._iter_widget_class(model):\n            try:\n                try:\n                    widget = factory(self)\n                except TypeError:\n                    widget = factory()\n                widget_id = get_widget_class_id(type(widget))\n                reg = _actions.AppActionRegistry.instance()\n                if self.model_app.name != \".\" and (\n                    plugin_configs := self.app_profile.plugin_configs.get(widget_id)\n                ):\n                    params = {}\n                    for k, v in plugin_configs.items():\n                        params[k] = v[\"value\"]\n                    cfgs = reg._plugin_default_configs\n                    cfg_type = cfgs[widget_id].config_class\n                    # widget should always have `update_configs` in this case\n                    widget.update_configs(cfg_type(**params))\n                widget.update_model(model)\n            except Exception as e:\n                exceptions.append((factory, e))\n            else:\n                break\n        else:\n            raise ValueError(\n                f\"Failed to create a widget for {_short_repr(model)}. Errors:\\n\"\n                f\"{_format_exceptions(exceptions)}\"\n            ) from exceptions[-1][1]\n        if exceptions:\n            raise exceptions[-1][1]\n\n        return widget\n\n    def _on_command_execution(self, id: str, result: Future):\n        if exc := result.exception():\n            _LOGGER.exception(\"Command %r failed: %r\", id, exc)\n            return\n        if action := self.model_app.registered_actions.get(id):\n            if getattr(action.callback, NO_RECORDING_FIELD, False):\n                return None\n            self._history_command.add(id)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.action_hint_registry","title":"<code>action_hint_registry</code>  <code>property</code>","text":"<p>Action hint registry.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.app_profile","title":"<code>app_profile</code>  <code>property</code>","text":"<p>Get the current application profile object.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.area_size","title":"<code>area_size</code>  <code>property</code>","text":"<p>(width, height) of the main window tab area.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.clipboard","title":"<code>clipboard</code>  <code>property</code> <code>writable</code>","text":"<p>Get the clipboard data as a ClipboardDataModel instance.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.current_model","title":"<code>current_model</code>  <code>property</code>","text":"<p>Get the current model of the active sub-window.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.current_window","title":"<code>current_window</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current sub-window.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.dock_widgets","title":"<code>dock_widgets</code>  <code>property</code>","text":"<p>Dock widget list object.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.events","title":"<code>events</code>  <code>property</code>","text":"<p>Main window events.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.model_app","title":"<code>model_app</code>  <code>property</code>","text":"<p>The app-model application instance.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.object_type_map","title":"<code>object_type_map</code>  <code>property</code>","text":"<p>Mapping object to string that describes the type.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.rect","title":"<code>rect</code>  <code>property</code> <code>writable</code>","text":"<p>Window rect (left, top, width, height) of the main window.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.size","title":"<code>size</code>  <code>property</code> <code>writable</code>","text":"<p>Size (width, height) of the main window.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.socket_info","title":"<code>socket_info</code>  <code>property</code>","text":"<p>Socket information.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.tabs","title":"<code>tabs</code>  <code>property</code>","text":"<p>Tab list object.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.theme","title":"<code>theme</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current color theme of the main window.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.add_data_model","title":"<code>add_data_model(model_data)</code>","text":"<p>Add a widget data model as a widget.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def add_data_model(self, model_data: WidgetDataModel) -&gt; SubWindow[_W]:\n    \"\"\"Add a widget data model as a widget.\"\"\"\n    _, tabarea = self._current_or_new_tab()\n    return tabarea.add_data_model(model_data)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.add_dock_widget","title":"<code>add_dock_widget(widget, *, title=None, area=DockArea.RIGHT, allowed_areas=None, _identifier=None)</code>","text":"<p>Add a custom widget as a dock widget of the main window.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>Widget type</code> <p>Widget instance that is allowed for the backend.</p> required <code>title</code> <code>str</code> <p>Title of the dock widget.</p> <code>None</code> <code>area</code> <code>dock area</code> <p>String or DockArea enum that describes where the dock widget initially appears.</p> <code>DockArea.RIGHT</code> <code>allowed_areas</code> <code>list of dock area</code> <p>List of allowed dock areas for the widget.</p> <code>None</code> <p>Returns:</p> Type Description <code>DockWidget</code> <p>The dock widget handler.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def add_dock_widget(\n    self,\n    widget: _W,\n    *,\n    title: str | None = None,\n    area: DockAreaString | DockArea | None = DockArea.RIGHT,\n    allowed_areas: list[DockAreaString | DockArea] | None = None,\n    _identifier: uuid.UUID | None = None,\n) -&gt; DockWidget[_W]:\n    \"\"\"Add a custom widget as a dock widget of the main window.\n\n    Parameters\n    ----------\n    widget : Widget type\n        Widget instance that is allowed for the backend.\n    title : str, optional\n        Title of the dock widget.\n    area : dock area, default DockArea.RIGHT\n        String or DockArea enum that describes where the dock widget initially\n        appears.\n    allowed_areas : list of dock area, optional\n        List of allowed dock areas for the widget.\n\n    Returns\n    -------\n    DockWidget\n        The dock widget handler.\n    \"\"\"\n    dock = DockWidget(widget, self._backend_main_window, identifier=_identifier)\n    dock_native = dock._split_interface_and_frontend()[1]\n    self._backend_main_window.add_dock_widget(\n        dock_native, title=title, area=area, allowed_areas=allowed_areas\n    )\n    self._dock_widget_list._add_dock_widget(dock)\n    _checker.call_widget_added_callback(widget)\n    _checker.call_theme_changed_callback(widget, self.theme)\n    return dock\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.add_function","title":"<code>add_function(func, *, preview=False, title=None, show_parameter_labels=True, auto_close=True, run_async=False, result_as='window')</code>","text":"<p>Add a function as a parametric sub-window.</p> <p>The input function must return a <code>WidgetDataModel</code> instance, which can be interpreted by the application.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>function (...) -&gt; WidgetDataModel</code> <p>Function that generates a model from the input parameters.</p> required <code>title</code> <code>str</code> <p>Title of the sub-window.</p> <code>None</code> <p>Returns:</p> Type Description <code>SubWindow</code> <p>The sub-window instance that represents the output model.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def add_function(\n    self,\n    func: Callable[..., _T],\n    *,\n    preview: bool = False,\n    title: str | None = None,\n    show_parameter_labels: bool = True,\n    auto_close: bool = True,\n    run_async: bool = False,\n    result_as: Literal[\"window\", \"below\", \"right\"] = \"window\",\n) -&gt; ParametricWindow[_W]:\n    \"\"\"Add a function as a parametric sub-window.\n\n    The input function must return a `WidgetDataModel` instance, which can be\n    interpreted by the application.\n\n    Parameters\n    ----------\n    func : function (...) -&gt; WidgetDataModel\n        Function that generates a model from the input parameters.\n    title : str, optional\n        Title of the sub-window.\n\n    Returns\n    -------\n    SubWindow\n        The sub-window instance that represents the output model.\n    \"\"\"\n    _, tabarea = self._current_or_new_tab()\n    return tabarea.add_function(\n        func, title=title, preview=preview, result_as=result_as,\n        show_parameter_labels=show_parameter_labels, auto_close=auto_close,\n        run_async=run_async,\n    )  # fmt: skip\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.add_object","title":"<code>add_object(value, *, type=None, title=None, force_open_with=None, metadata=None)</code>","text":"<p>Add any data as a widget data model.</p> <p>CAUTION: result of this method may not be stable between different sessions. If type is not given, the application will look for the proper widget data type in the type map. If this type map was modified, the result will be different.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Any object. Whether it can be represented as a widget is dependent on the plugins that are installed.</p> required <code>type</code> <code>str</code> <p>Any str that describes the type of the object. This type must be registered with a proper widget class.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title of the sub-window.</p> <code>None</code> <p>Returns:</p> Type Description <code>SubWindow</code> <p>The sub-window handler.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def add_object(\n    self,\n    value: Any,\n    *,\n    type: str | None = None,\n    title: str | None = None,\n    force_open_with: str | None = None,\n    metadata: Any | None = None,\n) -&gt; SubWindow[_W]:\n    \"\"\"Add any data as a widget data model.\n\n    CAUTION: result of this method may not be stable between different sessions. If\n    type is not given, the application will look for the proper widget data type in\n    the type map. If this type map was modified, the result will be different.\n\n    Parameters\n    ----------\n    value : Any\n        Any object. Whether it can be represented as a widget is dependent on the\n        plugins that are installed.\n    type : str, optional\n        Any str that describes the type of the object. This type must be registered\n        with a proper widget class.\n    title : str, optional\n        Title of the sub-window.\n\n    Returns\n    -------\n    SubWindow\n        The sub-window handler.\n    \"\"\"\n    if type is None:\n        if isinstance(metadata, BaseMetadata):\n            type = metadata.expected_type()\n    if type is None:\n        type = self._object_type_map.pick_type(value)\n    wd = WidgetDataModel(\n        value=value,\n        type=type,\n        title=title,\n        force_open_with=force_open_with,\n        metadata=metadata,\n        workflow=ProgrammaticMethod(output_model_type=type).construct_workflow(),\n    )\n    return self.add_data_model(wd)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.add_tab","title":"<code>add_tab(title=None)</code>","text":"<p>Add a new tab of given name.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def add_tab(self, title: str | None = None) -&gt; TabArea[_W]:\n    \"\"\"Add a new tab of given name.\"\"\"\n    return self.tabs.add(title)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.add_widget","title":"<code>add_widget(widget, *, title=None)</code>","text":"<p>Add a widget to the sub window.</p> <p>Any widget that can be interpreted by the backend can be added. For example, for Qt application, you can add any QWidget instance:</p> <pre><code>ui.add_widget(QtW.QLabel(\"Hello world!\"), title=\"my widget!\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>Any</code> <p>Widget to add.</p> required <code>title</code> <code>str</code> <p>Title of the sub-window. If not given, its name will be automatically generated.</p> <code>None</code> <p>Returns:</p> Type Description <code>SubWindow</code> <p>The sub-window handler.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def add_widget(\n    self,\n    widget: _W,\n    *,\n    title: str | None = None,\n) -&gt; SubWindow[_W]:\n    \"\"\"Add a widget to the sub window.\n\n    Any widget that can be interpreted by the backend can be added. For example, for\n    Qt application, you can add any QWidget instance:\n\n    ```python\n    ui.add_widget(QtW.QLabel(\"Hello world!\"), title=\"my widget!\")\n    ```\n\n    Parameters\n    ----------\n    widget : Any\n        Widget to add.\n    title : str, optional\n        Title of the sub-window. If not given, its name will be automatically\n        generated.\n\n    Returns\n    -------\n    SubWindow\n        The sub-window handler.\n    \"\"\"\n    _, tabarea = self._current_or_new_tab()\n    return tabarea.add_widget(widget, title=title)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.clear","title":"<code>clear()</code>","text":"<p>Clear all widgets in the main window.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear all widgets in the main window.\"\"\"\n    self.tabs.clear()\n    self.dock_widgets.clear()\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.close","title":"<code>close()</code>","text":"<p>Close the main window.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the main window.\"\"\"\n    self._backend_main_window._exit_main_window(confirm=False)\n    remove_instance(self.model_app.name, self)\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.exec_action","title":"<code>exec_action(id, *, model_context=None, window_context=None, with_params=None, with_defaults=None, process_model_output=True)</code>","text":"<p>Execute an action by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Action ID.</p> required <code>model_context</code> <code>WidgetDataModel</code> <p>If given, this model will override the application context for the type <code>WidgetDataModel</code> before the execution.</p> <code>None</code> <code>window_context</code> <code>SubWindow</code> <p>If given, this window will override the application context for the type <code>SubWindow</code> before the execution.</p> <code>None</code> <code>with_params</code> <code>dict</code> <p>Parameters to pass to the parametric action. These parameters will directly be passed to the parametric window created after the action is executed.</p> <code>None</code> <code>with_defaults</code> <code>dict</code> <p>If given, the resulting parametric window will be updated with these values.</p> <code>None</code> <code>process_model_output</code> <code>bool</code> <p>If True, the output result will be processed by the application context. If the command return a <code>WidgetDataModel</code> instance, it will be converted to a sub-window.</p> <code>True</code> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def exec_action(\n    self,\n    id: str,\n    *,\n    model_context: WidgetDataModel | None = None,\n    window_context: SubWindow | None = None,\n    with_params: dict[str, Any] | None = None,\n    with_defaults: dict[str, Any] | None = None,\n    process_model_output: bool = True,\n) -&gt; Any:\n    \"\"\"Execute an action by its ID.\n\n    Parameters\n    ----------\n    id : str\n        Action ID.\n    model_context : WidgetDataModel, optional\n        If given, this model will override the application context for the type\n        `WidgetDataModel` before the execution.\n    window_context : SubWindow, optional\n        If given, this window will override the application context for the type\n        `SubWindow` before the execution.\n    with_params : dict, optional\n        Parameters to pass to the parametric action. These parameters will directly\n        be passed to the parametric window created after the action is executed.\n    with_defaults : dict, optional\n        If given, the resulting parametric window will be updated with these values.\n    process_model_output : bool, default True\n        If True, the output result will be processed by the application context. If\n        the command return a `WidgetDataModel` instance, it will be converted to a\n        sub-window.\n    \"\"\"\n    if with_params is not None and with_defaults is not None:\n        raise TypeError(\n            \"Cannot use both `with_params` and `with_defaults` at the same time.\"\n        )\n    providers: list[tuple[Any, type]] = []\n    if model_context is not None:\n        providers.append((model_context, WidgetDataModel, 1000))\n    if window_context is not None:\n        if isinstance(window_context, SubWindow):\n            _window_context = window_context\n        else:\n            raise TypeError(\n                f\"`window_context` must be SubWindow or UUID, got {window_context}\"\n            )\n        providers.append((_window_context, SubWindow, 1000))\n        if model_context is None and _window_context.supports_to_model:\n            providers.append((_window_context.to_model(), WidgetDataModel, 100))\n    # execute the command under the given context\n    with (\n        self.model_app.injection_store.register(providers=providers),\n        self._execute_in_context(\n            is_gui=with_params is None, process_model_output=process_model_output\n        ),\n    ):\n        result = self.model_app.commands.execute_command(id).result()\n        if with_params is not None:\n            if (tab := self.tabs.current()) is not None and len(tab) &gt; 0:\n                param_widget = tab[-1]\n            else:  # pragma: no cover\n                raise RuntimeError(\"Unreachable code.\")\n            if not isinstance(param_widget, ParametricWindow):\n                if len(with_params) == 0:\n                    if isinstance(result, Future):\n                        return result.result()  # or appropriate handling\n                    return result\n                raise ValueError(\n                    f\"Parametric widget expected but got {param_widget}.\"\n                )\n            # run the callback with the given parameters synchronously\n            result = param_widget._callback_with_params(\n                with_params,\n                force_sync=True,\n                force_close=True,\n            )\n        elif with_defaults is not None:\n            if (tab := self.tabs.current()) is not None and len(tab) &gt; 0:\n                param_widget = tab[-1]\n            else:  # pragma: no cover\n                raise ValueError(\n                    f\"Command {id!r} did not create a parametric window.\"\n                )\n            if not isinstance(param_widget, ParametricWindow):\n                if with_defaults:\n                    raise ValueError(\n                        f\"Parametric widget expected but got {param_widget}.\"\n                    )\n            else:\n                param_widget.update_params(with_defaults)\n    return result\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.exec_choose_one_dialog","title":"<code>exec_choose_one_dialog(title, message, choices, how='buttons')</code>","text":"<pre><code>exec_choose_one_dialog(title: str, message: str, choices: list[tuple[str, _T]], how: Literal['buttons', 'radiobuttons'] = 'buttons') -&gt; _T | None\n</code></pre><pre><code>exec_choose_one_dialog(title: str, message: str, choices: list[str], how: Literal['buttons', 'radiobuttons'] = 'buttons') -&gt; str | None\n</code></pre> <p>Execute a dialog to choose one from the given choices.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Window title of the dialog.</p> required <code>message</code> <code>str</code> <p>HTML Message to show in the dialog.</p> required <code>choices</code> <code>list</code> <p>List of choices. Each choice can be a string or a tuple of (text, value). This method will return the selected value.</p> required <code>how</code> <code>str</code> <p>How to show the choices. \"buttons\" for horizontal buttons, \"radiobuttons\" for vertically arranged radio buttons.</p> <code>\"buttons\"</code> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def exec_choose_one_dialog(self, title, message, choices, how=\"buttons\"):\n    \"\"\"Execute a dialog to choose one from the given choices.\n\n    Parameters\n    ----------\n    title : str\n        Window title of the dialog.\n    message : str\n        HTML Message to show in the dialog.\n    choices : list\n        List of choices. Each choice can be a string or a tuple of (text, value).\n        This method will return the selected value.\n    how : str, default \"buttons\"\n        How to show the choices. \"buttons\" for horizontal buttons, \"radiobuttons\"\n        for vertically arranged radio buttons.\n    \"\"\"\n    if res := self._instructions.choose_one_dialog_response:\n        return res()\n    _choices_normed = []\n    for choice in choices:\n        if isinstance(choice, str):\n            _choices_normed.append((choice, choice))\n        else:\n            text, value = choice\n            _choices_normed.append((text, value))\n    return self._backend_main_window._request_choice_dialog(\n        title, message, _choices_normed, how=how\n    )\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.exec_file_dialog","title":"<code>exec_file_dialog(mode='r', *, extension_default=None, allowed_extensions=None, caption=None, start_path=None, group=None)</code>","text":"<pre><code>exec_file_dialog(mode: Literal['r', 'd', 'w'] = 'r', *, extension_default: str | None = None, allowed_extensions: list[str] | None = None, caption: str | None = None, start_path: str | Path | None = None, group: str | None = None) -&gt; Path | None\n</code></pre><pre><code>exec_file_dialog(mode: Literal['rm'], *, extension_default: str | None = None, allowed_extensions: list[str] | None = None, caption: str | None = None, start_path: str | Path | None = None, group: str | None = None) -&gt; list[Path] | None\n</code></pre> <p>Execute a file dialog to get file path(s).</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def exec_file_dialog(\n    self,\n    mode: Literal[\"r\", \"d\", \"w\", \"rm\"] = \"r\",\n    *,\n    extension_default=None,\n    allowed_extensions=None,\n    caption=None,\n    start_path=None,\n    group: str | None = None,\n):\n    \"\"\"Execute a file dialog to get file path(s).\"\"\"\n    if mode not in {\"r\", \"d\", \"w\", \"rm\"}:\n        raise ValueError(f\"`mode` must be 'r', 'd', 'w' or 'rm', got {mode!r}.\")\n    if res := self._instructions.file_dialog_response:\n        return res()\n    if group is None:\n        group = mode\n\n    if mode == \"w\":\n        if start_path is None:\n            _start_path = self._file_dialog_hist.get_path(group)\n        elif Path(start_path).parent != Path(\".\"):\n            _start_path = Path(start_path)\n        else:  # filename only is given\n            _start_path = self._file_dialog_hist.get_path(group, str(start_path))\n    else:\n        _start_path = Path(start_path or self._file_dialog_hist.get_path(group))\n    result = self._backend_main_window._open_file_dialog(\n        mode,\n        extension_default=extension_default,\n        allowed_extensions=allowed_extensions,\n        caption=caption,\n        start_path=_start_path,\n    )\n    if result is None:\n        return None\n    if mode in [\"r\", \"w\", \"d\"]:\n        self._file_dialog_hist.update(group, result.parent)\n    elif result:\n        self._file_dialog_hist.update(group, result[0].parent)\n    return result\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.iter_windows","title":"<code>iter_windows()</code>","text":"<p>Iterate over all the sub-windows in this main window.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def iter_windows(self) -&gt; Iterator[SubWindow[_W]]:\n    \"\"\"Iterate over all the sub-windows in this main window.\"\"\"\n    for tab in self.tabs:\n        yield from tab\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.load_session","title":"<code>load_session(path)</code>","text":"<p>Read a session file and update the main window based on the content.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def load_session(self, path: str | Path) -&gt; None:\n    \"\"\"Read a session file and update the main window based on the content.\"\"\"\n    from himena.session import update_from_zip, update_from_directory\n\n    fp = Path(path)\n    if fp.suffix == \".zip\":\n        update_from_zip(self, fp)\n    elif fp.is_dir():\n        update_from_directory(self, fp)\n    else:\n        raise ValueError(f\"Session must be a zip file or a directory, got {fp}.\")\n    # always plugin=None for reading a session file as a session\n    self._recent_session_manager.append_recent_files([(fp, None)])\n    self.set_status_tip(f\"Session loaded: {fp}\", duration=5)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.move_window","title":"<code>move_window(sub, target_index)</code>","text":"<p>Move the sub-window to the target tab index.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def move_window(self, sub: SubWindow[_W], target_index: int) -&gt; None:\n    \"\"\"Move the sub-window to the target tab index.\"\"\"\n    i_tab = i_win = None\n    for _i_tab, tab in self.tabs.enumerate():\n        for _i_win, win in tab.enumerate():\n            if win is sub:\n                i_tab = _i_tab\n                i_win = _i_win\n                break\n\n    if i_tab is None or i_win is None or target_index == i_tab:\n        return None\n    title = self.tabs[i_tab][i_win].title\n    old_rect = self.tabs[i_tab][i_win].rect\n    win, widget = self.tabs[i_tab]._pop_no_emit(i_win)\n    if target_index &lt; 0:\n        self.add_tab()\n    self.tabs[target_index].append(win, title)\n    win.rect = old_rect\n    if layout := win._parent_layout_ref():\n        layout.remove(win)\n    self.tabs.current_index = i_tab\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.read_file","title":"<code>read_file(file_path, plugin=None)</code>","text":"<p>Read local file(s) and open as a new sub-window.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def read_file(\n    self,\n    file_path: PathOrPaths,\n    plugin: str | None = None,\n) -&gt; SubWindow[_W]:\n    \"\"\"Read local file(s) and open as a new sub-window.\"\"\"\n    _, tabarea = self._current_or_new_tab()\n    return tabarea.read_file(file_path, plugin=plugin)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.read_files","title":"<code>read_files(file_paths)</code>","text":"<p>Read multiple files one by one and open as new sub-windows in a same tab.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def read_files(self, file_paths: PathOrPaths):\n    \"\"\"Read multiple files one by one and open as new sub-windows in a same tab.\"\"\"\n    _, tabarea = self._current_or_new_tab()\n    return tabarea.read_files(file_paths)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.read_files_async","title":"<code>read_files_async(file_paths, plugin=None)</code>","text":"<p>Read multiple files asynchronously and open as new sub-windows.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def read_files_async(self, file_paths: PathOrPaths, plugin: str | None = None):\n    \"\"\"Read multiple files asynchronously and open as new sub-windows.\"\"\"\n    _, tabarea = self._current_or_new_tab()\n    return tabarea.read_files_async(file_paths, plugin=plugin)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.register_function","title":"<code>register_function(func=None, *, menus='plugins', title=None, types=None, enablement=None, keybindings=None, command_id=None)</code>","text":"<pre><code>register_function(func: None = None, *, menus: str | Sequence[str] = 'plugins', title: str | None = None, types: str | Sequence[str] | None = None, enablement: BoolOp | None = None, keybindings: Sequence[KeyBindingRule] | None = None, command_id: str | None = None) -&gt; None\n</code></pre><pre><code>register_function(func: _F, *, menus: str | Sequence[str] = 'plugins', title: str | None = None, types: str | Sequence[str] | None = None, enablement: BoolOp | None = None, keybindings: Sequence[KeyBindingRule] | None = None, command_id: str | None = None) -&gt; _F\n</code></pre> <p>Register a function as a callback in runtime.</p> Example <pre><code>@ui.register_function(menus=\"plugins\", title=\"Test functions)\ndef test_function():\n    print(\"test\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>Function to register as an action.</p> <code>None</code> <code>menus</code> <code>str or sequence of str</code> <p>Menu(s) to add the action. Submenus are separated by <code>/</code>.</p> <code>\"plugins\"</code> <code>title</code> <code>str</code> <p>Title of the action. Name of the function will be used if not given.</p> <code>None</code> <code>types</code> <p>The <code>type</code> parameter(s) allowed as the WidgetDataModel. If this parameter is given, action will be grayed out if the active window does not satisfy the listed types.</p> <code>None</code> <code>enablement</code> <p>Expression that describes when the action will be enabled. As this argument is a generalized version of <code>types</code> argument, you cannot use both of them.</p> <code>None</code> <code>command_id</code> <code>str</code> <p>Command ID. If not given, the function qualname will be used.</p> <code>None</code> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def register_function(\n    self,\n    func=None,\n    *,\n    menus=\"plugins\",\n    title=None,\n    types=None,\n    enablement=None,\n    keybindings=None,\n    command_id=None,\n):\n    \"\"\"Register a function as a callback in runtime.\n\n    Example\n    -------\n    ``` python\n    @ui.register_function(menus=\"plugins\", title=\"Test functions)\n    def test_function():\n        print(\"test\")\n    ```\n\n    Parameters\n    ----------\n    func : callable, optional\n        Function to register as an action.\n    menus : str or sequence of str, default \"plugins\"\n        Menu(s) to add the action. Submenus are separated by `/`.\n    title : str, optional\n        Title of the action. Name of the function will be used if not given.\n    types: str or sequence of str, optional\n        The `type` parameter(s) allowed as the WidgetDataModel. If this parameter\n        is given, action will be grayed out if the active window does not satisfy\n        the listed types.\n    enablement: Expr, optional\n        Expression that describes when the action will be enabled. As this argument\n        is a generalized version of `types` argument, you cannot use both of them.\n    command_id : str, optional\n        Command ID. If not given, the function qualname will be used.\n    \"\"\"\n\n    def _inner(f):\n        action = _actions.make_action_for_function(\n            f,\n            menus=menus,\n            title=title,\n            types=types,\n            enablement=enablement,\n            keybindings=keybindings,\n            command_id=command_id,\n        )\n        _actions.AppActionRegistry.instance().add_action(action)\n        added_menus = _actions.AppActionRegistry.instance().install_to(\n            self.model_app, [action]\n        )\n        self._backend_main_window._rebuild_for_runtime(added_menus)\n        return f\n\n    return _inner(func) if func else _inner\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.save_session","title":"<code>save_session(path, *, save_copies=False, allow_calculate=())</code>","text":"<p>Save the current session to a zip file as a stand-along file.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def save_session(\n    self,\n    path: str | Path,\n    *,\n    save_copies: bool = False,\n    allow_calculate: Sequence[str] = (),\n) -&gt; None:\n    \"\"\"Save the current session to a zip file as a stand-along file.\"\"\"\n    from himena.session import dump_zip, dump_directory\n\n    path = Path(path)\n    if path.suffix == \".zip\":\n        dump_zip(\n            self, path, save_copies=save_copies, allow_calculate=allow_calculate\n        )\n    else:\n        dump_directory(\n            self, path, save_copies=save_copies, allow_calculate=allow_calculate\n        )\n    self.set_status_tip(f\"Session saved to {path}\")\n    self._recent_session_manager.append_recent_files([(path, None)])\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.set_clipboard","title":"<code>set_clipboard(*, text=None, html=None, image=None, files=None, internal_data=None)</code>","text":"<p>Set clipboard data.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def set_clipboard(\n    self,\n    *,\n    text: str | None = None,\n    html: str | None = None,\n    image: Any | None = None,\n    files: list[str | Path] | None = None,\n    internal_data: Any | None = None,\n) -&gt; None:\n    \"\"\"Set clipboard data.\"\"\"\n    self.clipboard = ClipboardDataModel(\n        text=text,\n        html=html,\n        image=image,\n        files=files or [],\n        internal_data=internal_data,\n    )\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.set_status_tip","title":"<code>set_status_tip(text, duration=10.0)</code>","text":"<p>Set the status tip of the main window.</p> <p>This method can be safely called from any thread.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to show in the status bar.</p> required <code>duration</code> <code>float</code> <p>Duration (seconds) to show the status tip.</p> <code>10.0</code> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def set_status_tip(self, text: str, duration: float = 10.0) -&gt; None:\n    \"\"\"Set the status tip of the main window.\n\n    This method can be safely called from any thread.\n\n    Parameters\n    ----------\n    text : str\n        Text to show in the status bar.\n    duration : float, default 10.0\n        Duration (seconds) to show the status tip.\n    \"\"\"\n    self._backend_main_window._set_status_tip(text, duration)\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.show","title":"<code>show(run=False)</code>","text":"<p>Show the main window.</p> <p>Parameters:</p> Name Type Description Default <code>run</code> <code>bool</code> <p>If True, run the application event loop.</p> <code>False</code> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def show(self, run: bool = False) -&gt; None:\n    \"\"\"\n    Show the main window.\n\n    Parameters\n    ----------\n    run : bool, default False\n        If True, run the application event loop.\n    \"\"\"\n    self._backend_main_window.show(run)\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.show_notification","title":"<code>show_notification(text, duration=5.0)</code>","text":"<p>Show a temporary notification in the main window.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def show_notification(self, text: str, duration: float = 5.0) -&gt; None:\n    \"\"\"Show a temporary notification in the main window.\"\"\"\n    self._backend_main_window._show_notification(text, duration)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.submit_async_task","title":"<code>submit_async_task(func, *args, progress_description=None, **kwargs)</code>","text":"<p>Submit a task to the thread pool.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>Function to run in the background.</p> required <code>progress_description</code> <code>str</code> <p>Description of the task in the progress bar.</p> <code>None</code> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def submit_async_task(\n    self,\n    func: Callable,\n    *args,\n    progress_description: str | None = None,\n    **kwargs,\n) -&gt; Future:\n    \"\"\"Submit a task to the thread pool.\n\n    Parameters\n    ----------\n    func : callable\n        Function to run in the background.\n    progress_description : str, optional\n        Description of the task in the progress bar.\n    \"\"\"\n    future = self._executor.submit(func, *args, **kwargs)\n    if progress_description is None:\n        progress_description = f\"Running {func!r}\"\n    self._backend_main_window._add_job_progress(\n        future, desc=progress_description, total=0\n    )\n    self.model_app.injection_store.process(future)\n    return future\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.window_for_id","title":"<code>window_for_id(identifier)</code>","text":"<p>Retrieve a sub-window by its identifier.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def window_for_id(self, identifier: uuid.UUID) -&gt; SubWindow[_W] | None:\n    \"\"\"Retrieve a sub-window by its identifier.\"\"\"\n    if not isinstance(identifier, uuid.UUID):\n        raise ValueError(f\"Expected UUID, got {identifier!r}.\")\n    for win in self.iter_windows():\n        if win._identifier == identifier:\n            return win\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.windows_for_type","title":"<code>windows_for_type(types)</code>","text":"<p>Get all sub-windows for the given types.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def windows_for_type(self, types: str | list[str]) -&gt; list[SubWindow[_W]]:\n    \"\"\"Get all sub-windows for the given types.\"\"\"\n    windows = []\n    if isinstance(types, str):\n        types = [types]\n    if tab := self.tabs.current():\n        for win in tab:\n            mtype = win.model_type()\n            if mtype and any(is_subtype(mtype, t) for t in types):\n                windows.append(win)\n    return windows\n</code></pre>"},{"location":"api/widgets/#himena.widgets.ParametricWindow","title":"<code>ParametricWindow</code>","text":"<p>Subwindow with a parametric widget inside.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>class ParametricWindow(SubWindow[_W]):\n    \"\"\"Subwindow with a parametric widget inside.\"\"\"\n\n    _IS_PREVIEWING = \"is_previewing\"  # keyword argument used for preview flag\n    btn_clicked = Signal(object)  # emit self\n    params_changed = Signal(object)  # emit self\n\n    def __init__(\n        self,\n        widget: _W,\n        callback: Callable,\n        main_window: BackendMainWindow[_W],\n    ):\n        super().__init__(widget, main_window)\n        self._callback = callback\n        self.btn_clicked.connect(self._widget_callback)\n        self._preview_window_ref: Callable[[], WidgetWrapper[_W] | None] = _do_nothing\n        self._auto_close = True\n        self._run_asynchronously = False\n        self._last_future: Future | None = None\n        self._result_as: Literal[\"window\", \"below\", \"right\"] = \"window\"\n\n        # check if callback has \"is_previewing\" argument\n        sig = inspect.signature(callback)\n        self._has_is_previewing = self._IS_PREVIEWING in sig.parameters\n        self._fn_signature = sig\n\n    def get_params(self) -&gt; dict[str, Any]:\n        \"\"\"Get the parameters of the widget.\"\"\"\n        if hasattr(self.widget, PWPN.GET_PARAMS):\n            params = getattr(self.widget, PWPN.GET_PARAMS)()\n            if not isinstance(params, dict):\n                raise TypeError(\n                    f\"`{PWPN.GET_PARAMS}` of {self.widget!r} must return a dict, got \"\n                    f\"{type(params)}.\"\n                )\n        else:\n            params = {}\n        return params\n\n    def update_params(self, params: dict[str, Any], **kwargs) -&gt; None:\n        \"\"\"Update the parameters of the widget.\"\"\"\n        if hasattr(self.widget, PWPN.UPDATE_PARAMS):\n            getattr(self.widget, PWPN.UPDATE_PARAMS)({**params, **kwargs})\n        else:\n            raise NotImplementedError(\n                f\"{self.widget!r} does not support setting parameters.\"\n            )\n        self._emit_param_changed()\n\n    def _get_preview_window(self) -&gt; SubWindow[_W] | None:\n        \"\"\"Return the preview window if it is alive.\"\"\"\n        if (prev := self._preview_window_ref()) and prev.is_alive:\n            return prev\n        return None\n\n    def _is_run_immediately(self) -&gt; bool:\n        for param in self._fn_signature.parameters.values():\n            annot = param.annotation\n            if _is_annotated(annot):\n                _, op = _split_annotated_type(annot)\n                if \"bind\" not in op:\n                    return False\n            else:\n                return False\n        return True\n\n    def _widget_callback(self):\n        \"\"\"Callback when the call button is clicked.\"\"\"\n        main = self._main_window()\n        main._set_parametric_widget_busy(self, True)\n        try:\n            self._callback_with_params(self.get_params())\n        except Exception:\n            main._set_parametric_widget_busy(self, False)\n            raise\n\n    def _call(self, **kwargs):\n        \"\"\"Call the callback (maybe) asynchronously.\"\"\"\n        ui = self._main_window()._himena_main_window\n        if self._run_asynchronously:\n            if self._last_future is not None:\n                self._last_future.cancel()\n                self._last_future = None\n            self._last_future = future = ui._executor.submit(self._callback, **kwargs)\n            return future\n        else:\n            return self._callback(**kwargs)\n\n    def _widget_preview_callback(self):\n        \"\"\"Callback function of parameter change during preview\"\"\"\n        main = self._main_window()\n        if not self.is_preview_enabled():\n            if prev := self._get_preview_window():\n                self._preview_window_ref = _do_nothing\n                self._child_windows.discard(prev)\n                if self._result_as == \"window\":\n                    prev._close_me(main._himena_main_window)\n                else:\n                    main._remove_widget_from_parametric_window(self)\n                    if hint := self.size_hint():\n                        self.rect = (self.rect.left, self.rect.top, hint[0], hint[1])\n            return None\n        kwargs = self.get_params()\n        if self._has_is_previewing:\n            kwargs[self._IS_PREVIEWING] = True\n        return_value = self._call(**kwargs)\n        if isinstance(return_value, Future):  # running asynchronously\n            done = main._process_future_done_callback(\n                self._widget_preview_callback_done,\n                lambda e: main._set_parametric_widget_busy(self, False),\n            )\n            return_value.add_done_callback(done)\n            main._set_parametric_widget_busy(self, True)\n        else:\n            temp_future = Future()\n            temp_future.set_result(return_value)\n            self._widget_preview_callback_done(temp_future)\n\n    def _widget_preview_callback_done(self, future: Future):\n        \"\"\"Callback function when the job of preview is done.\"\"\"\n        main = self._main_window()\n        main._set_parametric_widget_busy(self, False)\n        return_value = future.result()\n        if return_value is None:\n            return None\n        if not isinstance(return_value, WidgetDataModel):\n            raise NotImplementedError(\n                \"Preview is only supported for WidgetDataModel but the return value \"\n                f\"was {type(return_value)}\"\n            )\n        if prev := self._get_preview_window():\n            prev.update_model(return_value)\n        else:\n            # create a new preview window\n            result_widget = self._model_to_new_window(return_value)\n            if self._result_as == \"window\":\n                # create a new preview window\n                title = f\"{return_value.title} (preview)\"\n                prev = self.add_child(result_widget, title=title)\n                main.set_widget_as_preview(prev)\n                prev.force_not_editable(True)  # disable editing if possible\n                # move the window so that it does not overlap with the parametric window\n                prev.rect = prevent_window_overlap(self, prev, main._area_size())\n            else:\n                main._add_widget_to_parametric_window(\n                    self, result_widget, self._result_as\n                )\n                # update the size because new window is added\n                if hint := self.size_hint():\n                    self.rect = (self.rect.left, self.rect.top, hint[0], hint[1])\n                prev = WidgetWrapper(result_widget, main)  # just for wrapping\n            self._preview_window_ref = weakref.ref(prev)\n            main._move_focus_to(self._frontend_widget())\n        return None\n\n    def _process_return_value(self, return_value: Any, kwargs: dict[str, Any]):\n        main = self._main_window()\n        ui = main._himena_main_window\n        main._set_parametric_widget_busy(self, False)\n        tracker = ModelTrack.get(self._callback)\n        _return_annot = self._fn_signature.return_annotation\n        _LOGGER.info(\"Got tracker: %r\", tracker)\n        if isinstance(return_value, WidgetDataModel):\n            if prev := self._get_preview_window():\n                # no need to create a new window, just use the preview window\n                self._preview_window_ref = _do_nothing\n                if self._result_as != \"window\":\n                    widget = prev.widget  # avoid garbage collection\n                    main._remove_widget_from_parametric_window(self)\n                    result_widget = ui.add_widget(widget)\n                    result_widget._update_from_returned_model(return_value)\n                else:\n                    self._child_windows.discard(prev)\n                    result_widget = prev\n                result_widget.title = return_value.title  # title needs update\n\n                # if callback has \"is_previewing\" argument, the returned value may\n                # differ, thus the widget needs update.\n                if self._has_is_previewing:\n                    result_widget.update_model(return_value)\n                result_widget.force_not_editable(False)\n                with suppress(AttributeError):\n                    result_widget.is_editable = True\n                if self._auto_close:\n                    self._close_me(ui)\n            else:\n                result_widget = self._process_model_output(return_value, tracker)\n                if result_widget is None:\n                    if tracker is not None:\n                        new_workflow = tracker.to_workflow(kwargs)\n                        return_value.workflow = new_workflow  # needs inheritance\n                    return None\n                elif return_value.update_inplace:\n                    result_widget._widget_workflow = tracker.to_workflow(kwargs)\n            _LOGGER.info(\"Got subwindow: %r\", result_widget)\n            if tracker is not None:\n                new_workflow = tracker.to_workflow(kwargs)\n                _LOGGER.info(\n                    \"Inherited method %r, where the original method was %r\",\n                    new_workflow,\n                    return_value.workflow,\n                )\n                # NOTE: overwrite=False is needed to avoid overwriting ReaderMethod\n                result_widget._update_model_workflow(new_workflow, overwrite=False)\n                if isinstance(new_workflow, CommandExecution):\n                    if not isinstance(\n                        return_value.save_behavior_override, NoNeedToSave\n                    ):\n                        result_widget._set_ask_save_before_close(True)\n        elif _return_annot in (Parametric, ParametricWidgetProtocol):\n            raise NotImplementedError\n        else:\n            annot = getattr(self._callback, \"__annotations__\", {})\n            if isinstance(return_value, Future):\n                injection_type_hint = Future\n                # This is hacky. The injection store will process the result but the\n                # return type cannot be inherited from the callback. Here, we just set\n                # the type hint to Future and let it processed in the\n                # \"_future_done_callback\" method of himena application.\n                if prev := self._get_preview_window():\n                    top_left = (prev.rect.left, prev.rect.top)\n                    size = prev.rect.size()\n                else:\n                    top_left = (self.rect.left, self.rect.top)\n                    size = None\n                injection_ns = ui.model_app.injection_store.namespace\n                FutureInfo(\n                    type_hint=annot.get(\"return\", None),\n                    track=tracker,\n                    kwargs=kwargs,\n                    top_left=top_left,\n                    size=size,\n                ).resolve_type_hint(injection_ns).set(return_value)\n            else:\n                injection_type_hint = annot.get(\"return\", None)\n            self._process_other_output(return_value, injection_type_hint)\n        return None\n\n    def _callback_with_params(\n        self,\n        kwargs: dict[str, Any],\n        force_sync: bool = False,\n        force_close: bool = False,\n    ) -&gt; Any:\n        if self._has_is_previewing:\n            kwargs = {**kwargs, self._IS_PREVIEWING: False}\n        main = self._main_window()\n        old_run_async = self._run_asynchronously\n        try:\n            if force_sync:\n                self._run_asynchronously = False\n            return_value = self._call(**kwargs)\n        except Exception:\n            main._set_parametric_widget_busy(self, False)\n            raise\n        finally:\n            self._run_asynchronously = old_run_async\n        if isinstance(return_value, Future):\n            main._add_job_progress(return_value, desc=self.title, total=0)\n            return_value.add_done_callback(\n                main._process_future_done_callback(\n                    self._process_return_value,\n                    lambda e: main._set_parametric_widget_busy(self, False),\n                    kwargs=kwargs,\n                )\n            )\n        else:\n            main._set_parametric_widget_busy(self, False)\n            self._process_return_value(return_value, kwargs)\n        if (not self._auto_close) and force_close:\n            self._close_me(main._himena_main_window)\n        return return_value\n\n    def is_preview_enabled(self) -&gt; bool:\n        \"\"\"Whether the widget supports preview.\"\"\"\n        isfunc = getattr(self.widget, PWPN.IS_PREVIEW_ENABLED, None)\n        return callable(isfunc) and isfunc()\n\n    def _emit_btn_clicked(self) -&gt; None:\n        return self.btn_clicked.emit(self)\n\n    def _emit_param_changed(self) -&gt; None:\n        return self.params_changed.emit(self)\n\n    def _process_model_output(\n        self,\n        model: WidgetDataModel,\n        tracker: ModelTrack | None = None,\n    ) -&gt; SubWindow[_W] | None:\n        \"\"\"Process the returned WidgetDataModel.\"\"\"\n        ui = self._main_window()._himena_main_window\n        i_tab, i_win = self._find_me(ui)\n        rect = self.rect\n        if self._auto_close:\n            del ui.tabs[i_tab][i_win]\n        if model.update_inplace and tracker and tracker.contexts:\n            if win := ui._window_for_workflow_id(tracker.contexts[0].value):\n                win.update_model(model)\n                return win\n        if ui._instructions.process_model_output:\n            widget = self._model_to_new_window(model)\n            result_widget = ui.tabs[i_tab].add_widget(\n                widget, title=model.title, auto_size=False\n            )\n            # coerce rect\n            if size_hint := result_widget.size_hint():\n                new_rect = (rect.left, rect.top, size_hint[0], size_hint[1])\n            else:\n                new_rect = rect\n            result_widget.rect = new_rect\n            _checker.call_widget_added_callback(widget)\n            return result_widget._update_from_returned_model(model)\n        return None\n\n    def _model_to_new_window(self, model: WidgetDataModel) -&gt; _W:\n        ui = self._main_window()._himena_main_window\n        widget = ui._pick_widget(model)\n        return widget\n\n    def _process_other_output(self, return_value: Any, type_hint: Any | None = None):\n        _LOGGER.info(\"Got output: %r with type hint %r\", type(return_value), type_hint)\n        ui = self._main_window()._himena_main_window\n        ui.model_app.injection_store.process(return_value, type_hint=type_hint)\n        if self._auto_close:\n            with suppress(RuntimeError):\n                # FIXME: if the async command does not require parameter input, this\n                # window is already closed. We just ignore the error for now.\n                self._close_me(ui)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.ParametricWindow.get_params","title":"<code>get_params()</code>","text":"<p>Get the parameters of the widget.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def get_params(self) -&gt; dict[str, Any]:\n    \"\"\"Get the parameters of the widget.\"\"\"\n    if hasattr(self.widget, PWPN.GET_PARAMS):\n        params = getattr(self.widget, PWPN.GET_PARAMS)()\n        if not isinstance(params, dict):\n            raise TypeError(\n                f\"`{PWPN.GET_PARAMS}` of {self.widget!r} must return a dict, got \"\n                f\"{type(params)}.\"\n            )\n    else:\n        params = {}\n    return params\n</code></pre>"},{"location":"api/widgets/#himena.widgets.ParametricWindow.is_preview_enabled","title":"<code>is_preview_enabled()</code>","text":"<p>Whether the widget supports preview.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def is_preview_enabled(self) -&gt; bool:\n    \"\"\"Whether the widget supports preview.\"\"\"\n    isfunc = getattr(self.widget, PWPN.IS_PREVIEW_ENABLED, None)\n    return callable(isfunc) and isfunc()\n</code></pre>"},{"location":"api/widgets/#himena.widgets.ParametricWindow.update_params","title":"<code>update_params(params, **kwargs)</code>","text":"<p>Update the parameters of the widget.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def update_params(self, params: dict[str, Any], **kwargs) -&gt; None:\n    \"\"\"Update the parameters of the widget.\"\"\"\n    if hasattr(self.widget, PWPN.UPDATE_PARAMS):\n        getattr(self.widget, PWPN.UPDATE_PARAMS)({**params, **kwargs})\n    else:\n        raise NotImplementedError(\n            f\"{self.widget!r} does not support setting parameters.\"\n        )\n    self._emit_param_changed()\n</code></pre>"},{"location":"api/widgets/#himena.widgets.SubWindow","title":"<code>SubWindow</code>","text":"Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>class SubWindow(WidgetWrapper[_W], Layout):\n    state_changed = Signal(WindowState)\n    renamed = Signal(str)\n    closed = Signal()\n\n    def __init__(\n        self,\n        widget: _W,\n        main_window: BackendMainWindow[_W],\n    ):\n        super().__init__(widget, main_window=main_window)\n        Layout.__init__(self, main_window)\n        self._child_windows: weakref.WeakSet[SubWindow[_W]] = weakref.WeakSet()\n        self._alive = False\n        self.closed.connect(self._close_callback)\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"{type(self).__name__}(title={self.title!r}, widget={_widget_repr(self)})\"\n        )\n\n    def __class_getitem__(cls, widget_type: type[_W]):\n        # this hack allows in_n_out to assign both SubWindow and SubWindow[T] to the\n        # same provider/processor.\n        return cls\n\n    @classmethod\n    def _deserialize_layout(cls, obj: dict, main: MainWindow) -&gt; SubWindow[Any]:\n        win = main.window_for_id(uuid.UUID(obj[\"id\"]))\n        if win is None:\n            raise RuntimeError(f\"SubWindow {obj['id']} not found in main window.\")\n        return win\n\n    def _serialize_layout(self):\n        return {\"type\": \"subwindow\", \"id\": self._identifier.hex}\n\n    @property\n    def title(self) -&gt; str:\n        \"\"\"Title of the sub-window.\"\"\"\n        return self._main_window()._window_title(self._frontend_widget())\n\n    @title.setter\n    def title(self, value: str) -&gt; None:\n        self._main_window()._set_window_title(self._frontend_widget(), value)\n\n    @property\n    def state(self) -&gt; WindowState:\n        \"\"\"State (e.g. maximized, minimized) of the sub-window.\"\"\"\n        return self._main_window()._window_state(self._frontend_widget())\n\n    @state.setter\n    def state(self, value: WindowState | str) -&gt; None:\n        main = self._main_window()._himena_main_window\n        inst = main._instructions.updated(animate=False)\n        self._set_state(value, inst)\n\n    @property\n    def rect(self) -&gt; WindowRect:\n        \"\"\"Position and size of the sub-window.\"\"\"\n        return self._main_window()._window_rect(self._frontend_widget())\n\n    @rect.setter\n    def rect(self, value: tuple[int, int, int, int]) -&gt; None:\n        main = self._main_window()._himena_main_window\n        inst = main._instructions.updated(animate=False)\n        self._set_rect(value, inst)\n\n    @property\n    def is_alive(self) -&gt; bool:\n        \"\"\"Whether the sub-window is present in a main window.\"\"\"\n        return self._alive\n\n    def to_model(self) -&gt; WidgetDataModel:\n        \"\"\"Export the widget data.\"\"\"\n        if not self.supports_to_model:\n            raise ValueError(\"Widget does not have `to_model` method.\")\n        model = self.widget.to_model()  # type: ignore\n        if not isinstance(model, WidgetDataModel):\n            raise TypeError(\n                \"`to_model` method must return an instance of WidgetDataModel, got \"\n                f\"{type(model)}\"\n            )\n\n        if model.title is None:\n            model.title = self.title\n        if len(model.workflow) == 0:\n            model.workflow = self._widget_workflow\n        if self.is_modified:\n            self._data_modifications.update_workflow(model)\n        if model.extension_default is None:\n            model.extension_default = self._extension_default_fallback\n        return model\n\n    def update_value(self, value: Any) -&gt; None:\n        \"\"\"Update the value of the widget.\"\"\"\n        if hasattr(self.widget, \"update_value\"):\n            self.widget.update_value(value)\n        else:\n            model = self.to_model()\n            self.update_model(model.with_value(value))\n\n    def update_metadata(self, metadata: Any) -&gt; None:\n        \"\"\"Update the metadata of the widget data model.\"\"\"\n        return self.update_model(self.to_model().with_metadata(metadata))\n\n    def write_model(self, path: str | Path, plugin: str | None = None) -&gt; None:\n        \"\"\"Write the widget data to a file.\"\"\"\n        return self._write_model(path, plugin, self.to_model())\n\n    @property\n    def tab_area(self) -&gt; TabArea[_W]:\n        \"\"\"Tab area of the sub-window.\"\"\"\n        _hash = self._main_window()._tab_hash_for_window(self._frontend_widget())\n        return self._main_window()._himena_main_window.tabs._tab_areas[_hash]\n\n    def _write_model(\n        self, path: str | Path, plugin: str | None, model: WidgetDataModel\n    ) -&gt; None:\n        io_utils.write(model, path, plugin=plugin)\n        self.update_default_save_path(path)\n        return None\n\n    def _set_modification_tracking(self, enabled: bool) -&gt; None:\n        if self._data_modifications.track_enabled == enabled:\n            return None  # already in the desired state\n        if enabled and self.supports_to_model:\n            self._data_modifications = Modifications(\n                initial_value=self.to_model().value,\n                track_enabled=True,\n            )\n        else:\n            self._data_modifications = Modifications(\n                initial_value=None, track_enabled=False\n            )\n\n    def _set_state(self, value: WindowState, inst: BackendInstructions | None = None):\n        main = self._main_window()\n        front = self._frontend_widget()\n        if main._window_state(front) is value:  # if already in the state, do nothing\n            return None\n        if inst is None:\n            inst = main._himena_main_window._instructions\n        main._set_window_state(front, value, inst)\n        stack = self.tab_area._minimized_window_stack_layout\n        if value is WindowState.MIN:\n            stack.add(self)\n            self.anchor = None\n        elif value in (WindowState.FULL, WindowState.MAX):\n            self.anchor = _anchor.AllCornersAnchor()\n        else:\n            self.anchor = None\n            if self._parent_layout_ref() is stack:\n                stack.remove(self)\n                stack._reanchor(Size(*main._area_size()))\n\n    def _set_rect(\n        self,\n        value: tuple[int, int, int, int],\n        inst: BackendInstructions | None = None,\n    ):\n        if inst is None:\n            inst = self._main_window()._himena_main_window._instructions\n        rect_old = self.rect\n        main = self._main_window()\n        front = self._frontend_widget()\n        rect = WindowRect.from_tuple(*value)\n        anc = self.anchor.update_for_window_rect(main._area_size(), rect)\n        main._set_window_rect(front, rect, inst)\n        self.anchor = anc\n        if parent := self._parent_layout_ref():\n            parent._adjust_child_resize(self, rect_old, rect)\n\n    def _reanchor(self, size: Size):\n        if self.state is WindowState.MIN:\n            pass\n        elif self.state in (WindowState.MAX, WindowState.FULL):\n            self.rect = WindowRect(0, 0, *size)\n        else:\n            super()._reanchor(size)\n\n    def _process_drop_event(\n        self,\n        incoming: DragDataModel,\n        source: SubWindow[_W] | None = None,\n    ) -&gt; bool:\n        if hasattr(self.widget, \"dropped_callback\"):\n            # to remember how the model was mapped to a widget class\n            model = incoming.data_model()\n            if source is not None:\n                model.force_open_with = get_widget_class_id(source.widget)\n            drop_result = self.widget.dropped_callback(model)\n            if drop_result is None:\n                drop_result = DropResult()\n            ui = self._main_window()._himena_main_window\n            if drop_result.command_id:\n                # record the command\n                out = ui.exec_action(\n                    drop_result.command_id,\n                    window_context=self,\n                    model_context=self.to_model(),\n                    with_params=drop_result.with_params,\n                    process_model_output=False,\n                )\n                if isinstance(out, WidgetDataModel):\n                    self.update_model(out)\n                    self._update_model_workflow(out.workflow)\n            if source is not None:\n                if drop_result.delete_input:\n                    source._close_me(ui)\n                ui._backend_main_window._move_focus_to(source._frontend_widget())\n            return True\n        return False\n\n    def update(\n        self,\n        *,\n        rect: tuple[int, int, int, int] | WindowRect | None = None,\n        state: WindowState | None = None,\n        title: str | None = None,\n        anchor: _anchor.WindowAnchor | str | None = None,\n    ) -&gt; SubWindow[_W]:\n        \"\"\"A helper method to update window properties.\"\"\"\n        if rect is not None:\n            self.rect = rect\n        if state is not None:\n            self.state = state\n        if title is not None:\n            self.title = title\n        if anchor is not None:\n            self.anchor = anchor\n        return self\n\n    def add_child(\n        self,\n        widget: _W,\n        *,\n        title: str | None = None,\n    ) -&gt; SubWindow[_W]:\n        \"\"\"Add a child sub-window, which is automatically closed when the parent is closed.\"\"\"  # noqa: E501\n        main = self._main_window()._himena_main_window\n        i_tab, _ = self._find_me(main)\n        child = main.tabs[i_tab].add_widget(widget, title=title)\n        self._child_windows.add(child)\n        return child\n\n    def _find_me(self, main: MainWindow) -&gt; tuple[int, int]:\n        for i_tab, tab in main.tabs.enumerate():\n            for i_win, win in tab.enumerate():\n                # NOTE: should not be `win is self`, because the wrapper may be\n                # recreated\n                if win.widget is self.widget:\n                    return i_tab, i_win\n        raise RuntimeError(f\"SubWindow {self.title} not found in main window.\")\n\n    def _close_me(self, main: MainWindow, confirm: bool = False) -&gt; None:\n        if self._need_ask_save_before_close() and confirm:\n            title_short = repr(self.title)\n            if len(title_short) &gt; 60:\n                title_short = title_short[:60] + \"...\"\n            if isinstance(self.save_behavior, SaveToNewPath):\n                message = f\"{title_short} is not saved yet. Save before closing?\"\n            else:\n                message = f\"Save changes to {title_short}?\"\n            resp = main.exec_choose_one_dialog(\n                title=\"Closing window\",\n                message=message,\n                choices=[\"Save\", \"Don't save\", \"Cancel\"],\n            )\n            if resp is None or resp == \"Cancel\":\n                return None\n            elif resp == \"Save\":\n                if cb := self._save_from_dialog(main):\n                    cb()\n                else:\n                    return None\n\n        i_tab, i_win = self._find_me(main)\n        del main.tabs[i_tab][i_win]\n\n    def _save_from_dialog(\n        self,\n        main: MainWindow,\n        behavior: SaveBehavior | None = None,\n        plugin: str | None = None,\n    ) -&gt; Callable[[], Path] | None:\n        \"\"\"Save this window to a new path, return if saved.\"\"\"\n        if behavior is None:\n            behavior = self.save_behavior\n        model = self.to_model()\n        if save_path := behavior.get_save_path(main, model):\n\n            def _save():\n                main.set_status_tip(f\"Saving {self.title!r} to {save_path}\", duration=2)\n                self._write_model(save_path, plugin=plugin, model=model)\n                main.set_status_tip(f\"Saved {self.title!r} to {save_path}\", duration=2)\n                return save_path\n\n            return _save\n        return None\n\n    def _close_all_children(self, main: MainWindow) -&gt; None:\n        \"\"\"Close all the sub-windows that are children of this window.\"\"\"\n        for child in self._child_windows:\n            child._close_all_children(main)\n            if child.is_alive:\n                child._close_me(main, confirm=False)\n\n    def _close_callback(self):\n        main = self._main_window()._himena_main_window\n        self._close_all_children(main)\n        if layout := self._parent_layout_ref():\n            layout.remove(self)\n        self._alive = False\n\n    def _determine_read_from(self) -&gt; tuple[Path | list[Path], str | None] | None:\n        \"\"\"Determine how can the data be efficiently read.\"\"\"\n        workflow = self._widget_workflow.last()\n        if isinstance(workflow, LocalReaderMethod):\n            return workflow.path, workflow.plugin\n        elif isinstance(save_bh := self.save_behavior, SaveToPath):\n            return save_bh.path, None\n        else:\n            return None\n\n    def _update_from_returned_model(self, model: WidgetDataModel) -&gt; SubWindow[_W]:\n        \"\"\"Update the sub-window based on the returned model.\"\"\"\n        if (wf := model.workflow.last()) is not None:\n            if isinstance(wf, LocalReaderMethod):\n                # file is directly read from the local path\n                if isinstance(save_path := wf.path, Path):\n                    self.update_default_save_path(save_path, plugin=wf.plugin)\n            elif isinstance(wf, CommandExecution):\n                # model is created by some command\n                if not isinstance(model.save_behavior_override, NoNeedToSave):\n                    self._set_ask_save_before_close(True)\n            self._identifier = wf.id\n        if len(wlist := model.workflow) &gt; 0:\n            self._update_model_workflow(wlist)\n        if save_behavior_override := model.save_behavior_override:\n            self._save_behavior = save_behavior_override\n        if not model.editable:\n            with suppress(AttributeError):\n                self.is_editable = False\n\n        if model.is_subtype_of(\"text\"):\n            self._set_modification_tracking(True)\n        return self\n\n    def _switch_to_file_watch_mode(self):\n        # TODO: don't use Qt in the future\n        from himena.qt._qtwatchfiles import QWatchFileObject\n\n        self.title = f\"[Preview] {self.title}\"\n        QWatchFileObject(self)\n        return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.SubWindow.is_alive","title":"<code>is_alive</code>  <code>property</code>","text":"<p>Whether the sub-window is present in a main window.</p>"},{"location":"api/widgets/#himena.widgets.SubWindow.rect","title":"<code>rect</code>  <code>property</code> <code>writable</code>","text":"<p>Position and size of the sub-window.</p>"},{"location":"api/widgets/#himena.widgets.SubWindow.state","title":"<code>state</code>  <code>property</code> <code>writable</code>","text":"<p>State (e.g. maximized, minimized) of the sub-window.</p>"},{"location":"api/widgets/#himena.widgets.SubWindow.tab_area","title":"<code>tab_area</code>  <code>property</code>","text":"<p>Tab area of the sub-window.</p>"},{"location":"api/widgets/#himena.widgets.SubWindow.title","title":"<code>title</code>  <code>property</code> <code>writable</code>","text":"<p>Title of the sub-window.</p>"},{"location":"api/widgets/#himena.widgets.SubWindow.add_child","title":"<code>add_child(widget, *, title=None)</code>","text":"<p>Add a child sub-window, which is automatically closed when the parent is closed.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def add_child(\n    self,\n    widget: _W,\n    *,\n    title: str | None = None,\n) -&gt; SubWindow[_W]:\n    \"\"\"Add a child sub-window, which is automatically closed when the parent is closed.\"\"\"  # noqa: E501\n    main = self._main_window()._himena_main_window\n    i_tab, _ = self._find_me(main)\n    child = main.tabs[i_tab].add_widget(widget, title=title)\n    self._child_windows.add(child)\n    return child\n</code></pre>"},{"location":"api/widgets/#himena.widgets.SubWindow.to_model","title":"<code>to_model()</code>","text":"<p>Export the widget data.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def to_model(self) -&gt; WidgetDataModel:\n    \"\"\"Export the widget data.\"\"\"\n    if not self.supports_to_model:\n        raise ValueError(\"Widget does not have `to_model` method.\")\n    model = self.widget.to_model()  # type: ignore\n    if not isinstance(model, WidgetDataModel):\n        raise TypeError(\n            \"`to_model` method must return an instance of WidgetDataModel, got \"\n            f\"{type(model)}\"\n        )\n\n    if model.title is None:\n        model.title = self.title\n    if len(model.workflow) == 0:\n        model.workflow = self._widget_workflow\n    if self.is_modified:\n        self._data_modifications.update_workflow(model)\n    if model.extension_default is None:\n        model.extension_default = self._extension_default_fallback\n    return model\n</code></pre>"},{"location":"api/widgets/#himena.widgets.SubWindow.update","title":"<code>update(*, rect=None, state=None, title=None, anchor=None)</code>","text":"<p>A helper method to update window properties.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def update(\n    self,\n    *,\n    rect: tuple[int, int, int, int] | WindowRect | None = None,\n    state: WindowState | None = None,\n    title: str | None = None,\n    anchor: _anchor.WindowAnchor | str | None = None,\n) -&gt; SubWindow[_W]:\n    \"\"\"A helper method to update window properties.\"\"\"\n    if rect is not None:\n        self.rect = rect\n    if state is not None:\n        self.state = state\n    if title is not None:\n        self.title = title\n    if anchor is not None:\n        self.anchor = anchor\n    return self\n</code></pre>"},{"location":"api/widgets/#himena.widgets.SubWindow.update_metadata","title":"<code>update_metadata(metadata)</code>","text":"<p>Update the metadata of the widget data model.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def update_metadata(self, metadata: Any) -&gt; None:\n    \"\"\"Update the metadata of the widget data model.\"\"\"\n    return self.update_model(self.to_model().with_metadata(metadata))\n</code></pre>"},{"location":"api/widgets/#himena.widgets.SubWindow.update_value","title":"<code>update_value(value)</code>","text":"<p>Update the value of the widget.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def update_value(self, value: Any) -&gt; None:\n    \"\"\"Update the value of the widget.\"\"\"\n    if hasattr(self.widget, \"update_value\"):\n        self.widget.update_value(value)\n    else:\n        model = self.to_model()\n        self.update_model(model.with_value(value))\n</code></pre>"},{"location":"api/widgets/#himena.widgets.SubWindow.write_model","title":"<code>write_model(path, plugin=None)</code>","text":"<p>Write the widget data to a file.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def write_model(self, path: str | Path, plugin: str | None = None) -&gt; None:\n    \"\"\"Write the widget data to a file.\"\"\"\n    return self._write_model(path, plugin, self.to_model())\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea","title":"<code>TabArea</code>","text":"<p>An area containing multiple sub-windows.</p> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>class TabArea(SemiMutableSequence[SubWindow[_W]], _HasMainWindowRef[_W]):\n    \"\"\"An area containing multiple sub-windows.\"\"\"\n\n    def __init__(self, main_window: BackendMainWindow[_W], hash_value: Hashable):\n        super().__init__(main_window)\n        self._hash_value = hash_value\n        # A tab area always has a layout for stacking minimized windows\n        self._minimized_window_stack_layout = VStackLayout(main_window, inverted=True)\n        self._layouts = [self._minimized_window_stack_layout]\n        self._minimized_window_stack_layout._reanchor(Size(*main_window._area_size()))\n        # the tab-specific result stack\n        self._result_stack_ref: Callable[[], _W | None] = lambda: None\n\n    @property\n    def layouts(self) -&gt; FrozenList[Layout]:\n        \"\"\"List of layouts in the tab area.\"\"\"\n        return FrozenList(self._layouts)\n\n    def _tab_index(self) -&gt; int:\n        main = self._main_window()\n        for i in range(main._num_tabs()):\n            if main._tab_hash(i) == self._hash_value:\n                return i\n        raise ValueError(\"Tab is already removed from the main window.\")\n\n    def __getitem__(self, index_or_name: int | str) -&gt; SubWindow[_W]:\n        index = self._norm_index_or_name(index_or_name)\n        widgets = self._main_window()._get_widget_list(self._tab_index())\n        front = widgets[index][1]\n        return front._himena_widget\n\n    def __delitem__(self, index_or_name: int | str) -&gt; None:\n        index = self._norm_index_or_name(index_or_name)\n        win, widget = self._pop_no_emit(index)\n        _checker.call_widget_closed_callback(widget)\n        win.closed.emit()\n\n    def _pop_no_emit(self, index: int) -&gt; tuple[SubWindow[_W], _W]:\n        main = self._main_window()\n        win = self[index]\n        widget = win.widget  # get widget here to avoid garbage collection\n        main._del_widget_at(self._tab_index(), index)\n        main._remove_control_widget(widget)\n        if isinstance(sb := win.save_behavior, SaveToPath):\n            main._himena_main_window._history_closed.add((sb.path, sb.plugin))\n        return win, widget\n\n    def __len__(self) -&gt; int:\n        return len(self._main_window()._get_widget_list(self._tab_index()))\n\n    def __iter__(self) -&gt; Iterator[SubWindow[_W]]:\n        return iter(\n            w[1]._himena_widget\n            for w in self._main_window()._get_widget_list(self._tab_index())\n        )\n\n    def append(self, sub_window: SubWindow[_W], title: str) -&gt; None:\n        \"\"\"Append a sub-window to the tab area.\"\"\"\n        main = self._main_window()\n        interf, front = sub_window._split_interface_and_frontend()\n        front._himena_widget = sub_window\n        out = main.add_widget(front, self._tab_index(), title)\n        if hasattr(interf, \"control_widget\"):\n            main._set_control_widget(front, interf.control_widget())\n\n        main._connect_window_events(sub_window, out)\n        sub_window.title = title\n        sub_window.state_changed.connect(main._update_context)\n\n        main._set_current_tab_index(self._tab_index())\n        if main._himena_main_window._new_widget_behavior is NewWidgetBehavior.TAB:\n            main._set_window_state(\n                front,\n                WindowState.FULL,\n                main._himena_main_window._instructions.updated(animate=False),\n            )\n\n        main._move_focus_to(front)\n        sub_window._alive = True\n        return None\n\n    def current(self, default: _T = None) -&gt; SubWindow[_W] | _T:\n        \"\"\"Get the current sub-window or a default value.\"\"\"\n        idx = self.current_index\n        if idx is None:\n            return default\n        try:\n            return self[idx]\n        except IndexError:\n            return default\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Name of the tab area.\"\"\"\n        return self._main_window()._get_tab_name_list()[self._tab_index()]\n\n    @property\n    def current_index(self) -&gt; int | None:\n        \"\"\"Get the index of the current sub-window.\"\"\"\n        return self._main_window()._current_sub_window_index(self._tab_index())\n\n    @current_index.setter\n    def current_index(self, index: int) -&gt; None:\n        self._main_window()._set_current_sub_window_index(self._tab_index(), index)\n\n    @property\n    def title(self) -&gt; str:\n        \"\"\"Title of the tab area.\"\"\"\n        return self._main_window()._tab_title(self._tab_index())\n\n    def add_widget(\n        self,\n        widget: _W,\n        *,\n        title: str | None = None,\n        auto_size: bool = True,\n    ) -&gt; SubWindow[_W]:\n        \"\"\"Add a widget to the sub window.\n\n        Parameters\n        ----------\n        widget : QtW.QWidget\n            Widget to add.\n        title : str, optional\n            Title of the sub-window. If not given, its name will be automatically\n            generated.\n\n        Returns\n        -------\n        SubWindow\n            A sub-window widget. The added widget is available by calling\n            `widget` property.\n        \"\"\"\n        main = self._main_window()\n        sub_window = SubWindow(widget=widget, main_window=main)\n        self._process_new_widget(sub_window, title, auto_size)\n        main._move_focus_to(sub_window._split_interface_and_frontend()[1])\n        _checker.call_theme_changed_callback(widget, main._himena_main_window.theme)\n        return sub_window\n\n    def add_function(\n        self,\n        func: Callable[..., _T],\n        *,\n        preview: bool = False,\n        title: str | None = None,\n        show_parameter_labels: bool = True,\n        auto_close: bool = True,\n        run_async: bool = False,\n        result_as: Literal[\"window\", \"below\", \"right\"] = \"window\",\n    ) -&gt; ParametricWindow[_W]:\n        \"\"\"Add a function as a parametric sub-window.\n\n        The input function must return a `WidgetDataModel` instance, which can be\n        interpreted by the application.\n\n        Parameters\n        ----------\n        func : function (...) -&gt; WidgetDataModel\n            Function that generates a model from the input parameters.\n        preview : bool, default False\n            If true, the parametric widget will be implemented with a preview toggle\n            button, and the preview window will be created when it is enabled.\n        title : str, optional\n            Title of the parametric window.\n        show_parameter_labels : bool, default True\n            If true, the parameter labels will be shown in the parametric window.\n        auto_close : bool, default True\n            If true, close the parametric window after the function call.\n\n        Returns\n        -------\n        SubWindow\n            The sub-window instance that represents the output model.\n        \"\"\"\n        sig = inspect.signature(func)\n        back_main = self._main_window()\n        _is_prev_arg = ParametricWindow._IS_PREVIEWING\n        if preview and _is_prev_arg in sig.parameters:\n            parameters = [p for p in sig.parameters.values() if p.name != _is_prev_arg]\n            sig = sig.replace(parameters=parameters)\n        fn_widget = back_main._signature_to_widget(\n            sig,\n            show_parameter_labels=show_parameter_labels,\n            preview=preview,\n        )\n        param_widget = self.add_parametric_widget(\n            fn_widget, func, title=title, preview=preview, run_async=run_async,\n            auto_close=auto_close, result_as=result_as,\n        )  # fmt: skip\n        return param_widget\n\n    def add_parametric_widget(\n        self,\n        widget: _W,\n        callback: Callable | None = None,\n        *,\n        title: str | None = None,\n        preview: bool = False,\n        auto_close: bool = True,\n        auto_size: bool = True,\n        run_async: bool = False,\n        result_as: Literal[\"window\", \"below\", \"right\"] = \"window\",\n    ) -&gt; ParametricWindow[_W]:\n        \"\"\"Add a custom parametric widget and its callback as a subwindow.\n\n        This method creates a parametric window inside the workspace, so that the\n        calculation can be done with the user-defined parameters.\n\n        Parameters\n        ----------\n        widget : _W\n            The parametric widget implemented with `get_params` and/or `get_output`.\n        callback : callable, optional\n            The callback function that will be called with the parameters set by the\n            widget.\n        title : str, optional\n            Title of the window to manage parameters.\n        preview : bool, default False\n            If true, the parametric widget will be check for whether preview is enabled\n            everytime the parameter changed, and if preview is enabled, a preview window\n            is created to show the preview result.\n        auto_close : bool, default True\n            If true, close the parametric window after the function call.\n        auto_size : bool, default True\n            If true, the output window will be auto-sized to the size of the parametric\n            window.\n\n        Returns\n        -------\n        ParametricWindow[_W]\n            A wrapper containing the backend widget.\n        \"\"\"\n        if callback is None:\n            if not hasattr(widget, PWPN.GET_OUTPUT):\n                raise TypeError(\n                    f\"Parametric widget must have `{PWPN.GET_OUTPUT}` method if \"\n                    \"callback is not given.\"\n                )\n            callback = getattr(widget, PWPN.GET_OUTPUT)\n        main = self._main_window()\n        widget0 = main._process_parametric_widget(widget)\n        param_widget = ParametricWindow(widget0, callback, main_window=main)\n        param_widget._auto_close = auto_close\n        param_widget._result_as = result_as\n        param_widget._run_asynchronously = run_async\n        main._connect_parametric_widget_events(param_widget, widget0)\n        self._process_new_widget(param_widget, title, auto_size)\n        if preview:\n            if not (\n                hasattr(widget, PWPN.CONNECT_CHANGED_SIGNAL)\n                and hasattr(widget, PWPN.IS_PREVIEW_ENABLED)\n            ):\n                raise TypeError(\n                    f\"If preview=True, the backend widget {widget!r} must implements \"\n                    f\"methods {PWPN.CONNECT_CHANGED_SIGNAL!r} and \"\n                    f\"{PWPN.IS_PREVIEW_ENABLED!r}\"\n                )\n            param_widget.params_changed.connect(param_widget._widget_preview_callback)\n        main._move_focus_to(widget0)\n        return param_widget\n\n    def add_layout(self, layout: Layout) -&gt; Layout:\n        layout._main_window_ref = weakref.ref(self._main_window())\n        return self._add_layout_impl(layout)\n\n    def add_vbox_layout(\n        self,\n        *,\n        margins: Margins[int] | tuple[int, int, int, int] = (0, 0, 0, 0),\n        spacing: int = 0,\n    ) -&gt; VBoxLayout:\n        \"\"\"Add a vertical box layout to the tab area.\n\n        Parameters\n        ----------\n        margins : (int, int, int, int) or Margins, optional\n            Left, top, right and bottom margins of the layout.\n        spacing : int, optional\n            Spacing between the widgets.\n        \"\"\"\n        main = self._main_window()\n        layout = VBoxLayout(main, margins=margins, spacing=spacing)\n        return self._add_layout_impl(layout)\n\n    def add_hbox_layout(\n        self,\n        *,\n        margins: Margins[int] | tuple[int, int, int, int] = (0, 0, 0, 0),\n        spacing: int = 0,\n    ) -&gt; HBoxLayout:\n        \"\"\"Add a horizontal box layout to the tab area.\n\n        Parameters\n        ----------\n        margins : (int, int, int, int) or Margins, optional\n            Left, top, right and bottom margins of the layout.\n        spacing : int, optional\n            Spacing between the widgets.\n        \"\"\"\n        main = self._main_window()\n        layout = HBoxLayout(main, margins=margins, spacing=spacing)\n        return self._add_layout_impl(layout)\n\n    def _add_layout_impl(self, layout: Layout) -&gt; Layout:\n        self._layouts.append(layout)\n        layout._reanchor(self._main_window()._area_size())\n        return layout\n\n    def _process_new_widget(\n        self,\n        sub_window: SubWindow[_W],\n        title: str | None = None,\n        auto_size: bool = True,\n    ) -&gt; None:\n        \"\"\"Add, resize, and set the focus to the new widget.\"\"\"\n        main = self._main_window()\n        interf, front = sub_window._split_interface_and_frontend()\n        if title is None:\n            title = getattr(interf, \"default_title\", _make_title)(len(self))\n        out = main.add_widget(front, self._tab_index(), title)\n        if hasattr(interf, \"control_widget\"):\n            main._set_control_widget(front, interf.control_widget())\n\n        main._connect_window_events(sub_window, out)\n        sub_window.title = title\n        sub_window.state_changed.connect(main._update_context)\n\n        main._set_current_tab_index(self._tab_index())\n        nwindows = len(self)\n        if main._himena_main_window._new_widget_behavior is NewWidgetBehavior.TAB:\n            main._set_window_state(\n                front,\n                WindowState.FULL,\n                main._himena_main_window._instructions.updated(animate=False),\n            )\n        else:\n            i_tab = main._current_tab_index()\n            main._set_current_sub_window_index(i_tab, len(self) - 1)\n            if auto_size:\n                left = 4 + 24 * (nwindows % 5)\n                top = 4 + 24 * (nwindows % 5)\n                if size_hint := sub_window.size_hint():\n                    width, height = size_hint\n                else:\n                    _, _, width, height = sub_window.rect\n                sub_window.rect = WindowRect(left, top, width, height)\n        _checker.call_widget_added_callback(sub_window.widget)\n        sub_window._alive = True\n        return None\n\n    def add_data_model(self, model: WidgetDataModel) -&gt; SubWindow[_W]:\n        \"\"\"Add a widget data model as a widget.\"\"\"\n        if not isinstance(model, WidgetDataModel):\n            raise TypeError(\n                f\"input model must be an instance of WidgetDataModel, got {model!r}\"\n            )\n        if len(model.workflow) == 0:\n            # this case may happen if this method was programatically called\n            wf = ProgrammaticMethod(output_model_type=model.type).construct_workflow()\n            model = model.model_copy(update={\"workflow\": wf})\n        ui = self._main_window()._himena_main_window\n        widget = ui._pick_widget(model)\n        ui.set_status_tip(f\"Data model {model.title!r} added.\", duration=1)\n        sub_win = self.add_widget(widget, title=model.title)\n        sub_win._update_from_returned_model(model)\n        if rect_factory := model.window_rect_override:\n            rect = WindowRect.from_tuple(*rect_factory(sub_win.size))\n            sub_win.rect = rect\n        if model.extension_default is not None:\n            sub_win._extension_default_fallback = model.extension_default\n        return sub_win\n\n    def read_file(\n        self,\n        file_path: PathOrPaths,\n        plugin: str | None = None,\n    ) -&gt; SubWindow[_W]:\n        \"\"\"Read local file(s) and open as a new sub-window in this tab.\n\n        Parameters\n        ----------\n        file_path : str or Path or list of them\n            Path(s) to the file to read. If a list is given, they will be read as a\n            group, not as separate windows.\n        plugin : str, optional\n            If given, reader provider will be searched with the plugin name. This value\n            is usually the full import path to the reader provider function, such as\n            `\"himena_builtins.io.default_reader_provider\"`.\n\n        Returns\n        -------\n        SubWindow\n            The sub-window instance that is constructed based on the return value of\n            the reader.\n        \"\"\"\n        return self.read_files([file_path], plugin=plugin)[0]\n\n    def read_files(\n        self,\n        file_paths: PathOrPaths,\n        plugin: str | None = None,\n    ) -&gt; list[SubWindow[_W]]:\n        \"\"\"Read multiple files and open as new sub-windows in this tab.\"\"\"\n        models = self._paths_to_models(file_paths, plugin=plugin)\n        out = [self.add_data_model(model) for model in models]\n        ui = self._main_window()._himena_main_window\n        if len(out) == 1:\n            ui.set_status_tip(f\"File opened: {out[0].title}\", duration=5)\n        elif len(out) &gt; 1:\n            _titles = \", \".join(w.title for w in out)\n            ui.set_status_tip(f\"File opened: {_titles}\", duration=5)\n        return out\n\n    def _paths_to_models(self, file_paths: PathOrPaths, plugin: str | None = None):\n        ins = _providers.ReaderStore.instance()\n        file_paths = _norm_paths(file_paths)\n        reader_path_sets = [\n            (ins.pick(file_path, plugin=plugin), file_path) for file_path in file_paths\n        ]\n        models = [\n            reader.read_and_update_source(file_path)\n            for reader, file_path in reader_path_sets\n        ]\n        ui = self._main_window()._himena_main_window\n        ui._recent_manager.append_recent_files(\n            [(fp, reader.plugin_str) for reader, fp in reader_path_sets]\n        )\n        return models\n\n    def read_files_async(\n        self,\n        file_paths: PathOrPaths,\n        plugin: str | None = None,\n    ) -&gt; Future:\n        \"\"\"Read multiple files asynchronously and return a future.\"\"\"\n        ui = self._main_window()._himena_main_window\n        file_paths = _norm_paths(file_paths)\n        future = ui._executor.submit(self._paths_to_models, file_paths, plugin=plugin)\n        if len(file_paths) == 1:\n            ui.set_status_tip(f\"Opening: {file_paths[0].as_posix()}\", duration=5)\n        else:\n            ui.set_status_tip(f\"Opening {len(file_paths)} files\", duration=5)\n        FutureInfo(list[WidgetDataModel]).set(future)  # set info for injection store\n        return future\n\n    def save_session(\n        self,\n        file_path: str | Path,\n        save_copies: bool = False,\n        allow_calculate: Sequence[str] = (),\n    ) -&gt; None:\n        \"\"\"Save the current session to a file.\"\"\"\n        from himena.session import dump_tab_to_zip\n\n        dump_tab_to_zip(\n            self, file_path, save_copies=save_copies, allow_calculate=allow_calculate\n        )\n        return None\n\n    def tile_windows(\n        self,\n        nrows: int | None = None,\n        ncols: int | None = None,\n    ) -&gt; None:\n        main = self._main_window()\n        inst = main._himena_main_window._instructions\n        width, height = main._area_size()\n        nrows, ncols = _norm_nrows_ncols(nrows, ncols, len(self))\n\n        w = width / ncols\n        h = height / nrows\n        for i in range(nrows):\n            for j in range(ncols):\n                idx = i * ncols + j\n                if idx &gt;= len(self):\n                    break\n                x = j * width / ncols\n                y = i * height / nrows\n                sub = self[idx]\n                rect = WindowRect.from_tuple(x, y, w, h)\n                main._set_window_rect(sub.widget, rect, inst)\n        return None\n\n    def _norm_index_or_name(self, index_or_name: int | str) -&gt; int:\n        if isinstance(index_or_name, str):\n            for i, w in enumerate(\n                self._main_window()._get_widget_list(self._tab_index())\n            ):\n                if w[0] == index_or_name:\n                    index = i\n                    break\n            else:\n                raise ValueError(f\"Name {index_or_name!r} not found.\")\n        else:\n            if index_or_name &lt; 0:\n                index = len(self) + index_or_name\n            else:\n                index = index_or_name\n        return index\n\n    def _discard_result_stack_ref(self):\n        \"\"\"Discard the result stack reference.\"\"\"\n        self._result_stack_ref = lambda: None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea.current_index","title":"<code>current_index</code>  <code>property</code> <code>writable</code>","text":"<p>Get the index of the current sub-window.</p>"},{"location":"api/widgets/#himena.widgets.TabArea.layouts","title":"<code>layouts</code>  <code>property</code>","text":"<p>List of layouts in the tab area.</p>"},{"location":"api/widgets/#himena.widgets.TabArea.name","title":"<code>name</code>  <code>property</code>","text":"<p>Name of the tab area.</p>"},{"location":"api/widgets/#himena.widgets.TabArea.title","title":"<code>title</code>  <code>property</code>","text":"<p>Title of the tab area.</p>"},{"location":"api/widgets/#himena.widgets.TabArea.add_data_model","title":"<code>add_data_model(model)</code>","text":"<p>Add a widget data model as a widget.</p> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>def add_data_model(self, model: WidgetDataModel) -&gt; SubWindow[_W]:\n    \"\"\"Add a widget data model as a widget.\"\"\"\n    if not isinstance(model, WidgetDataModel):\n        raise TypeError(\n            f\"input model must be an instance of WidgetDataModel, got {model!r}\"\n        )\n    if len(model.workflow) == 0:\n        # this case may happen if this method was programatically called\n        wf = ProgrammaticMethod(output_model_type=model.type).construct_workflow()\n        model = model.model_copy(update={\"workflow\": wf})\n    ui = self._main_window()._himena_main_window\n    widget = ui._pick_widget(model)\n    ui.set_status_tip(f\"Data model {model.title!r} added.\", duration=1)\n    sub_win = self.add_widget(widget, title=model.title)\n    sub_win._update_from_returned_model(model)\n    if rect_factory := model.window_rect_override:\n        rect = WindowRect.from_tuple(*rect_factory(sub_win.size))\n        sub_win.rect = rect\n    if model.extension_default is not None:\n        sub_win._extension_default_fallback = model.extension_default\n    return sub_win\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea.add_function","title":"<code>add_function(func, *, preview=False, title=None, show_parameter_labels=True, auto_close=True, run_async=False, result_as='window')</code>","text":"<p>Add a function as a parametric sub-window.</p> <p>The input function must return a <code>WidgetDataModel</code> instance, which can be interpreted by the application.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>function (...) -&gt; WidgetDataModel</code> <p>Function that generates a model from the input parameters.</p> required <code>preview</code> <code>bool</code> <p>If true, the parametric widget will be implemented with a preview toggle button, and the preview window will be created when it is enabled.</p> <code>False</code> <code>title</code> <code>str</code> <p>Title of the parametric window.</p> <code>None</code> <code>show_parameter_labels</code> <code>bool</code> <p>If true, the parameter labels will be shown in the parametric window.</p> <code>True</code> <code>auto_close</code> <code>bool</code> <p>If true, close the parametric window after the function call.</p> <code>True</code> <p>Returns:</p> Type Description <code>SubWindow</code> <p>The sub-window instance that represents the output model.</p> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>def add_function(\n    self,\n    func: Callable[..., _T],\n    *,\n    preview: bool = False,\n    title: str | None = None,\n    show_parameter_labels: bool = True,\n    auto_close: bool = True,\n    run_async: bool = False,\n    result_as: Literal[\"window\", \"below\", \"right\"] = \"window\",\n) -&gt; ParametricWindow[_W]:\n    \"\"\"Add a function as a parametric sub-window.\n\n    The input function must return a `WidgetDataModel` instance, which can be\n    interpreted by the application.\n\n    Parameters\n    ----------\n    func : function (...) -&gt; WidgetDataModel\n        Function that generates a model from the input parameters.\n    preview : bool, default False\n        If true, the parametric widget will be implemented with a preview toggle\n        button, and the preview window will be created when it is enabled.\n    title : str, optional\n        Title of the parametric window.\n    show_parameter_labels : bool, default True\n        If true, the parameter labels will be shown in the parametric window.\n    auto_close : bool, default True\n        If true, close the parametric window after the function call.\n\n    Returns\n    -------\n    SubWindow\n        The sub-window instance that represents the output model.\n    \"\"\"\n    sig = inspect.signature(func)\n    back_main = self._main_window()\n    _is_prev_arg = ParametricWindow._IS_PREVIEWING\n    if preview and _is_prev_arg in sig.parameters:\n        parameters = [p for p in sig.parameters.values() if p.name != _is_prev_arg]\n        sig = sig.replace(parameters=parameters)\n    fn_widget = back_main._signature_to_widget(\n        sig,\n        show_parameter_labels=show_parameter_labels,\n        preview=preview,\n    )\n    param_widget = self.add_parametric_widget(\n        fn_widget, func, title=title, preview=preview, run_async=run_async,\n        auto_close=auto_close, result_as=result_as,\n    )  # fmt: skip\n    return param_widget\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea.add_hbox_layout","title":"<code>add_hbox_layout(*, margins=(0, 0, 0, 0), spacing=0)</code>","text":"<p>Add a horizontal box layout to the tab area.</p> <p>Parameters:</p> Name Type Description Default <code>margins</code> <code>(int, int, int, int) or Margins</code> <p>Left, top, right and bottom margins of the layout.</p> <code>(0, 0, 0, 0)</code> <code>spacing</code> <code>int</code> <p>Spacing between the widgets.</p> <code>0</code> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>def add_hbox_layout(\n    self,\n    *,\n    margins: Margins[int] | tuple[int, int, int, int] = (0, 0, 0, 0),\n    spacing: int = 0,\n) -&gt; HBoxLayout:\n    \"\"\"Add a horizontal box layout to the tab area.\n\n    Parameters\n    ----------\n    margins : (int, int, int, int) or Margins, optional\n        Left, top, right and bottom margins of the layout.\n    spacing : int, optional\n        Spacing between the widgets.\n    \"\"\"\n    main = self._main_window()\n    layout = HBoxLayout(main, margins=margins, spacing=spacing)\n    return self._add_layout_impl(layout)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea.add_parametric_widget","title":"<code>add_parametric_widget(widget, callback=None, *, title=None, preview=False, auto_close=True, auto_size=True, run_async=False, result_as='window')</code>","text":"<p>Add a custom parametric widget and its callback as a subwindow.</p> <p>This method creates a parametric window inside the workspace, so that the calculation can be done with the user-defined parameters.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>_W</code> <p>The parametric widget implemented with <code>get_params</code> and/or <code>get_output</code>.</p> required <code>callback</code> <code>callable</code> <p>The callback function that will be called with the parameters set by the widget.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title of the window to manage parameters.</p> <code>None</code> <code>preview</code> <code>bool</code> <p>If true, the parametric widget will be check for whether preview is enabled everytime the parameter changed, and if preview is enabled, a preview window is created to show the preview result.</p> <code>False</code> <code>auto_close</code> <code>bool</code> <p>If true, close the parametric window after the function call.</p> <code>True</code> <code>auto_size</code> <code>bool</code> <p>If true, the output window will be auto-sized to the size of the parametric window.</p> <code>True</code> <p>Returns:</p> Type Description <code>ParametricWindow[_W]</code> <p>A wrapper containing the backend widget.</p> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>def add_parametric_widget(\n    self,\n    widget: _W,\n    callback: Callable | None = None,\n    *,\n    title: str | None = None,\n    preview: bool = False,\n    auto_close: bool = True,\n    auto_size: bool = True,\n    run_async: bool = False,\n    result_as: Literal[\"window\", \"below\", \"right\"] = \"window\",\n) -&gt; ParametricWindow[_W]:\n    \"\"\"Add a custom parametric widget and its callback as a subwindow.\n\n    This method creates a parametric window inside the workspace, so that the\n    calculation can be done with the user-defined parameters.\n\n    Parameters\n    ----------\n    widget : _W\n        The parametric widget implemented with `get_params` and/or `get_output`.\n    callback : callable, optional\n        The callback function that will be called with the parameters set by the\n        widget.\n    title : str, optional\n        Title of the window to manage parameters.\n    preview : bool, default False\n        If true, the parametric widget will be check for whether preview is enabled\n        everytime the parameter changed, and if preview is enabled, a preview window\n        is created to show the preview result.\n    auto_close : bool, default True\n        If true, close the parametric window after the function call.\n    auto_size : bool, default True\n        If true, the output window will be auto-sized to the size of the parametric\n        window.\n\n    Returns\n    -------\n    ParametricWindow[_W]\n        A wrapper containing the backend widget.\n    \"\"\"\n    if callback is None:\n        if not hasattr(widget, PWPN.GET_OUTPUT):\n            raise TypeError(\n                f\"Parametric widget must have `{PWPN.GET_OUTPUT}` method if \"\n                \"callback is not given.\"\n            )\n        callback = getattr(widget, PWPN.GET_OUTPUT)\n    main = self._main_window()\n    widget0 = main._process_parametric_widget(widget)\n    param_widget = ParametricWindow(widget0, callback, main_window=main)\n    param_widget._auto_close = auto_close\n    param_widget._result_as = result_as\n    param_widget._run_asynchronously = run_async\n    main._connect_parametric_widget_events(param_widget, widget0)\n    self._process_new_widget(param_widget, title, auto_size)\n    if preview:\n        if not (\n            hasattr(widget, PWPN.CONNECT_CHANGED_SIGNAL)\n            and hasattr(widget, PWPN.IS_PREVIEW_ENABLED)\n        ):\n            raise TypeError(\n                f\"If preview=True, the backend widget {widget!r} must implements \"\n                f\"methods {PWPN.CONNECT_CHANGED_SIGNAL!r} and \"\n                f\"{PWPN.IS_PREVIEW_ENABLED!r}\"\n            )\n        param_widget.params_changed.connect(param_widget._widget_preview_callback)\n    main._move_focus_to(widget0)\n    return param_widget\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea.add_vbox_layout","title":"<code>add_vbox_layout(*, margins=(0, 0, 0, 0), spacing=0)</code>","text":"<p>Add a vertical box layout to the tab area.</p> <p>Parameters:</p> Name Type Description Default <code>margins</code> <code>(int, int, int, int) or Margins</code> <p>Left, top, right and bottom margins of the layout.</p> <code>(0, 0, 0, 0)</code> <code>spacing</code> <code>int</code> <p>Spacing between the widgets.</p> <code>0</code> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>def add_vbox_layout(\n    self,\n    *,\n    margins: Margins[int] | tuple[int, int, int, int] = (0, 0, 0, 0),\n    spacing: int = 0,\n) -&gt; VBoxLayout:\n    \"\"\"Add a vertical box layout to the tab area.\n\n    Parameters\n    ----------\n    margins : (int, int, int, int) or Margins, optional\n        Left, top, right and bottom margins of the layout.\n    spacing : int, optional\n        Spacing between the widgets.\n    \"\"\"\n    main = self._main_window()\n    layout = VBoxLayout(main, margins=margins, spacing=spacing)\n    return self._add_layout_impl(layout)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea.add_widget","title":"<code>add_widget(widget, *, title=None, auto_size=True)</code>","text":"<p>Add a widget to the sub window.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>QWidget</code> <p>Widget to add.</p> required <code>title</code> <code>str</code> <p>Title of the sub-window. If not given, its name will be automatically generated.</p> <code>None</code> <p>Returns:</p> Type Description <code>SubWindow</code> <p>A sub-window widget. The added widget is available by calling <code>widget</code> property.</p> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>def add_widget(\n    self,\n    widget: _W,\n    *,\n    title: str | None = None,\n    auto_size: bool = True,\n) -&gt; SubWindow[_W]:\n    \"\"\"Add a widget to the sub window.\n\n    Parameters\n    ----------\n    widget : QtW.QWidget\n        Widget to add.\n    title : str, optional\n        Title of the sub-window. If not given, its name will be automatically\n        generated.\n\n    Returns\n    -------\n    SubWindow\n        A sub-window widget. The added widget is available by calling\n        `widget` property.\n    \"\"\"\n    main = self._main_window()\n    sub_window = SubWindow(widget=widget, main_window=main)\n    self._process_new_widget(sub_window, title, auto_size)\n    main._move_focus_to(sub_window._split_interface_and_frontend()[1])\n    _checker.call_theme_changed_callback(widget, main._himena_main_window.theme)\n    return sub_window\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea.append","title":"<code>append(sub_window, title)</code>","text":"<p>Append a sub-window to the tab area.</p> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>def append(self, sub_window: SubWindow[_W], title: str) -&gt; None:\n    \"\"\"Append a sub-window to the tab area.\"\"\"\n    main = self._main_window()\n    interf, front = sub_window._split_interface_and_frontend()\n    front._himena_widget = sub_window\n    out = main.add_widget(front, self._tab_index(), title)\n    if hasattr(interf, \"control_widget\"):\n        main._set_control_widget(front, interf.control_widget())\n\n    main._connect_window_events(sub_window, out)\n    sub_window.title = title\n    sub_window.state_changed.connect(main._update_context)\n\n    main._set_current_tab_index(self._tab_index())\n    if main._himena_main_window._new_widget_behavior is NewWidgetBehavior.TAB:\n        main._set_window_state(\n            front,\n            WindowState.FULL,\n            main._himena_main_window._instructions.updated(animate=False),\n        )\n\n    main._move_focus_to(front)\n    sub_window._alive = True\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea.current","title":"<code>current(default=None)</code>","text":"<p>Get the current sub-window or a default value.</p> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>def current(self, default: _T = None) -&gt; SubWindow[_W] | _T:\n    \"\"\"Get the current sub-window or a default value.\"\"\"\n    idx = self.current_index\n    if idx is None:\n        return default\n    try:\n        return self[idx]\n    except IndexError:\n        return default\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea.read_file","title":"<code>read_file(file_path, plugin=None)</code>","text":"<p>Read local file(s) and open as a new sub-window in this tab.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str or Path or list of them</code> <p>Path(s) to the file to read. If a list is given, they will be read as a group, not as separate windows.</p> required <code>plugin</code> <code>str</code> <p>If given, reader provider will be searched with the plugin name. This value is usually the full import path to the reader provider function, such as <code>\"himena_builtins.io.default_reader_provider\"</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>SubWindow</code> <p>The sub-window instance that is constructed based on the return value of the reader.</p> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>def read_file(\n    self,\n    file_path: PathOrPaths,\n    plugin: str | None = None,\n) -&gt; SubWindow[_W]:\n    \"\"\"Read local file(s) and open as a new sub-window in this tab.\n\n    Parameters\n    ----------\n    file_path : str or Path or list of them\n        Path(s) to the file to read. If a list is given, they will be read as a\n        group, not as separate windows.\n    plugin : str, optional\n        If given, reader provider will be searched with the plugin name. This value\n        is usually the full import path to the reader provider function, such as\n        `\"himena_builtins.io.default_reader_provider\"`.\n\n    Returns\n    -------\n    SubWindow\n        The sub-window instance that is constructed based on the return value of\n        the reader.\n    \"\"\"\n    return self.read_files([file_path], plugin=plugin)[0]\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea.read_files","title":"<code>read_files(file_paths, plugin=None)</code>","text":"<p>Read multiple files and open as new sub-windows in this tab.</p> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>def read_files(\n    self,\n    file_paths: PathOrPaths,\n    plugin: str | None = None,\n) -&gt; list[SubWindow[_W]]:\n    \"\"\"Read multiple files and open as new sub-windows in this tab.\"\"\"\n    models = self._paths_to_models(file_paths, plugin=plugin)\n    out = [self.add_data_model(model) for model in models]\n    ui = self._main_window()._himena_main_window\n    if len(out) == 1:\n        ui.set_status_tip(f\"File opened: {out[0].title}\", duration=5)\n    elif len(out) &gt; 1:\n        _titles = \", \".join(w.title for w in out)\n        ui.set_status_tip(f\"File opened: {_titles}\", duration=5)\n    return out\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea.read_files_async","title":"<code>read_files_async(file_paths, plugin=None)</code>","text":"<p>Read multiple files asynchronously and return a future.</p> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>def read_files_async(\n    self,\n    file_paths: PathOrPaths,\n    plugin: str | None = None,\n) -&gt; Future:\n    \"\"\"Read multiple files asynchronously and return a future.\"\"\"\n    ui = self._main_window()._himena_main_window\n    file_paths = _norm_paths(file_paths)\n    future = ui._executor.submit(self._paths_to_models, file_paths, plugin=plugin)\n    if len(file_paths) == 1:\n        ui.set_status_tip(f\"Opening: {file_paths[0].as_posix()}\", duration=5)\n    else:\n        ui.set_status_tip(f\"Opening {len(file_paths)} files\", duration=5)\n    FutureInfo(list[WidgetDataModel]).set(future)  # set info for injection store\n    return future\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea.save_session","title":"<code>save_session(file_path, save_copies=False, allow_calculate=())</code>","text":"<p>Save the current session to a file.</p> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>def save_session(\n    self,\n    file_path: str | Path,\n    save_copies: bool = False,\n    allow_calculate: Sequence[str] = (),\n) -&gt; None:\n    \"\"\"Save the current session to a file.\"\"\"\n    from himena.session import dump_tab_to_zip\n\n    dump_tab_to_zip(\n        self, file_path, save_copies=save_copies, allow_calculate=allow_calculate\n    )\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.append_result","title":"<code>append_result(item)</code>","text":"<p>Append a new result to the result stack.</p> Source code in <code>src\\himena\\widgets\\_functions.py</code> <pre><code>def append_result(item: dict[str, Any], /) -&gt; None:\n    \"\"\"Append a new result to the result stack.\"\"\"\n    ins = current_instance()\n    ins._backend_main_window._append_result(item)\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.current_instance","title":"<code>current_instance(name=None)</code>","text":"<p>Get current instance of the main window (raise if not exists).</p> Source code in <code>src\\himena\\widgets\\_initialize.py</code> <pre><code>def current_instance(name: str | None = None) -&gt; MainWindow[_W]:\n    \"\"\"Get current instance of the main window (raise if not exists).\"\"\"\n    if name is None:\n        name = next(iter(_APP_INSTANCES))\n    return _APP_INSTANCES[name][-1]\n</code></pre>"},{"location":"api/widgets/#himena.widgets.get_clipboard","title":"<code>get_clipboard()</code>","text":"<p>Get the current clipboard data.</p> Source code in <code>src\\himena\\widgets\\_functions.py</code> <pre><code>def get_clipboard() -&gt; ClipboardDataModel:\n    \"\"\"Get the current clipboard data.\"\"\"\n    return current_instance().clipboard\n</code></pre>"},{"location":"api/widgets/#himena.widgets.notify","title":"<code>notify(text, duration=5.0)</code>","text":"<p>Show a notification popup in the bottom right corner.</p> Source code in <code>src\\himena\\widgets\\_functions.py</code> <pre><code>def notify(text: str, duration: float = 5.0) -&gt; None:\n    \"\"\"Show a notification popup in the bottom right corner.\"\"\"\n    ins = current_instance()\n    ins._backend_main_window._show_notification(text, duration)\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.remove_instance","title":"<code>remove_instance(name, instance)</code>","text":"<p>Remove the instance from the list.</p> Source code in <code>src\\himena\\widgets\\_initialize.py</code> <pre><code>def remove_instance(name: str, instance: MainWindow[_W]) -&gt; None:\n    \"\"\"Remove the instance from the list.\"\"\"\n    if name in _APP_INSTANCES:\n        instances = _APP_INSTANCES[name]\n        if instance in instances:\n            instances.remove(instance)\n            instance.model_app.destroy(instance.model_app.name)\n        if not instances:\n            _APP_INSTANCES.pop(name, None)\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.set_clipboard","title":"<code>set_clipboard(model=None, **kwargs)</code>","text":"<pre><code>set_clipboard(*, text: str | None = None, html: str | None = None, image: Any | None = None, files: list[str | Path] | None = None, interanal_data: Any | None = None) -&gt; None\n</code></pre><pre><code>set_clipboard(model: ClipboardDataModel) -&gt; None\n</code></pre> <p>Set data to clipboard.</p> Source code in <code>src\\himena\\widgets\\_functions.py</code> <pre><code>def set_clipboard(model=None, **kwargs) -&gt; None:\n    \"\"\"Set data to clipboard.\"\"\"\n    ins = current_instance()\n    if model is not None:\n        if kwargs:\n            raise TypeError(\"Cannot specify both model and keyword arguments\")\n        ins.clipboard = model\n    else:\n        ins.set_clipboard(**kwargs)\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.set_current_instance","title":"<code>set_current_instance(name, instance)</code>","text":"<p>Set the instance as the current one.</p> Source code in <code>src\\himena\\widgets\\_initialize.py</code> <pre><code>def set_current_instance(name: str, instance: MainWindow[_W]) -&gt; None:\n    \"\"\"Set the instance as the current one.\"\"\"\n    if name not in _APP_INSTANCES:\n        _APP_INSTANCES[name] = []\n    elif instance in _APP_INSTANCES[name]:\n        _APP_INSTANCES[name].remove(instance)\n    _APP_INSTANCES[name].append(instance)\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.set_status_tip","title":"<code>set_status_tip(text, duration=10.0)</code>","text":"<p>Set a status tip to the current main window for duration (second).</p> Source code in <code>src\\himena\\widgets\\_functions.py</code> <pre><code>def set_status_tip(text: str, duration: float = 10.0) -&gt; None:\n    \"\"\"Set a status tip to the current main window for duration (second).\"\"\"\n\n    with suppress(Exception):\n        ins = current_instance()\n        ins.set_status_tip(text, duration=duration)\n    return None\n</code></pre>"},{"location":"api/standards/model_meta/","title":"himena.standards.model_meta","text":""},{"location":"api/standards/model_meta/#himena.standards.model_meta.ArrayMeta","title":"<code>ArrayMeta</code>","text":"<p>Preset for describing an array metadata.</p> <p>Parameters:</p> Name Type Description Default <code>axes</code> <code>list[DimAxis] | None</code> <p>Axes of the array.</p> <code>None</code> <code>current_indices</code> <code>tuple[Optional[int], ...] | None</code> <p>Current slice indices to render the array in GUI.</p> <code>None</code> <code>selections</code> <code>list[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Selections of the array. This attribute should be any sliceable objects that can passed to the backend array object.</p> <code>&lt;dynamic&gt;</code> <code>unit</code> <code>str | None</code> <p>Unit of the array values.</p> <code>None</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class ArrayMeta(BaseMetadata):\n    \"\"\"Preset for describing an array metadata.\"\"\"\n\n    axes: list[DimAxis] | None = Field(None, description=\"Axes of the array.\")\n    current_indices: tuple[int | None, ...] | None = Field(\n        None, description=\"Current slice indices to render the array in GUI.\"\n    )\n    selections: list[tuple[tuple[int, int], tuple[int, int]]] = Field(\n        default_factory=list,\n        description=\"Selections of the array. This attribute should be any sliceable \"\n        \"objects that can passed to the backend array object.\",\n    )\n    unit: str | None = Field(\n        None,\n        description=\"Unit of the array values.\",\n    )\n\n    def without_selections(self) -&gt; \"ArrayMeta\":\n        \"\"\"Make a copy of the metadata without selections.\"\"\"\n        return self.model_copy(update={\"selections\": []})\n\n    def expected_type(self):\n        return StandardType.ARRAY\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ArrayMeta.without_selections","title":"<code>without_selections()</code>","text":"<p>Make a copy of the metadata without selections.</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>def without_selections(self) -&gt; \"ArrayMeta\":\n    \"\"\"Make a copy of the metadata without selections.\"\"\"\n    return self.model_copy(update={\"selections\": []})\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.DataFrameMeta","title":"<code>DataFrameMeta</code>","text":"<p>Preset for describing the metadata for a \"dataframe\" type.</p> <p>Parameters:</p> Name Type Description Default <code>current_position</code> <code>list[int] | None</code> <p>Current index position of (row, column) in the table.</p> <code>None</code> <code>selections</code> <code>list[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Table selections in the format of ((row_start, row_end), (col_start, col_end)), where the end index is exclusive, as is always the case for the Python indexing.</p> <code>&lt;dynamic&gt;</code> <code>separator</code> <code>str | None</code> <p>Separator of the table.</p> <code>None</code> <code>transpose</code> <code>bool</code> <p>Whether the table is transposed.</p> <code>False</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class DataFrameMeta(TableMeta):\n    \"\"\"Preset for describing the metadata for a \"dataframe\" type.\"\"\"\n\n    transpose: bool = Field(\n        default=False, description=\"Whether the table is transposed.\"\n    )\n\n    def expected_type(self):\n        return StandardType.DATAFRAME\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.DataFramePlotMeta","title":"<code>DataFramePlotMeta</code>","text":"<p>Preset for describing the metadata for a \"dataframe.plot\" type.</p> <p>Parameters:</p> Name Type Description Default <code>current_position</code> <code>list[int] | None</code> <p>Current index position of (row, column) in the table.</p> <code>None</code> <code>selections</code> <code>list[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Table selections in the format of ((row_start, row_end), (col_start, col_end)), where the end index is exclusive, as is always the case for the Python indexing.</p> <code>&lt;dynamic&gt;</code> <code>separator</code> <code>str | None</code> <p>Separator of the table.</p> <code>None</code> <code>transpose</code> <code>bool</code> <p>Whether the table is transposed.</p> <code>False</code> <code>plot_type</code> <code>Literal['line', 'scatter']</code> <p>Type of the plot.</p> <code>'line'</code> <code>plot_color_cycle</code> <code>list[str] | None</code> <p>Color cycle of the plot.</p> <code>None</code> <code>plot_background_color</code> <code>str | None</code> <p>Background color of the plot.</p> <code>'#FFFFFF'</code> <code>rois</code> <code>RoiListModel | Callable[list, RoiListModel]</code> <p>Regions of interest.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class DataFramePlotMeta(DataFrameMeta):\n    \"\"\"Preset for describing the metadata for a \"dataframe.plot\" type.\"\"\"\n\n    model_config = {\"arbitrary_types_allowed\": True}\n\n    plot_type: Literal[\"line\", \"scatter\"] = Field(\n        \"line\", description=\"Type of the plot.\"\n    )\n    plot_color_cycle: list[str] | None = Field(\n        None, description=\"Color cycle of the plot.\"\n    )\n    plot_background_color: str | None = Field(\n        \"#FFFFFF\", description=\"Background color of the plot.\"\n    )\n    rois: roi.RoiListModel | Callable[[], roi.RoiListModel] = Field(\n        default_factory=roi.RoiListModel, description=\"Regions of interest.\"\n    )\n\n    @classmethod\n    def from_metadata(cls, dir_path: Path) -&gt; \"DataFramePlotMeta\":\n        self = cls.model_validate_json(dir_path.joinpath(_META_NAME).read_text())\n        if (rois_path := dir_path.joinpath(\"rois.roi.json\")).exists():\n            self.rois = roi.RoiListModel.model_validate_json(rois_path.read_text())\n        return self\n\n    def unwrap_rois(self) -&gt; roi.RoiListModel:\n        \"\"\"Unwrap the lazy-evaluation of the ROIs.\"\"\"\n        if isinstance(self.rois, roi.RoiListModel):\n            return self.rois\n        self.rois = self.rois()\n        return self.rois\n\n    def write_metadata(self, dir_path: Path) -&gt; None:\n        dir_path.joinpath(_META_NAME).write_text(self.model_dump_json(exclude={\"rois\"}))\n        rois = self.unwrap_rois()\n        if len(rois) &gt; 0:\n            dir_path.joinpath(\"rois.roi.json\").write_text(\n                json.dumps(rois.model_dump_typed())\n            )\n        return None\n\n    def expected_type(self):\n        return StandardType.DATAFRAME_PLOT\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.DataFramePlotMeta.unwrap_rois","title":"<code>unwrap_rois()</code>","text":"<p>Unwrap the lazy-evaluation of the ROIs.</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>def unwrap_rois(self) -&gt; roi.RoiListModel:\n    \"\"\"Unwrap the lazy-evaluation of the ROIs.\"\"\"\n    if isinstance(self.rois, roi.RoiListModel):\n        return self.rois\n    self.rois = self.rois()\n    return self.rois\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.DictMeta","title":"<code>DictMeta</code>","text":"<p>Parameters:</p> Name Type Description Default <code>current_tab</code> <code>str | None</code> <p>Current tab name.</p> <code>None</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class DictMeta(BaseMetadata):\n    current_tab: str | None = Field(None, description=\"Current tab name.\")\n    child_meta: dict[str, BaseMetadata] = Field(\n        default_factory=dict, description=\"Metadata of the child models.\"\n    )\n\n    def expected_type(self):\n        return StandardType.DICT\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.DimAxis","title":"<code>DimAxis</code>","text":"<p>A dimension axis.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the axis.</p> required <code>scale</code> <code>float</code> <p>Pixel scale of the axis.</p> <code>1.0</code> <code>origin</code> <code>float</code> <p>Offset of the axis.</p> <code>0.0</code> <code>unit</code> <code>str</code> <p>Unit of the axis spacing.</p> <code>''</code> <code>labels</code> <code>list[str]</code> <p>Category labels of the axis.</p> <code>&lt;dynamic&gt;</code> <code>default_label_format</code> <code>str</code> <p>Default format of the labels.</p> <code>'{:s}'</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class DimAxis(BaseModel):\n    \"\"\"A dimension axis.\"\"\"\n\n    name: str = Field(..., description=\"Name of the axis.\")\n    scale: float = Field(default=1.0, description=\"Pixel scale of the axis.\")\n    origin: float = Field(default=0.0, description=\"Offset of the axis.\")\n    unit: str = Field(\"\", description=\"Unit of the axis spacing.\")\n    labels: list[str] = Field(\n        default_factory=list, description=\"Category labels of the axis.\"\n    )\n    default_label_format: str = Field(\n        \"{:s}\", description=\"Default format of the labels.\"\n    )\n\n    @field_validator(\"name\", mode=\"before\")\n    def _name_to_str(cls, v):\n        return str(v)\n\n    @classmethod\n    def parse(cls, obj) -&gt; \"DimAxis\":\n        if isinstance(obj, str):\n            axis = DimAxis(name=obj)\n        elif isinstance(obj, dict):\n            axis = DimAxis(**obj)\n        elif isinstance(obj, DimAxis):\n            axis = obj\n        else:\n            raise TypeError(f\"Cannot convert {type(obj)} to DimAxis.\")\n        return axis\n\n    def get_label(self, index: int) -&gt; str:\n        \"\"\"Return the label of the axis at the given index.\"\"\"\n        if index &lt; 0:\n            raise ValueError(\"Index must be non-negative.\")\n        try:\n            return self.labels[index]\n        except IndexError:\n            return self.default_label_format.format(str(index))\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.DimAxis.get_label","title":"<code>get_label(index)</code>","text":"<p>Return the label of the axis at the given index.</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>def get_label(self, index: int) -&gt; str:\n    \"\"\"Return the label of the axis at the given index.\"\"\"\n    if index &lt; 0:\n        raise ValueError(\"Index must be non-negative.\")\n    try:\n        return self.labels[index]\n    except IndexError:\n        return self.default_label_format.format(str(index))\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.FunctionMeta","title":"<code>FunctionMeta</code>","text":"<p>Preset for describing the metadata for a \"function\" type.</p> <p>Parameters:</p> Name Type Description Default <code>source_code</code> <code>str | None</code> <p>Source code of the function.</p> <code>None</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class FunctionMeta(BaseMetadata):\n    \"\"\"Preset for describing the metadata for a \"function\" type.\"\"\"\n\n    source_code: str | None = Field(None, description=\"Source code of the function.\")\n\n    def expected_type(self):\n        return StandardType.FUNCTION\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageChannel","title":"<code>ImageChannel</code>","text":"<p>A channel in an image file.</p> <p>Parameters:</p> Name Type Description Default <code>colormap</code> <code>str | None</code> <p>Color map of the channel.</p> <code>None</code> <code>contrast_limits</code> <code>tuple[float, float] | None</code> <p>Contrast limits of the channel.</p> <code>None</code> <code>visible</code> <code>bool</code> <p>Whether the channel is visible.</p> <code>True</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class ImageChannel(BaseModel):\n    \"\"\"A channel in an image file.\"\"\"\n\n    colormap: str | None = Field(None, description=\"Color map of the channel.\")\n    contrast_limits: tuple[float, float] | None = Field(\n        None, description=\"Contrast limits of the channel.\"\n    )\n    visible: bool = Field(True, description=\"Whether the channel is visible.\")\n\n    @classmethod\n    def default(cls) -&gt; \"ImageChannel\":\n        \"\"\"Return a default channel (also used for mono-channel images).\"\"\"\n        return cls(name=None, colormap=\"gray\", contrast_limits=None)\n\n    def with_colormap(self, colormap: str) -&gt; \"ImageChannel\":\n        \"\"\"Set the colormap of the channel.\"\"\"\n        return self.model_copy(update={\"colormap\": colormap})\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageChannel.default","title":"<code>default()</code>  <code>classmethod</code>","text":"<p>Return a default channel (also used for mono-channel images).</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>@classmethod\ndef default(cls) -&gt; \"ImageChannel\":\n    \"\"\"Return a default channel (also used for mono-channel images).\"\"\"\n    return cls(name=None, colormap=\"gray\", contrast_limits=None)\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageChannel.with_colormap","title":"<code>with_colormap(colormap)</code>","text":"<p>Set the colormap of the channel.</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>def with_colormap(self, colormap: str) -&gt; \"ImageChannel\":\n    \"\"\"Set the colormap of the channel.\"\"\"\n    return self.model_copy(update={\"colormap\": colormap})\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageMeta","title":"<code>ImageMeta</code>","text":"<p>Preset for describing an image file metadata.</p> <p>Parameters:</p> Name Type Description Default <code>axes</code> <code>list[DimAxis] | None</code> <p>Axes of the array.</p> <code>None</code> <code>current_indices</code> <code>tuple[Optional[int], ...] | None</code> <p>Current slice indices to render the array in GUI.</p> <code>None</code> <code>selections</code> <code>list[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Selections of the array. This attribute should be any sliceable objects that can passed to the backend array object.</p> <code>&lt;dynamic&gt;</code> <code>unit</code> <code>str | None</code> <p>Unit of the array values.</p> <code>None</code> <code>channels</code> <code>list[ImageChannel]</code> <p>Channels of the image. At least one channel is required.</p> <code>[ImageChannel(colormap='gray', contrast_limits=None, visible=True)]</code> <code>channel_axis</code> <code>int | None</code> <p>Channel axis of the image.</p> <code>None</code> <code>is_rgb</code> <code>bool</code> <p>Whether the image is RGB.</p> <code>False</code> <code>current_roi</code> <code>RoiModel | int | None</code> <p>Current region of interest</p> <code>None</code> <code>current_roi_index</code> <code>int | None</code> <p>Current index of the ROI in the <code>rois</code>, if applicable.</p> <code>None</code> <code>rois</code> <code>RoiListModel | Callable[list, RoiListModel]</code> <p>Regions of interest.</p> <code>&lt;dynamic&gt;</code> <code>interpolation</code> <code>str | None</code> <p>Interpolation method.</p> <code>None</code> <code>skip_image_rerendering</code> <code>bool</code> <p>Skip image rerendering when the model is passed to the <code>update_model</code> method. This field is only used when a function does not touch the image data itself.</p> <code>False</code> <code>more_metadata</code> <code>Any | None</code> <p>More metadata if exists.</p> <code>None</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class ImageMeta(ArrayMeta):\n    \"\"\"Preset for describing an image file metadata.\"\"\"\n\n    model_config = {\"arbitrary_types_allowed\": True}\n\n    channels: list[ImageChannel] = Field(\n        default_factory=lambda: [ImageChannel.default()],\n        description=\"Channels of the image. At least one channel is required.\",\n    )\n    channel_axis: int | None = Field(None, description=\"Channel axis of the image.\")\n    is_rgb: bool = Field(False, description=\"Whether the image is RGB.\")\n    current_roi: roi.RoiModel | int | None = Field(\n        None, description=\"Current region of interest\"\n    )\n    current_roi_index: int | None = Field(\n        None, description=\"Current index of the ROI in the `rois`, if applicable.\"\n    )\n    rois: roi.RoiListModel | Callable[[], roi.RoiListModel] = Field(\n        default_factory=roi.RoiListModel, description=\"Regions of interest.\"\n    )\n    interpolation: str | None = Field(\n        default=None,\n        description=\"Interpolation method.\",\n    )\n    skip_image_rerendering: bool = Field(\n        default=False,\n        description=\"Skip image rerendering when the model is passed to the `update_model` method. This field is only used when a function does not touch the image data itself.\",\n    )\n    more_metadata: Any | None = Field(None, description=\"More metadata if exists.\")\n\n    def without_rois(self) -&gt; \"ImageMeta\":\n        return self.model_copy(update={\"rois\": roi.RoiListModel(), \"current_roi\": None})\n\n    def get_one_axis(self, index: int, value: int) -&gt; \"ImageMeta\":\n        \"\"\"Drop an axis by index for the array slicing arr[..., value, ...].\"\"\"\n        if index &lt; 0:\n            index += len(self.axes)\n        if index &lt; 0 or index &gt;= len(self.axes):\n            raise IndexError(f\"Invalid axis index: {index}.\")\n        axes = self.axes.copy()\n        del axes[index]\n        update = {\"axes\": axes, \"rois\": self.unwrap_rois().take_axis(index, value)}\n        if (caxis := self.channel_axis) == index:\n            update[\"channels\"] = [self.channels[value]]\n            update[\"channel_axis\"] = None\n            update[\"is_rgb\"] = False\n        elif caxis is not None:\n            update[\"channel_axis\"] = caxis - 1 if caxis &gt; index else caxis\n        return self.model_copy(update=update)\n\n    def with_current_roi(self, roi: roi.RoiModel) -&gt; \"ImageMeta\":\n        \"\"\"Set the current ROI.\"\"\"\n        update = {\"current_roi\": roi}\n        if self.current_roi_index is not None:\n            rois = self.unwrap_rois()\n            rois.items[self.current_roi_index] = roi\n            update[\"rois\"] = rois\n        return self.model_copy(update=update)\n\n    def unwrap_rois(self) -&gt; roi.RoiListModel:\n        \"\"\"Unwrap the lazy-evaluation of the ROIs.\"\"\"\n        if isinstance(self.rois, roi.RoiListModel):\n            return self.rois\n        self.rois = self.rois()\n        return self.rois\n\n    @field_validator(\"axes\", mode=\"before\")\n    def _strings_to_axes(cls, v):\n        if v is None:\n            return None\n        return [DimAxis.parse(axis) for axis in v]\n\n    @field_validator(\"channel_axis\")\n    def _is_rgb_and_channels_exclusive(cls, v, values: \"ValidationInfo\"):\n        if values.data.get(\"is_rgb\") and v is not None:\n            raise ValueError(\"Channel axis must be None for RGB images.\")\n        if v is None and len(values.data.get(\"channels\", [])) &gt; 1:\n            raise ValueError(\"Channel axis is required for multi-channel images.\")\n        return v\n\n    @field_validator(\"channels\")\n    def _channels_not_empty(cls, v, values: \"ValidationInfo\"):\n        if not v:\n            raise ValueError(\"At least one channel is required.\")\n        return v\n\n    @property\n    def contrast_limits(self) -&gt; tuple[float, float] | None:\n        \"\"\"Return the contrast limits of the first visible channel.\"\"\"\n        return self.channels[0].contrast_limits\n\n    @contrast_limits.setter\n    def contrast_limits(self, value: tuple[float, float] | None):\n        \"\"\"Set the contrast limits of all channels.\"\"\"\n        for channel in self.channels:\n            channel.contrast_limits = value\n\n    @property\n    def colormap(self) -&gt; Any | None:\n        \"\"\"Return the colormap of the first visible channel.\"\"\"\n        return self.channels[0].colormap\n\n    @colormap.setter\n    def colormap(self, value: Any | None):\n        \"\"\"Set the colormap of all channels.\"\"\"\n        for channel in self.channels:\n            channel.colormap = value\n\n    @classmethod\n    def from_metadata(cls, dir_path: Path) -&gt; \"ImageMeta\":\n        self = cls.model_validate_json(dir_path.joinpath(_META_NAME).read_text())\n        if (rois_path := dir_path.joinpath(_ROIS)).exists():\n            self.rois = roi.RoiListModel.model_validate_json(rois_path.read_text())\n        if (cur_roi_path := dir_path.joinpath(_CURRENT_ROI)).exists():\n            roi_js = json.loads(cur_roi_path.read_text())\n            self.current_roi = roi.RoiModel.construct(roi_js.pop(\"type\"), roi_js)\n        if (more_meta_path := dir_path.joinpath(_MORE_META)).exists():\n            with more_meta_path.open() as f:\n                self.more_metadata = json.load(f)\n        return self\n\n    def write_metadata(self, dir_path: Path) -&gt; None:\n        dir_path.joinpath(_META_NAME).write_text(\n            self.model_dump_json(\n                exclude={\"current_roi\", \"rois\", \"labels\", \"more_metadata\"}\n            )\n        )\n        rois = self.unwrap_rois()\n        if isinstance(cur_roi := self.current_roi, roi.RoiModel):\n            dir_path.joinpath(_CURRENT_ROI).write_text(\n                json.dumps(cur_roi.model_dump_typed())\n            )\n        if len(rois) &gt; 0:\n            dir_path.joinpath(_ROIS).write_text(json.dumps(rois.model_dump_typed()))\n        if (more_metadata := self.more_metadata) is not None:\n            try:\n                dir_path.joinpath(_MORE_META).write_text(json.dumps(more_metadata))\n            except Exception as e:\n                warnings.warn(\n                    f\"Failed to save `more_metadata`: {e}\",\n                    UserWarning,\n                    stacklevel=2,\n                )\n        return None\n\n    def expected_type(self):\n        return StandardType.IMAGE\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageMeta.colormap","title":"<code>colormap</code>  <code>property</code> <code>writable</code>","text":"<p>Return the colormap of the first visible channel.</p>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageMeta.contrast_limits","title":"<code>contrast_limits</code>  <code>property</code> <code>writable</code>","text":"<p>Return the contrast limits of the first visible channel.</p>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageMeta.get_one_axis","title":"<code>get_one_axis(index, value)</code>","text":"<p>Drop an axis by index for the array slicing arr[..., value, ...].</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>def get_one_axis(self, index: int, value: int) -&gt; \"ImageMeta\":\n    \"\"\"Drop an axis by index for the array slicing arr[..., value, ...].\"\"\"\n    if index &lt; 0:\n        index += len(self.axes)\n    if index &lt; 0 or index &gt;= len(self.axes):\n        raise IndexError(f\"Invalid axis index: {index}.\")\n    axes = self.axes.copy()\n    del axes[index]\n    update = {\"axes\": axes, \"rois\": self.unwrap_rois().take_axis(index, value)}\n    if (caxis := self.channel_axis) == index:\n        update[\"channels\"] = [self.channels[value]]\n        update[\"channel_axis\"] = None\n        update[\"is_rgb\"] = False\n    elif caxis is not None:\n        update[\"channel_axis\"] = caxis - 1 if caxis &gt; index else caxis\n    return self.model_copy(update=update)\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageMeta.unwrap_rois","title":"<code>unwrap_rois()</code>","text":"<p>Unwrap the lazy-evaluation of the ROIs.</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>def unwrap_rois(self) -&gt; roi.RoiListModel:\n    \"\"\"Unwrap the lazy-evaluation of the ROIs.\"\"\"\n    if isinstance(self.rois, roi.RoiListModel):\n        return self.rois\n    self.rois = self.rois()\n    return self.rois\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageMeta.with_current_roi","title":"<code>with_current_roi(roi)</code>","text":"<p>Set the current ROI.</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>def with_current_roi(self, roi: roi.RoiModel) -&gt; \"ImageMeta\":\n    \"\"\"Set the current ROI.\"\"\"\n    update = {\"current_roi\": roi}\n    if self.current_roi_index is not None:\n        rois = self.unwrap_rois()\n        rois.items[self.current_roi_index] = roi\n        update[\"rois\"] = rois\n    return self.model_copy(update=update)\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageRoisMeta","title":"<code>ImageRoisMeta</code>","text":"<p>Preset for describing an image-rois metadata.</p> <p>Parameters:</p> Name Type Description Default <code>selections</code> <code>list[int]</code> <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p> <code>&lt;dynamic&gt;</code> <code>axes</code> <code>list[DimAxis] | None</code> <p>Axes of the ROIs.</p> <code>None</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class ImageRoisMeta(ListMeta):\n    \"\"\"Preset for describing an image-rois metadata.\"\"\"\n\n    axes: list[DimAxis] | None = Field(None, description=\"Axes of the ROIs.\")\n\n    def expected_type(self):\n        return StandardType.ROIS\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ListMeta","title":"<code>ListMeta</code>","text":"<p>Preset for describing a metadata for a list-like object.</p> <p>Parameters:</p> Name Type Description Default <code>selections</code> <code>list[int]</code> <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class ListMeta(BaseMetadata):\n    \"\"\"Preset for describing a metadata for a list-like object.\"\"\"\n\n    selections: list[int] = Field(default_factory=list)\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.TableMeta","title":"<code>TableMeta</code>","text":"<p>Preset for describing the metadata for a \"table\" type.</p> <p>Parameters:</p> Name Type Description Default <code>current_position</code> <code>list[int] | None</code> <p>Current index position of (row, column) in the table.</p> <code>None</code> <code>selections</code> <code>list[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Table selections in the format of ((row_start, row_end), (col_start, col_end)), where the end index is exclusive, as is always the case for the Python indexing.</p> <code>&lt;dynamic&gt;</code> <code>separator</code> <code>str | None</code> <p>Separator of the table.</p> <code>None</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class TableMeta(BaseMetadata):\n    \"\"\"Preset for describing the metadata for a \"table\" type.\"\"\"\n\n    current_position: list[int] | None = Field(\n        default=None,\n        description=\"Current index position of (row, column) in the table.\",\n    )\n    selections: list[tuple[tuple[int, int], tuple[int, int]]] = Field(\n        default_factory=list,\n        description=\"Table selections in the format of ((row_start, row_end), (col_start, col_end)), where the end index is exclusive, as is always the case for the Python indexing.\",\n    )\n    separator: str | None = Field(None, description=\"Separator of the table.\")\n\n    def expected_type(self):\n        return StandardType.TABLE\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.TextMeta","title":"<code>TextMeta</code>","text":"<p>Preset for describing the metadata for a \"text\" type.</p> <p>Parameters:</p> Name Type Description Default <code>language</code> <code>str | None</code> <p>Language of the text file.</p> <code>None</code> <code>spaces</code> <code>int</code> <p>Number of spaces for indentation.</p> <code>4</code> <code>selection</code> <code>tuple[int, int] | None</code> <p>Selection range.</p> <code>None</code> <code>font_family</code> <code>str | None</code> <p>Font family.</p> <code>None</code> <code>font_size</code> <code>float</code> <p>Font size.</p> <code>10</code> <code>encoding</code> <code>str | None</code> <p>Encoding of the text file.</p> <code>None</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class TextMeta(BaseMetadata):\n    \"\"\"Preset for describing the metadata for a \"text\" type.\"\"\"\n\n    language: str | None = Field(None, description=\"Language of the text file.\")\n    spaces: int = Field(4, description=\"Number of spaces for indentation.\")\n    selection: tuple[int, int] | None = Field(None, description=\"Selection range.\")\n    font_family: str | None = Field(None, description=\"Font family.\")\n    font_size: float = Field(10, description=\"Font size.\")\n    encoding: str | None = Field(None, description=\"Encoding of the text file.\")\n\n    def expected_type(self):\n        return StandardType.TEXT\n</code></pre>"},{"location":"api/standards/plotting/","title":"himena.standards.plotting","text":"<p>Standard plotting models.</p>"},{"location":"api/standards/plotting/#himena.standards.plotting.Axes","title":"<code>Axes</code>","text":"<p>Layout model for 2D axes.</p> <p>Parameters:</p> Name Type Description Default <code>models</code> <code>list[BasePlotModel]</code> <p>Child plot models.</p> <code>&lt;dynamic&gt;</code> <code>title</code> <code>str | StyledText | None</code> <p>Title of the axes.</p> <code>None</code> <code>x</code> <code>Axis</code> <p>X-axis settings.</p> <code>&lt;dynamic&gt;</code> <code>y</code> <code>Axis</code> <p>Y-axis settings.</p> <code>&lt;dynamic&gt;</code> <code>axis_color</code> <code>str</code> <p>Axis color.</p> <code>'#000000'</code> Source code in <code>src\\himena\\standards\\plotting\\layout.py</code> <pre><code>class Axes(AxesBase, ModelsRef):\n    \"\"\"Layout model for 2D axes.\"\"\"\n\n    x: Axis = Field(default_factory=Axis, description=\"X-axis settings.\")\n    y: Axis = Field(default_factory=Axis, description=\"Y-axis settings.\")\n    axis_color: str = Field(\"#000000\", description=\"Axis color.\")\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.Axes3D","title":"<code>Axes3D</code>","text":"<p>Layout model for 3D axes.</p> <p>Parameters:</p> Name Type Description Default <code>models</code> <code>list[BasePlotModel]</code> <p>Child plot models.</p> <code>&lt;dynamic&gt;</code> <code>title</code> <code>str | StyledText | None</code> <p>Title of the axes.</p> <code>None</code> <code>x</code> <code>Axis</code> <p>X-axis settings.</p> <code>&lt;dynamic&gt;</code> <code>y</code> <code>Axis</code> <p>Y-axis settings.</p> <code>&lt;dynamic&gt;</code> <code>z</code> <code>Axis</code> <p>Z-axis settings.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\standards\\plotting\\layout3d.py</code> <pre><code>class Axes3D(AxesBase):\n    \"\"\"Layout model for 3D axes.\"\"\"\n\n    x: Axis = Field(default_factory=Axis, description=\"X-axis settings.\")\n    y: Axis = Field(default_factory=Axis, description=\"Y-axis settings.\")\n    z: Axis = Field(default_factory=Axis, description=\"Z-axis settings.\")\n\n    def scatter(\n        self,\n        x: Sequence[float],\n        y: Sequence[float],\n        z: Sequence[float],\n        *,\n        symbol: str = \"o\",\n        size: float | None = None,\n        **kwargs,\n    ) -&gt; _m3d.Scatter3D:\n        \"\"\"Create a 3D scatter plot.\"\"\"\n        model = _m3d.Scatter3D(\n            x=x, y=y, z=z, symbol=symbol, size=size, **parse_face_edge(kwargs)\n        )\n        self.models.append(model)\n        return model\n\n    def plot(\n        self,\n        x: Sequence[float],\n        y: Sequence[float],\n        z: Sequence[float],\n        **kwargs,\n    ) -&gt; _m3d.Line3D:\n        \"\"\"Create a 3D line plot.\"\"\"\n        model = _m3d.Line3D(x=x, y=y, z=z, **parse_edge(kwargs))\n        self.models.append(model)\n        return model\n\n    def surface(\n        self,\n        x: \"NDArray[np.number]\",\n        y: \"NDArray[np.number]\",\n        z: \"NDArray[np.number]\",\n        **kwargs,\n    ) -&gt; _m3d.Surface3D:\n        \"\"\"Create a 3D surface plot.\"\"\"\n        model = _m3d.Surface3D(x=x, y=y, z=z, **parse_face_edge(kwargs))\n        self.models.append(model)\n        return model\n\n    def mesh(\n        self,\n        vertices: \"NDArray[np.number]\",\n        face_indices: \"NDArray[np.number]\",\n        **kwargs,\n    ) -&gt; _m3d.Mesh3D:\n        \"\"\"Create a 3D mesh plot.\"\"\"\n        model = _m3d.Mesh3D(\n            vertices=vertices, face_indices=face_indices, **parse_face_edge(kwargs)\n        )\n        self.models.append(model)\n        return model\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.Axes3D.mesh","title":"<code>mesh(vertices, face_indices, **kwargs)</code>","text":"<p>Create a 3D mesh plot.</p> Source code in <code>src\\himena\\standards\\plotting\\layout3d.py</code> <pre><code>def mesh(\n    self,\n    vertices: \"NDArray[np.number]\",\n    face_indices: \"NDArray[np.number]\",\n    **kwargs,\n) -&gt; _m3d.Mesh3D:\n    \"\"\"Create a 3D mesh plot.\"\"\"\n    model = _m3d.Mesh3D(\n        vertices=vertices, face_indices=face_indices, **parse_face_edge(kwargs)\n    )\n    self.models.append(model)\n    return model\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.Axes3D.plot","title":"<code>plot(x, y, z, **kwargs)</code>","text":"<p>Create a 3D line plot.</p> Source code in <code>src\\himena\\standards\\plotting\\layout3d.py</code> <pre><code>def plot(\n    self,\n    x: Sequence[float],\n    y: Sequence[float],\n    z: Sequence[float],\n    **kwargs,\n) -&gt; _m3d.Line3D:\n    \"\"\"Create a 3D line plot.\"\"\"\n    model = _m3d.Line3D(x=x, y=y, z=z, **parse_edge(kwargs))\n    self.models.append(model)\n    return model\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.Axes3D.scatter","title":"<code>scatter(x, y, z, *, symbol='o', size=None, **kwargs)</code>","text":"<p>Create a 3D scatter plot.</p> Source code in <code>src\\himena\\standards\\plotting\\layout3d.py</code> <pre><code>def scatter(\n    self,\n    x: Sequence[float],\n    y: Sequence[float],\n    z: Sequence[float],\n    *,\n    symbol: str = \"o\",\n    size: float | None = None,\n    **kwargs,\n) -&gt; _m3d.Scatter3D:\n    \"\"\"Create a 3D scatter plot.\"\"\"\n    model = _m3d.Scatter3D(\n        x=x, y=y, z=z, symbol=symbol, size=size, **parse_face_edge(kwargs)\n    )\n    self.models.append(model)\n    return model\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.Axes3D.surface","title":"<code>surface(x, y, z, **kwargs)</code>","text":"<p>Create a 3D surface plot.</p> Source code in <code>src\\himena\\standards\\plotting\\layout3d.py</code> <pre><code>def surface(\n    self,\n    x: \"NDArray[np.number]\",\n    y: \"NDArray[np.number]\",\n    z: \"NDArray[np.number]\",\n    **kwargs,\n) -&gt; _m3d.Surface3D:\n    \"\"\"Create a 3D surface plot.\"\"\"\n    model = _m3d.Surface3D(x=x, y=y, z=z, **parse_face_edge(kwargs))\n    self.models.append(model)\n    return model\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.Axis","title":"<code>Axis</code>","text":"<p>Model that represents a plot axis.</p> <p>Parameters:</p> Name Type Description Default <code>lim</code> <code>tuple[float, float] | None</code> <p>Axis limits.</p> <code>None</code> <code>scale</code> <code>Literal['linear', 'log']</code> <p>Axis scale.</p> <code>'linear'</code> <code>label</code> <code>str | StyledText | None</code> <p>Axis label.</p> <code>None</code> <code>ticks</code> <code>Any | None</code> <p>Axis ticks.</p> <code>None</code> <code>grid</code> <code>bool</code> <p>Show grid or not.</p> <code>False</code> Source code in <code>src\\himena\\standards\\plotting\\components.py</code> <pre><code>class Axis(BaseModel):\n    \"\"\"Model that represents a plot axis.\"\"\"\n\n    model_config = PYDANTIC_CONFIG_STRICT\n\n    lim: tuple[float, float] | None = Field(None, description=\"Axis limits.\")\n    scale: Literal[\"linear\", \"log\"] = Field(\"linear\", description=\"Axis scale.\")\n    label: str | StyledText | None = Field(None, description=\"Axis label.\")\n    ticks: Any | None = Field(None, description=\"Axis ticks.\")\n    grid: bool = Field(False, description=\"Show grid or not.\")\n\n    @field_validator(\"lim\", mode=\"before\")\n    def _validate_lim(cls, lim) -&gt; tuple[float, float] | None:\n        if lim is None:\n            return None\n        _lim = tuple(lim)\n        if len(_lim) != 2:\n            raise ValueError(f\"Must be a tuple of 2 floats but got: {lim!r}\")\n        return _lim\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.Band","title":"<code>Band</code>","text":"<p>Plot model for band plot.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the plot.</p> <code>''</code> <code>x</code> <code>Any</code> <p>X-axis values.</p> required <code>y0</code> <code>Any</code> <p>Y-axis values of the lower bound.</p> required <code>y1</code> <code>Any</code> <p>Y-axis values of the upper bound.</p> required <code>orient</code> <code>Literal['vertical', 'horizontal']</code> <p>Orientation of the band fill.</p> <code>'vertical'</code> <code>face</code> <code>Face</code> <p>Properties of the band fill.</p> <code>&lt;dynamic&gt;</code> <code>edge</code> <code>Edge</code> <p>Properties of the band edge.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\standards\\plotting\\models.py</code> <pre><code>class Band(BasePlotModel):\n    \"\"\"Plot model for band plot.\"\"\"\n\n    x: Any = Field(..., description=\"X-axis values.\")\n    y0: Any = Field(..., description=\"Y-axis values of the lower bound.\")\n    y1: Any = Field(..., description=\"Y-axis values of the upper bound.\")\n    orient: Literal[\"vertical\", \"horizontal\"] = Field(\n        \"vertical\", description=\"Orientation of the band fill.\"\n    )\n    face: Face = Field(default_factory=Face, description=\"Properties of the band fill.\")\n    edge: Edge = Field(default_factory=Edge, description=\"Properties of the band edge.\")\n\n    def plot_option_dict(self) -&gt; dict[str, Any]:\n        from himena.qt.magicgui import EdgePropertyEdit, FacePropertyEdit\n\n        return {\n            \"name\": {\"widget_type\": \"LineEdit\", \"value\": self.name},\n            \"orient\": {\"choices\": [\"vertical\", \"horizontal\"], \"value\": self.orient},\n            \"face\": {\"widget_type\": FacePropertyEdit, \"value\": self.face.model_dump()},\n            \"edge\": {\"widget_type\": EdgePropertyEdit, \"value\": self.edge.model_dump()},\n        }\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.Bar","title":"<code>Bar</code>","text":"<p>Plot model for bar plot.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the plot.</p> <code>''</code> <code>x</code> <code>Any</code> <p>X-axis values.</p> required <code>y</code> <code>Any</code> <p>Y-axis values.</p> required <code>bottom</code> <code>float | Any</code> <p>Bottom values of the bars.</p> <code>0</code> <code>bar_width</code> <code>float | None</code> <p>Width of the bars.</p> <code>None</code> <code>orient</code> <code>Literal['vertical', 'horizontal']</code> <p>Orientation of the bar plots.</p> <code>'vertical'</code> <code>face</code> <code>Face</code> <p>Properties of the bars.</p> <code>&lt;dynamic&gt;</code> <code>edge</code> <code>Edge</code> <p>Properties of the bars.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\standards\\plotting\\models.py</code> <pre><code>class Bar(PlotModelXY):\n    \"\"\"Plot model for bar plot.\"\"\"\n\n    bottom: float | Any = Field(0, description=\"Bottom values of the bars.\")\n    bar_width: float | None = Field(None, description=\"Width of the bars.\")\n    orient: Literal[\"vertical\", \"horizontal\"] = Field(\n        \"vertical\", description=\"Orientation of the bar plots.\"\n    )\n    face: Face = Field(default_factory=Face, description=\"Properties of the bars.\")\n    edge: Edge = Field(default_factory=Edge, description=\"Properties of the bars.\")\n\n    def plot_option_dict(self) -&gt; dict[str, Any]:\n        from himena.qt.magicgui import EdgePropertyEdit, FacePropertyEdit\n\n        return {\n            \"name\": {\"widget_type\": \"LineEdit\", \"value\": self.name},\n            \"bar_width\": {\"annotation\": float, \"value\": self.bar_width},\n            \"orient\": {\"choices\": [\"vertical\", \"horizontal\"], \"value\": self.orient},\n            \"face\": {\"widget_type\": FacePropertyEdit, \"value\": self.face.model_dump()},\n            \"edge\": {\"widget_type\": EdgePropertyEdit, \"value\": self.edge.model_dump()},\n        }\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.BaseLayoutModel","title":"<code>BaseLayoutModel</code>","text":"<p>Parameters:</p> Name Type Description Default <code>hpad</code> <code>float | None</code> <p>Horizontal padding.</p> <code>None</code> <code>vpad</code> <code>float | None</code> <p>Vertical padding.</p> <code>None</code> <code>hspace</code> <code>float | None</code> <p>Horizontal space.</p> <code>None</code> <code>vspace</code> <code>float | None</code> <p>Vertical space.</p> <code>None</code> <code>background_color</code> <code>str</code> <p>Background color.</p> <code>'#FFFFFF'</code> Source code in <code>src\\himena\\standards\\plotting\\layout.py</code> <pre><code>class BaseLayoutModel(BaseModel):\n    model_config = PYDANTIC_CONFIG_STRICT\n    model_type: ClassVar[str] = StandardType.PLOT\n\n    hpad: float | None = Field(None, description=\"Horizontal padding.\")\n    vpad: float | None = Field(None, description=\"Vertical padding.\")\n    hspace: float | None = Field(None, description=\"Horizontal space.\")\n    vspace: float | None = Field(None, description=\"Vertical space.\")\n    background_color: str = Field(\"#FFFFFF\", description=\"Background color.\")\n\n    def merge_with(self, other: \"BaseLayoutModel\") -&gt; \"BaseLayoutModel\":\n        raise NotImplementedError\n\n    def model_dump_typed(self) -&gt; dict:\n        return {\"type\": type(self).__name__.lower(), **self.model_dump()}\n\n    @classmethod\n    def construct(self, model_type: str, dict_: dict) -&gt; \"BaseLayoutModel\":\n        from himena.standards.plotting.layout3d import SingleAxes3D\n\n        if model_type == \"singleaxes\":\n            return SingleAxes.model_validate(dict_)\n        if model_type == \"row\":\n            return Row.model_validate(dict_)\n        if model_type == \"column\":\n            return Column.model_validate(dict_)\n        if model_type == \"grid\":\n            return Grid.model_validate(dict_)\n        if model_type == \"singleaxes3d\":\n            return SingleAxes3D.model_validate(dict_)\n        raise ValueError(f\"Unknown layout model type: {model_type!r}\")\n\n    def show(self) -&gt; None:\n        \"\"\"Show the layout in the current himena window.\"\"\"\n        from himena.widgets import current_instance\n\n        ui = current_instance()\n        ui.add_object(self, type=self.__class__.model_type, title=\"Plot\")\n        return None\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.BaseLayoutModel.show","title":"<code>show()</code>","text":"<p>Show the layout in the current himena window.</p> Source code in <code>src\\himena\\standards\\plotting\\layout.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Show the layout in the current himena window.\"\"\"\n    from himena.widgets import current_instance\n\n    ui = current_instance()\n    ui.add_object(self, type=self.__class__.model_type, title=\"Plot\")\n    return None\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.BasePlotModel","title":"<code>BasePlotModel</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the plot.</p> <code>''</code> Source code in <code>src\\himena\\standards\\plotting\\components.py</code> <pre><code>class BasePlotModel(BaseModel):\n    model_config = PYDANTIC_CONFIG_STRICT\n    name: str = Field(default=\"\", description=\"Name of the plot.\")\n\n    @classmethod\n    def construct(cls, type: str, dict_: dict[str, Any]) -&gt; \"BasePlotModel\":\n        for subclass in iter_subclasses(BasePlotModel):\n            if subclass.__name__.lower() == type:\n                return subclass(**dict_)\n        raise ValueError(f\"Unknown plot type: {type!r}\")\n\n    @field_validator(\"name\", mode=\"before\")\n    def _validate_name(cls, name: str) -&gt; str:\n        if name is None:\n            return \"\"\n        return name\n\n    def model_dump_typed(self) -&gt; dict[str, Any]:\n        return {\"type\": type(self).__name__.lower(), **self.model_dump()}\n\n    def plot_option_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the GUI option dict for this plot for editing.\"\"\"\n        return {\"name\": {\"widget_type\": \"LineEdit\", \"value\": self.name}}\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.BasePlotModel.plot_option_dict","title":"<code>plot_option_dict()</code>","text":"<p>Return the GUI option dict for this plot for editing.</p> Source code in <code>src\\himena\\standards\\plotting\\components.py</code> <pre><code>def plot_option_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the GUI option dict for this plot for editing.\"\"\"\n    return {\"name\": {\"widget_type\": \"LineEdit\", \"value\": self.name}}\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.Column","title":"<code>Column</code>","text":"<p>Layout model for column.</p> <p>Parameters:</p> Name Type Description Default <code>hpad</code> <code>float | None</code> <p>Horizontal padding.</p> <code>None</code> <code>vpad</code> <code>float | None</code> <p>Vertical padding.</p> <code>None</code> <code>hspace</code> <code>float | None</code> <p>Horizontal space.</p> <code>None</code> <code>vspace</code> <code>float | None</code> <p>Vertical space.</p> <code>None</code> <code>background_color</code> <code>str</code> <p>Background color.</p> <code>'#FFFFFF'</code> <code>axes</code> <code>list[Axes]</code> <p>Child layouts.</p> <code>&lt;dynamic&gt;</code> <code>share_x</code> <code>bool</code> <p>Share x-axis or not.</p> <code>False</code> <code>share_y</code> <code>bool</code> <p>Share y-axis or not.</p> <code>False</code> Source code in <code>src\\himena\\standards\\plotting\\layout.py</code> <pre><code>class Column(Layout1D):\n    \"\"\"Layout model for column.\"\"\"\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.ErrorBar","title":"<code>ErrorBar</code>","text":"<p>Plot model for error bar plot.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the plot.</p> <code>''</code> <code>x</code> <code>Any</code> <p>X-axis values.</p> required <code>y</code> <code>Any</code> <p>Y-axis values.</p> required <code>x_error</code> <code>Any | None</code> <p>X-axis error values.</p> <code>None</code> <code>y_error</code> <code>Any | None</code> <p>Y-axis error values.</p> <code>None</code> <code>capsize</code> <code>float | None</code> <p>Cap size of the error bars.</p> <code>None</code> <code>edge</code> <code>Edge</code> <p>Properties of the error bars.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\standards\\plotting\\models.py</code> <pre><code>class ErrorBar(PlotModelXY):\n    \"\"\"Plot model for error bar plot.\"\"\"\n\n    x_error: Any | None = Field(None, description=\"X-axis error values.\")\n    y_error: Any | None = Field(None, description=\"Y-axis error values.\")\n    capsize: float | None = Field(None, description=\"Cap size of the error bars.\")\n    edge: Edge = Field(\n        default_factory=Edge, description=\"Properties of the error bars.\"\n    )\n\n    def plot_option_dict(self) -&gt; dict[str, Any]:\n        from himena.qt.magicgui import EdgePropertyEdit\n\n        return {\n            \"name\": {\"widget_type\": \"LineEdit\", \"value\": self.name},\n            \"capsize\": {\"annotation\": float, \"value\": self.capsize},\n            \"edge\": {\"widget_type\": EdgePropertyEdit, \"value\": self.edge.model_dump()},\n        }\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.Grid","title":"<code>Grid</code>","text":"<p>Layout model for grid.</p> <p>Parameters:</p> Name Type Description Default <code>hpad</code> <code>float | None</code> <p>Horizontal padding.</p> <code>None</code> <code>vpad</code> <code>float | None</code> <p>Vertical padding.</p> <code>None</code> <code>hspace</code> <code>float | None</code> <p>Horizontal space.</p> <code>None</code> <code>vspace</code> <code>float | None</code> <p>Vertical space.</p> <code>None</code> <code>background_color</code> <code>str</code> <p>Background color.</p> <code>'#FFFFFF'</code> <code>axes</code> <code>list[list[Axes]]</code> <p>Child layouts.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\standards\\plotting\\layout.py</code> <pre><code>class Grid(BaseLayoutModel):\n    \"\"\"Layout model for grid.\"\"\"\n\n    axes: list[list[Axes]] = Field(default_factory=list, description=\"Child layouts.\")\n\n    def __getitem__(self, key) -&gt; Axes:\n        return self.axes[key[0]][key[1]]\n\n    @classmethod\n    def fill(cls, rows: int, cols: int) -&gt; \"Self\":\n        layout = cls()\n        for _ in range(rows):\n            layout.axes.append([Axes() for _ in range(cols)])\n        return layout\n\n    def merge_with(self, other: \"Self\") -&gt; \"Self\":\n        if not isinstance(other, type(self)):\n            raise ValueError(f\"Cannot merge {type(self)} with {type(other)}\")\n        new_axes = [\n            [\n                a.model_copy(update={\"models\": a.models + b.models})\n                for a, b in zip(row_a, row_b)\n            ]\n            for row_a, row_b in zip(self.axes, other.axes)\n        ]\n        return type(self)(axes=new_axes)\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.Histogram","title":"<code>Histogram</code>","text":"<p>Plot model for a histogram.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the plot.</p> <code>''</code> <code>height</code> <code>Any</code> <p>Count or frequency values.</p> required <code>bins</code> <code>Any</code> <p>Bin edges.</p> required <code>orient</code> <code>Literal['vertical', 'horizontal']</code> <p>Orientation of the histogram.</p> <code>'vertical'</code> <code>face</code> <code>Face</code> <p>Properties of the histogram face.</p> <code>&lt;dynamic&gt;</code> <code>edge</code> <code>Edge</code> <p>Properties of the histogram edge.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\standards\\plotting\\models.py</code> <pre><code>class Histogram(BasePlotModel):\n    \"\"\"Plot model for a histogram.\"\"\"\n\n    height: Any = Field(..., description=\"Count or frequency values.\")\n    bins: Any = Field(..., description=\"Bin edges.\")\n    orient: Literal[\"vertical\", \"horizontal\"] = Field(\n        \"vertical\", description=\"Orientation of the histogram.\"\n    )\n    face: Face = Field(\n        default_factory=Face, description=\"Properties of the histogram face.\"\n    )\n    edge: Edge = Field(\n        default_factory=Edge, description=\"Properties of the histogram edge.\"\n    )\n\n    def plot_option_dict(self) -&gt; dict[str, Any]:\n        from himena.qt.magicgui import EdgePropertyEdit, FacePropertyEdit\n\n        return {\n            \"name\": {\"widget_type\": \"LineEdit\", \"value\": self.name},\n            \"orient\": {\"choices\": [\"vertical\", \"horizontal\"], \"value\": self.orient},\n            \"face\": {\"widget_type\": FacePropertyEdit, \"value\": self.face.model_dump()},\n            \"edge\": {\"widget_type\": EdgePropertyEdit, \"value\": self.edge.model_dump()},\n        }\n\n    def to_band(self) -&gt; Band:\n        \"\"\"Convert the histogram to a band plot.\"\"\"\n        x = np.repeat(self.bins, 3)[1:-1]\n        y = np.zeros_like(x)\n        y[1::3] = self.height\n        y[2::3] = self.height\n        return Band(\n            x=x,\n            y0=y,\n            y1=np.zeros_like(y),\n            orient=self.orient,\n            face=self.face,\n            edge=self.edge,\n        )\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.Histogram.to_band","title":"<code>to_band()</code>","text":"<p>Convert the histogram to a band plot.</p> Source code in <code>src\\himena\\standards\\plotting\\models.py</code> <pre><code>def to_band(self) -&gt; Band:\n    \"\"\"Convert the histogram to a band plot.\"\"\"\n    x = np.repeat(self.bins, 3)[1:-1]\n    y = np.zeros_like(x)\n    y[1::3] = self.height\n    y[2::3] = self.height\n    return Band(\n        x=x,\n        y0=y,\n        y1=np.zeros_like(y),\n        orient=self.orient,\n        face=self.face,\n        edge=self.edge,\n    )\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.Line","title":"<code>Line</code>","text":"<p>Plot model for line plot.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the plot.</p> <code>''</code> <code>x</code> <code>Any</code> <p>X-axis values.</p> required <code>y</code> <code>Any</code> <p>Y-axis values.</p> required <code>edge</code> <code>Edge</code> <p>Properties of the line.</p> <code>&lt;dynamic&gt;</code> <code>marker</code> <code>Scatter | None</code> <p>Marker of the line.</p> <code>None</code> Source code in <code>src\\himena\\standards\\plotting\\models.py</code> <pre><code>class Line(PlotModelXY):\n    \"\"\"Plot model for line plot.\"\"\"\n\n    edge: Edge = Field(default_factory=Edge, description=\"Properties of the line.\")\n    marker: Scatter | None = Field(None, description=\"Marker of the line.\")\n\n    def plot_option_dict(self) -&gt; dict[str, Any]:\n        from himena.qt.magicgui import EdgePropertyEdit\n\n        return {\n            \"name\": {\"widget_type\": \"LineEdit\", \"value\": self.name},\n            \"edge\": {\"widget_type\": EdgePropertyEdit, \"value\": self.edge.model_dump()},\n        }\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.Line3D","title":"<code>Line3D</code>","text":"<p>Plot model for a 3D line plot.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the plot.</p> <code>''</code> <code>x</code> <code>Any</code> <p>X-axis values.</p> required <code>y</code> <code>Any</code> <p>Y-axis values.</p> required <code>edge</code> <code>Edge</code> <p>Properties of the line.</p> <code>&lt;dynamic&gt;</code> <code>marker</code> <code>Scatter | None</code> <p>Marker of the line.</p> <code>None</code> <code>z</code> <code>Any</code> <p>Z-axis values.</p> required Source code in <code>src\\himena\\standards\\plotting\\models3d.py</code> <pre><code>class Line3D(_m.Line):\n    \"\"\"Plot model for a 3D line plot.\"\"\"\n\n    z: Any = Field(..., description=\"Z-axis values.\")\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.Mesh3D","title":"<code>Mesh3D</code>","text":"<p>Plot model for a 3D mesh plot.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the plot.</p> <code>''</code> <code>vertices</code> <code>Any</code> <p>Vertices of the mesh.</p> required <code>face_indices</code> <code>Any</code> <p>Face indices of the mesh.</p> required <code>face</code> <code>Face</code> <p>Properties of the faces.</p> <code>&lt;dynamic&gt;</code> <code>edge</code> <code>Edge</code> <p>Properties of the edges.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\standards\\plotting\\models3d.py</code> <pre><code>class Mesh3D(BasePlotModel):\n    \"\"\"Plot model for a 3D mesh plot.\"\"\"\n\n    vertices: Any = Field(..., description=\"Vertices of the mesh.\")\n    face_indices: Any = Field(..., description=\"Face indices of the mesh.\")\n    face: Face = Field(default_factory=Face, description=\"Properties of the faces.\")\n    edge: Edge = Field(default_factory=Edge, description=\"Properties of the edges.\")\n\n    def plot_option_dict(self) -&gt; dict[str, Any]:\n        from himena.qt.magicgui import EdgePropertyEdit, FacePropertyEdit\n\n        return {\n            \"name\": {\"widget_type\": \"LineEdit\", \"value\": self.name},\n            \"face\": {\"widget_type\": FacePropertyEdit, \"value\": self.face.model_dump()},\n            \"edge\": {\"widget_type\": EdgePropertyEdit, \"value\": self.edge.model_dump()},\n        }\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.Row","title":"<code>Row</code>","text":"<p>Layout model for row.</p> <p>Parameters:</p> Name Type Description Default <code>hpad</code> <code>float | None</code> <p>Horizontal padding.</p> <code>None</code> <code>vpad</code> <code>float | None</code> <p>Vertical padding.</p> <code>None</code> <code>hspace</code> <code>float | None</code> <p>Horizontal space.</p> <code>None</code> <code>vspace</code> <code>float | None</code> <p>Vertical space.</p> <code>None</code> <code>background_color</code> <code>str</code> <p>Background color.</p> <code>'#FFFFFF'</code> <code>axes</code> <code>list[Axes]</code> <p>Child layouts.</p> <code>&lt;dynamic&gt;</code> <code>share_x</code> <code>bool</code> <p>Share x-axis or not.</p> <code>False</code> <code>share_y</code> <code>bool</code> <p>Share y-axis or not.</p> <code>False</code> Source code in <code>src\\himena\\standards\\plotting\\layout.py</code> <pre><code>class Row(Layout1D):\n    \"\"\"Layout model for row.\"\"\"\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.Scatter","title":"<code>Scatter</code>","text":"<p>Plot model for scatter plot.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the plot.</p> <code>''</code> <code>x</code> <code>Any</code> <p>X-axis values.</p> required <code>y</code> <code>Any</code> <p>Y-axis values.</p> required <code>symbol</code> <code>Any | None</code> <p>Symbol of the markers.</p> <code>None</code> <code>size</code> <code>Any | None</code> <p>Size of the markers.</p> <code>None</code> <code>face</code> <code>Face</code> <p>Properties of the marker faces.</p> <code>&lt;dynamic&gt;</code> <code>edge</code> <code>Edge</code> <p>Properties of the marker edges.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\standards\\plotting\\models.py</code> <pre><code>class Scatter(PlotModelXY):\n    \"\"\"Plot model for scatter plot.\"\"\"\n\n    symbol: Any | None = Field(None, description=\"Symbol of the markers.\")\n    size: Any | None = Field(None, description=\"Size of the markers.\")\n    face: Face = Field(\n        default_factory=Face, description=\"Properties of the marker faces.\"\n    )\n    edge: Edge = Field(\n        default_factory=Edge, description=\"Properties of the marker edges.\"\n    )\n\n    def plot_option_dict(self) -&gt; dict[str, Any]:\n        from himena.qt.magicgui import EdgePropertyEdit, FacePropertyEdit\n\n        return {\n            \"name\": {\"widget_type\": \"LineEdit\", \"value\": self.name},\n            \"symbol\": {\"widget_type\": \"LineEdit\", \"value\": self.symbol},\n            \"size\": {\"annotation\": float, \"value\": self.size},\n            \"face\": {\"widget_type\": FacePropertyEdit, \"value\": self.face.model_dump()},\n            \"edge\": {\"widget_type\": EdgePropertyEdit, \"value\": self.edge.model_dump()},\n        }\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.Scatter3D","title":"<code>Scatter3D</code>","text":"<p>Plot model for a 3D scatter plot.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the plot.</p> <code>''</code> <code>x</code> <code>Any</code> <p>X-axis values.</p> required <code>y</code> <code>Any</code> <p>Y-axis values.</p> required <code>symbol</code> <code>Any | None</code> <p>Symbol of the markers.</p> <code>None</code> <code>size</code> <code>Any | None</code> <p>Size of the markers.</p> <code>None</code> <code>face</code> <code>Face</code> <p>Properties of the marker faces.</p> <code>&lt;dynamic&gt;</code> <code>edge</code> <code>Edge</code> <p>Properties of the marker edges.</p> <code>&lt;dynamic&gt;</code> <code>z</code> <code>Any</code> <p>Z-axis values.</p> required Source code in <code>src\\himena\\standards\\plotting\\models3d.py</code> <pre><code>class Scatter3D(_m.Scatter):\n    \"\"\"Plot model for a 3D scatter plot.\"\"\"\n\n    z: Any = Field(..., description=\"Z-axis values.\")\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.SingleAxes","title":"<code>SingleAxes</code>","text":"<p>Parameters:</p> Name Type Description Default <code>hpad</code> <code>float | None</code> <p>Horizontal padding.</p> <code>None</code> <code>vpad</code> <code>float | None</code> <p>Vertical padding.</p> <code>None</code> <code>hspace</code> <code>float | None</code> <p>Horizontal space.</p> <code>None</code> <code>vspace</code> <code>float | None</code> <p>Vertical space.</p> <code>None</code> <code>background_color</code> <code>str</code> <p>Background color.</p> <code>'#FFFFFF'</code> <code>axes</code> <code>Axes</code> <p>Child axes.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\standards\\plotting\\layout.py</code> <pre><code>class SingleAxes(BaseLayoutModel):\n    axes: Axes = Field(default_factory=Axes, description=\"Child axes.\")\n\n    @property\n    def x(self) -&gt; Axis:\n        \"\"\"X-axis settings.\"\"\"\n        return self.axes.x\n\n    @property\n    def y(self) -&gt; Axis:\n        \"\"\"Y-axis settings.\"\"\"\n        return self.axes.y\n\n    @property\n    def axis_color(self) -&gt; str:\n        \"\"\"Axis color.\"\"\"\n        return self.axes.axis_color\n\n    @axis_color.setter\n    def axis_color(self, value):\n        self.axes.axis_color = value\n\n    @property\n    def title(self) -&gt; str:\n        \"\"\"Title of the central axes.\"\"\"\n        return self.axes.title\n\n    @title.setter\n    def title(self, value):\n        self.axes.title = value\n\n    def merge_with(self, other: \"SingleAxes\") -&gt; \"SingleAxes\":\n        \"\"\"Merge with another SingleAxes layout.\"\"\"\n        new_axes = self.axes.model_copy(\n            update={\"models\": self.axes.models + other.axes.models}\n        )\n        return SingleAxes(axes=new_axes)\n\n    ### Because there's only one axes, we can directly call the axes methods.\n    def scatter(\n        self,\n        x: Sequence[float],\n        y: Sequence[float] | None = None,\n        *,\n        symbol: str = \"o\",\n        size: float | None = None,\n        **kwargs,\n    ) -&gt; _m.Scatter:\n        \"\"\"Add a scatter plot model to the axes.\"\"\"\n        return self.axes.scatter(x=x, y=y, symbol=symbol, size=size, **kwargs)\n\n    def plot(\n        self,\n        x: Sequence[float],\n        y: Sequence[float] | None = None,\n        **kwargs,\n    ) -&gt; _m.Line:\n        \"\"\"Add a line plot model to the axes.\"\"\"\n        return self.axes.plot(x=x, y=y, **kwargs)\n\n    def bar(\n        self,\n        x: Sequence[float],\n        y: Sequence[float] | None = None,\n        *,\n        bottom: \"float | Sequence[float] | NDArray[np.number] | None\" = None,\n        bar_width: float | None = None,\n        orient: Literal[\"vertical\", \"horizontal\"] = \"vertical\",\n        **kwargs,\n    ) -&gt; _m.Bar:\n        \"\"\"Add a bar plot model to the axes.\"\"\"\n        return self.axes.bar(\n            x=x, y=y, bottom=bottom, bar_width=bar_width, orient=orient, **kwargs\n        )\n\n    def errorbar(\n        self,\n        x: Sequence[float],\n        y: Sequence[float] | None = None,\n        *,\n        x_error: \"float | Sequence[float] | NDArray[np.number] | None\" = None,\n        y_error: \"float | Sequence[float] | NDArray[np.number] | None\" = None,\n        capsize: float | None = None,\n        **kwargs,\n    ) -&gt; _m.ErrorBar:\n        \"\"\"Add an error bar plot model to the axes.\"\"\"\n        return self.axes.errorbar(\n            x=x, y=y, x_error=x_error, y_error=y_error, capsize=capsize, **kwargs\n        )\n\n    def band(\n        self,\n        x: Sequence[float],\n        y0: Sequence[float],\n        y1: Sequence[float] | None = None,\n        *,\n        orient: Literal[\"vertical\", \"horizontal\"] = \"vertical\",\n        **kwargs,\n    ) -&gt; _m.Band:\n        \"\"\"Add a band plot model to the axes.\"\"\"\n        return self.axes.band(x=x, y0=y0, y1=y1, orient=orient, **kwargs)\n\n    def hist(\n        self,\n        data: \"Sequence[float] | NDArray[np.number]\",\n        *,\n        bins: int = 10,\n        range: tuple[float, float] | None = None,\n        orient: Literal[\"vertical\", \"horizontal\"] = \"vertical\",\n        stat: Literal[\"count\", \"density\", \"probability\"] = \"count\",\n        **kwargs,\n    ) -&gt; _m.Histogram:\n        \"\"\"Add a histogram plot model to the axes.\"\"\"\n        return self.axes.hist(\n            data=data, bins=bins, range=range, orient=orient, stat=stat, **kwargs\n        )\n\n    def text(\n        self,\n        x: Sequence[float],\n        y: Sequence[float],\n        text: Sequence[str],\n        *,\n        size: int = 12,\n        color: str = \"black\",\n        family: str = \"Arial\",\n        rotation: float = 0,\n        anchor: _m.ANCHOR_STRINGS = \"center\",\n    ) -&gt; _m.Texts:\n        \"\"\"Add a text plot model to the axes.\"\"\"\n        return self.axes.text(\n            x=x, y=y, text=text, size=size, color=color, family=family, anchor=anchor,\n            rotation=rotation,\n        )  # fmt: skip\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.SingleAxes.axis_color","title":"<code>axis_color</code>  <code>property</code> <code>writable</code>","text":"<p>Axis color.</p>"},{"location":"api/standards/plotting/#himena.standards.plotting.SingleAxes.title","title":"<code>title</code>  <code>property</code> <code>writable</code>","text":"<p>Title of the central axes.</p>"},{"location":"api/standards/plotting/#himena.standards.plotting.SingleAxes.x","title":"<code>x</code>  <code>property</code>","text":"<p>X-axis settings.</p>"},{"location":"api/standards/plotting/#himena.standards.plotting.SingleAxes.y","title":"<code>y</code>  <code>property</code>","text":"<p>Y-axis settings.</p>"},{"location":"api/standards/plotting/#himena.standards.plotting.SingleAxes.band","title":"<code>band(x, y0, y1=None, *, orient='vertical', **kwargs)</code>","text":"<p>Add a band plot model to the axes.</p> Source code in <code>src\\himena\\standards\\plotting\\layout.py</code> <pre><code>def band(\n    self,\n    x: Sequence[float],\n    y0: Sequence[float],\n    y1: Sequence[float] | None = None,\n    *,\n    orient: Literal[\"vertical\", \"horizontal\"] = \"vertical\",\n    **kwargs,\n) -&gt; _m.Band:\n    \"\"\"Add a band plot model to the axes.\"\"\"\n    return self.axes.band(x=x, y0=y0, y1=y1, orient=orient, **kwargs)\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.SingleAxes.bar","title":"<code>bar(x, y=None, *, bottom=None, bar_width=None, orient='vertical', **kwargs)</code>","text":"<p>Add a bar plot model to the axes.</p> Source code in <code>src\\himena\\standards\\plotting\\layout.py</code> <pre><code>def bar(\n    self,\n    x: Sequence[float],\n    y: Sequence[float] | None = None,\n    *,\n    bottom: \"float | Sequence[float] | NDArray[np.number] | None\" = None,\n    bar_width: float | None = None,\n    orient: Literal[\"vertical\", \"horizontal\"] = \"vertical\",\n    **kwargs,\n) -&gt; _m.Bar:\n    \"\"\"Add a bar plot model to the axes.\"\"\"\n    return self.axes.bar(\n        x=x, y=y, bottom=bottom, bar_width=bar_width, orient=orient, **kwargs\n    )\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.SingleAxes.errorbar","title":"<code>errorbar(x, y=None, *, x_error=None, y_error=None, capsize=None, **kwargs)</code>","text":"<p>Add an error bar plot model to the axes.</p> Source code in <code>src\\himena\\standards\\plotting\\layout.py</code> <pre><code>def errorbar(\n    self,\n    x: Sequence[float],\n    y: Sequence[float] | None = None,\n    *,\n    x_error: \"float | Sequence[float] | NDArray[np.number] | None\" = None,\n    y_error: \"float | Sequence[float] | NDArray[np.number] | None\" = None,\n    capsize: float | None = None,\n    **kwargs,\n) -&gt; _m.ErrorBar:\n    \"\"\"Add an error bar plot model to the axes.\"\"\"\n    return self.axes.errorbar(\n        x=x, y=y, x_error=x_error, y_error=y_error, capsize=capsize, **kwargs\n    )\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.SingleAxes.hist","title":"<code>hist(data, *, bins=10, range=None, orient='vertical', stat='count', **kwargs)</code>","text":"<p>Add a histogram plot model to the axes.</p> Source code in <code>src\\himena\\standards\\plotting\\layout.py</code> <pre><code>def hist(\n    self,\n    data: \"Sequence[float] | NDArray[np.number]\",\n    *,\n    bins: int = 10,\n    range: tuple[float, float] | None = None,\n    orient: Literal[\"vertical\", \"horizontal\"] = \"vertical\",\n    stat: Literal[\"count\", \"density\", \"probability\"] = \"count\",\n    **kwargs,\n) -&gt; _m.Histogram:\n    \"\"\"Add a histogram plot model to the axes.\"\"\"\n    return self.axes.hist(\n        data=data, bins=bins, range=range, orient=orient, stat=stat, **kwargs\n    )\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.SingleAxes.merge_with","title":"<code>merge_with(other)</code>","text":"<p>Merge with another SingleAxes layout.</p> Source code in <code>src\\himena\\standards\\plotting\\layout.py</code> <pre><code>def merge_with(self, other: \"SingleAxes\") -&gt; \"SingleAxes\":\n    \"\"\"Merge with another SingleAxes layout.\"\"\"\n    new_axes = self.axes.model_copy(\n        update={\"models\": self.axes.models + other.axes.models}\n    )\n    return SingleAxes(axes=new_axes)\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.SingleAxes.plot","title":"<code>plot(x, y=None, **kwargs)</code>","text":"<p>Add a line plot model to the axes.</p> Source code in <code>src\\himena\\standards\\plotting\\layout.py</code> <pre><code>def plot(\n    self,\n    x: Sequence[float],\n    y: Sequence[float] | None = None,\n    **kwargs,\n) -&gt; _m.Line:\n    \"\"\"Add a line plot model to the axes.\"\"\"\n    return self.axes.plot(x=x, y=y, **kwargs)\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.SingleAxes.scatter","title":"<code>scatter(x, y=None, *, symbol='o', size=None, **kwargs)</code>","text":"<p>Add a scatter plot model to the axes.</p> Source code in <code>src\\himena\\standards\\plotting\\layout.py</code> <pre><code>def scatter(\n    self,\n    x: Sequence[float],\n    y: Sequence[float] | None = None,\n    *,\n    symbol: str = \"o\",\n    size: float | None = None,\n    **kwargs,\n) -&gt; _m.Scatter:\n    \"\"\"Add a scatter plot model to the axes.\"\"\"\n    return self.axes.scatter(x=x, y=y, symbol=symbol, size=size, **kwargs)\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.SingleAxes.text","title":"<code>text(x, y, text, *, size=12, color='black', family='Arial', rotation=0, anchor='center')</code>","text":"<p>Add a text plot model to the axes.</p> Source code in <code>src\\himena\\standards\\plotting\\layout.py</code> <pre><code>def text(\n    self,\n    x: Sequence[float],\n    y: Sequence[float],\n    text: Sequence[str],\n    *,\n    size: int = 12,\n    color: str = \"black\",\n    family: str = \"Arial\",\n    rotation: float = 0,\n    anchor: _m.ANCHOR_STRINGS = \"center\",\n) -&gt; _m.Texts:\n    \"\"\"Add a text plot model to the axes.\"\"\"\n    return self.axes.text(\n        x=x, y=y, text=text, size=size, color=color, family=family, anchor=anchor,\n        rotation=rotation,\n    )  # fmt: skip\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.SingleAxes3D","title":"<code>SingleAxes3D</code>","text":"<p>Parameters:</p> Name Type Description Default <code>hpad</code> <code>float | None</code> <p>Horizontal padding.</p> <code>None</code> <code>vpad</code> <code>float | None</code> <p>Vertical padding.</p> <code>None</code> <code>hspace</code> <code>float | None</code> <p>Horizontal space.</p> <code>None</code> <code>vspace</code> <code>float | None</code> <p>Vertical space.</p> <code>None</code> <code>background_color</code> <code>str</code> <p>Background color.</p> <code>'#FFFFFF'</code> <code>axes</code> <code>Axes3D</code> <p>Child 3D axes.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\standards\\plotting\\layout3d.py</code> <pre><code>class SingleAxes3D(BaseLayoutModel):\n    axes: Axes3D = Field(default_factory=Axes3D, description=\"Child 3D axes.\")\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.SingleStackedAxes","title":"<code>SingleStackedAxes</code>","text":"<p>Parameters:</p> Name Type Description Default <code>hpad</code> <code>float | None</code> <p>Horizontal padding.</p> <code>None</code> <code>vpad</code> <code>float | None</code> <p>Vertical padding.</p> <code>None</code> <code>hspace</code> <code>float | None</code> <p>Horizontal space.</p> <code>None</code> <code>vspace</code> <code>float | None</code> <p>Vertical space.</p> <code>None</code> <code>background_color</code> <code>str</code> <p>Background color.</p> <code>'#FFFFFF'</code> <code>axes</code> <code>StackedAxes</code> <p>Child axes.</p> required Source code in <code>src\\himena\\standards\\plotting\\layout.py</code> <pre><code>class SingleStackedAxes(BaseLayoutModel):\n    model_type: ClassVar[str] = StandardType.PLOT_STACK\n\n    axes: StackedAxes = Field(..., description=\"Child axes.\")\n    background_color: str = Field(\"#FFFFFF\", description=\"Background color.\")\n\n    @property\n    def x(self) -&gt; Axis:\n        \"\"\"X-axis settings.\"\"\"\n        return self.axes.x\n\n    @property\n    def y(self) -&gt; Axis:\n        \"\"\"Y-axis settings.\"\"\"\n        return self.axes.y\n\n    @property\n    def axis_color(self) -&gt; str:\n        \"\"\"Axis color.\"\"\"\n        return self.axes.axis_color\n\n    @axis_color.setter\n    def axis_color(self, value):\n        self.axes.axis_color = value\n\n    @property\n    def title(self) -&gt; str:\n        \"\"\"Title of the central axes.\"\"\"\n        return self.axes.title\n\n    @title.setter\n    def title(self, value):\n        self.axes.title = value\n\n    @classmethod\n    def fill(cls, *shape: int, multi_dims=None):\n        models = {}\n        for index in np.ndindex(*shape):\n            models[index] = []\n        return SingleStackedAxes(\n            axes=StackedAxes(shape=shape, models=models, multi_dims=multi_dims)\n        )\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        \"\"\"Shape of the stack dimensions.\"\"\"\n        return self.axes.shape\n\n    def __getitem__(self, key) -&gt; ModelsRef:\n        return self.axes[key]\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.SingleStackedAxes.axis_color","title":"<code>axis_color</code>  <code>property</code> <code>writable</code>","text":"<p>Axis color.</p>"},{"location":"api/standards/plotting/#himena.standards.plotting.SingleStackedAxes.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Shape of the stack dimensions.</p>"},{"location":"api/standards/plotting/#himena.standards.plotting.SingleStackedAxes.title","title":"<code>title</code>  <code>property</code> <code>writable</code>","text":"<p>Title of the central axes.</p>"},{"location":"api/standards/plotting/#himena.standards.plotting.SingleStackedAxes.x","title":"<code>x</code>  <code>property</code>","text":"<p>X-axis settings.</p>"},{"location":"api/standards/plotting/#himena.standards.plotting.SingleStackedAxes.y","title":"<code>y</code>  <code>property</code>","text":"<p>Y-axis settings.</p>"},{"location":"api/standards/plotting/#himena.standards.plotting.Span","title":"<code>Span</code>","text":"<p>Plot model for span plot.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the plot.</p> <code>''</code> <code>start</code> <code>float</code> <p>Starting value of the lower bound.</p> required <code>end</code> <code>float</code> <p>Ending value of the upper bound.</p> required <code>orient</code> <code>Literal['vertical', 'horizontal']</code> <p>Orientation of the span. 'vertical' means the spanis vertically unlimited.</p> <code>'vertical'</code> <code>face</code> <code>Face</code> <p>Properties of the span fill.</p> <code>&lt;dynamic&gt;</code> <code>edge</code> <code>Edge</code> <p>Properties of the span edge.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\standards\\plotting\\models.py</code> <pre><code>class Span(BasePlotModel):\n    \"\"\"Plot model for span plot.\"\"\"\n\n    start: float = Field(..., description=\"Starting value of the lower bound.\")\n    end: float = Field(..., description=\"Ending value of the upper bound.\")\n    orient: Literal[\"vertical\", \"horizontal\"] = Field(\n        \"vertical\",\n        description=\"Orientation of the span. 'vertical' means the span\"\n        \"is vertically unlimited.\",\n    )\n    face: Face = Field(default_factory=Face, description=\"Properties of the span fill.\")\n    edge: Edge = Field(default_factory=Edge, description=\"Properties of the span edge.\")\n\n    def plot_option_dict(self) -&gt; dict[str, Any]:\n        from himena.qt.magicgui import EdgePropertyEdit, FacePropertyEdit\n\n        return {\n            \"name\": {\"widget_type\": \"LineEdit\", \"value\": self.name},\n            \"x0\": {\"annotation\": float, \"value\": self.start},\n            \"x1\": {\"annotation\": float, \"value\": self.end},\n            \"orient\": {\"choices\": [\"vertical\", \"horizontal\"], \"value\": self.orient},\n            \"face\": {\"widget_type\": FacePropertyEdit, \"value\": self.face.model_dump()},\n            \"edge\": {\"widget_type\": EdgePropertyEdit, \"value\": self.edge.model_dump()},\n        }\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.StyledText","title":"<code>StyledText</code>","text":"<p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text content.</p> required <code>size</code> <code>float | None</code> <p>Font size.</p> <code>None</code> <code>color</code> <code>Any | None</code> <p>Font color.</p> <code>None</code> <code>family</code> <code>str | None</code> <p>Font family.</p> <code>None</code> <code>bold</code> <code>bool</code> <p>Bold style or not.</p> <code>False</code> <code>italic</code> <code>bool</code> <p>Italic style or not.</p> <code>False</code> <code>underline</code> <code>bool</code> <p>Underline style or not.</p> <code>False</code> <code>alignment</code> <code>str | None</code> <p>Text alignment.</p> <code>None</code> Source code in <code>src\\himena\\standards\\plotting\\components.py</code> <pre><code>class StyledText(BaseModel):\n    model_config = PYDANTIC_CONFIG_STRICT\n\n    text: str = Field(..., description=\"Text content.\")\n    size: float | None = Field(None, description=\"Font size.\")\n    color: Any | None = Field(None, description=\"Font color.\")\n    family: str | None = Field(None, description=\"Font family.\")\n    bold: bool = Field(False, description=\"Bold style or not.\")\n    italic: bool = Field(False, description=\"Italic style or not.\")\n    underline: bool = Field(False, description=\"Underline style or not.\")\n    alignment: str | None = Field(None, description=\"Text alignment.\")\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.Surface3D","title":"<code>Surface3D</code>","text":"<p>Plot model for a 3D surface plot.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the plot.</p> <code>''</code> <code>x</code> <code>Any</code> <p>X-axis values.</p> required <code>y</code> <code>Any</code> <p>Y-axis values.</p> required <code>z</code> <code>Any</code> <p>Z-axis values.</p> required <code>face</code> <code>Face</code> <p>Properties of the faces.</p> <code>&lt;dynamic&gt;</code> <code>edge</code> <code>Edge</code> <p>Properties of the edges.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\standards\\plotting\\models3d.py</code> <pre><code>class Surface3D(BasePlotModel):\n    \"\"\"Plot model for a 3D surface plot.\"\"\"\n\n    x: Any = Field(..., description=\"X-axis values.\")\n    y: Any = Field(..., description=\"Y-axis values.\")\n    z: Any = Field(..., description=\"Z-axis values.\")\n    face: Face = Field(default_factory=Face, description=\"Properties of the faces.\")\n    edge: Edge = Field(default_factory=Edge, description=\"Properties of the edges.\")\n\n    def plot_option_dict(self) -&gt; dict[str, Any]:\n        from himena.qt.magicgui import EdgePropertyEdit, FacePropertyEdit\n\n        return {\n            \"name\": {\"widget_type\": \"LineEdit\", \"value\": self.name},\n            \"face\": {\"widget_type\": FacePropertyEdit, \"value\": self.face.model_dump()},\n            \"edge\": {\"widget_type\": EdgePropertyEdit, \"value\": self.edge.model_dump()},\n        }\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.Texts","title":"<code>Texts</code>","text":"<p>Plot model for texts.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the plot.</p> <code>''</code> <code>x</code> <code>Any</code> <p>X-axis values.</p> required <code>y</code> <code>Any</code> <p>Y-axis values.</p> required <code>texts</code> <code>Any</code> <p>Texts to be displayed.</p> required <code>size</code> <code>int</code> <p>Font size of the texts.</p> <code>12</code> <code>color</code> <code>str</code> <p>Font color of the texts.</p> <code>'black'</code> <code>family</code> <code>str</code> <p>Font family of the texts.</p> <code>'Arial'</code> <code>anchor</code> <code>Literal['center', 'left', 'right', 'top', 'bottom', 'top_left', 'top_right', 'bottom_left', 'bottom_right']</code> <p>Anchor position of the texts. 'center' means the center of the text.</p> <code>'center'</code> <code>rotation</code> <code>float</code> <p>Rotation angle of the texts.</p> <code>0</code> Source code in <code>src\\himena\\standards\\plotting\\models.py</code> <pre><code>class Texts(PlotModelXY):\n    \"\"\"Plot model for texts.\"\"\"\n\n    texts: Any = Field(..., description=\"Texts to be displayed.\")\n    size: int = Field(12, description=\"Font size of the texts.\")\n    color: str = Field(\"black\", description=\"Font color of the texts.\")\n    family: str = Field(\"Arial\", description=\"Font family of the texts.\")\n    anchor: ANCHOR_STRINGS = Field(\n        \"center\",\n        description=\"Anchor position of the texts. 'center' means the center of the text.\",\n    )\n    rotation: float = Field(0, description=\"Rotation angle of the texts.\")\n\n    def plot_option_dict(self) -&gt; dict[str, Any]:\n        return {\n            \"name\": {\"widget_type\": \"LineEdit\", \"value\": self.name},\n            \"font_size\": {\"annotation\": int, \"value\": self.size},\n            \"font_color\": {\"annotation\": str, \"value\": self.color},\n            \"font_family\": {\"annotation\": str, \"value\": self.family},\n        }\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.column","title":"<code>column(num=1, *, background_color='white')</code>","text":"<p>Make a column layout model.</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>int</code> <p>Number of columns, by default 1</p> <code>1</code> <p>Examples:</p> <pre><code>from himena.standards import plotting as hplt\ncol = hplt.column(3)\ncol[0].plot([0, 1, 2], [4, 2, 3], color=\"blue\")\ncol.show()  # show as a sub-window in the current widget\n</code></pre> Source code in <code>src\\himena\\standards\\plotting\\_api.py</code> <pre><code>def column(num: int = 1, *, background_color: Any = \"white\") -&gt; layout.Column:\n    \"\"\"Make a column layout model.\n\n    Parameters\n    ----------\n    num : int, optional\n        Number of columns, by default 1\n\n    Examples\n    --------\n    ``` python\n    from himena.standards import plotting as hplt\n    col = hplt.column(3)\n    col[0].plot([0, 1, 2], [4, 2, 3], color=\"blue\")\n    col.show()  # show as a sub-window in the current widget\n    ```\n    \"\"\"\n    lo = layout.Column.fill(num)\n    lo.background_color = \"white\"\n    return lo\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.figure","title":"<code>figure(background_color='white')</code>","text":"<p>Make a single axes layout model.</p> <p>Examples:</p> <pre><code>from himena.standards import plotting as hplt\nfig = hplt.figure()\nfig.plot([0, 1, 2], [4, 2, 3], color=\"red\")\nfig.show()  # show as a sub-window in the current widget\n</code></pre> Source code in <code>src\\himena\\standards\\plotting\\_api.py</code> <pre><code>def figure(background_color: Any = \"white\") -&gt; layout.SingleAxes:\n    \"\"\"Make a single axes layout model.\n\n    Examples\n    --------\n    ``` python\n    from himena.standards import plotting as hplt\n    fig = hplt.figure()\n    fig.plot([0, 1, 2], [4, 2, 3], color=\"red\")\n    fig.show()  # show as a sub-window in the current widget\n    ```\n    \"\"\"\n    lo = layout.SingleAxes(background_color=background_color)\n    return lo\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.figure_3d","title":"<code>figure_3d(background_color='white')</code>","text":"<p>Make a single 3D axes layout model.</p> <p>Examples:</p> <pre><code>from himena.standards import plotting as hplt\nfig = hplt.figure_3d()\nfig.plot([0, 1, 2], [4, 2, 3], [6, 8, 7], color=\"red\")\nfig.show()  # show as a sub-window in the current widget\n</code></pre> Source code in <code>src\\himena\\standards\\plotting\\_api.py</code> <pre><code>def figure_3d(background_color: Any = \"white\") -&gt; layout3d.SingleAxes3D:\n    \"\"\"Make a single 3D axes layout model.\n\n    Examples\n    --------\n    ``` python\n    from himena.standards import plotting as hplt\n    fig = hplt.figure_3d()\n    fig.plot([0, 1, 2], [4, 2, 3], [6, 8, 7], color=\"red\")\n    fig.show()  # show as a sub-window in the current widget\n    ```\n    \"\"\"\n    lo = layout3d.SingleAxes3D(background_color=background_color)\n    return lo\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.grid","title":"<code>grid(rows=1, cols=1, *, background_color='white')</code>","text":"<p>Make a grid layout model.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>Number of rows, by default 1</p> <code>1</code> <code>cols</code> <code>int</code> <p>Number of columns, by default 1</p> <code>1</code> <p>Examples:</p> <pre><code>from himena.standards import plotting as hplt\ngrd = hplt.grid(2, 3)\ngrd[0, 0].plot([0, 1, 2], [4, 2, 3], color=\"green\")\ngrd.show()  # show as a sub-window in the current widget\n</code></pre> Source code in <code>src\\himena\\standards\\plotting\\_api.py</code> <pre><code>def grid(\n    rows: int = 1, cols: int = 1, *, background_color: Any = \"white\"\n) -&gt; layout.Grid:\n    \"\"\"Make a grid layout model.\n\n    Parameters\n    ----------\n    rows : int, optional\n        Number of rows, by default 1\n    cols : int, optional\n        Number of columns, by default 1\n\n    Examples\n    --------\n    ``` python\n    from himena.standards import plotting as hplt\n    grd = hplt.grid(2, 3)\n    grd[0, 0].plot([0, 1, 2], [4, 2, 3], color=\"green\")\n    grd.show()  # show as a sub-window in the current widget\n    ```\n    \"\"\"\n    lo = layout.Grid.fill(rows, cols)\n    lo.background_color = \"white\"\n    return lo\n</code></pre>"},{"location":"api/standards/plotting/#himena.standards.plotting.row","title":"<code>row(num=1, *, background_color='white')</code>","text":"<p>Make a row layout model.</p> <p>Examples:</p> <pre><code>from himena.standards import plotting as hplt\nrow = hplt.row(2)\nrow[0].plot([0, 1, 2], [4, 2, 3], color=\"red\")\nrow.show()  # show as a sub-window in the current widget\n</code></pre> Source code in <code>src\\himena\\standards\\plotting\\_api.py</code> <pre><code>def row(num: int = 1, *, background_color: Any = \"white\") -&gt; layout.Row:\n    \"\"\"Make a row layout model.\n\n    Examples\n    --------\n    ``` python\n    from himena.standards import plotting as hplt\n    row = hplt.row(2)\n    row[0].plot([0, 1, 2], [4, 2, 3], color=\"red\")\n    row.show()  # show as a sub-window in the current widget\n    ```\n    \"\"\"\n    lo = layout.Row.fill(num)\n    lo.background_color = background_color\n    return lo\n</code></pre>"},{"location":"api/standards/roi/","title":"himena.standards.roi","text":"<p>Standard ROI (Region of Interest) classes for images.</p>"},{"location":"api/standards/roi/#himena.standards.roi.CircleRoi","title":"<code>CircleRoi</code>","text":"<p>ROI that represents a circle.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>x</code> <code>int | float</code> <p>X-coordinate of the center.</p> required <code>y</code> <code>int | float</code> <p>Y-coordinate of the center.</p> required <code>radius</code> <code>int | float</code> <p>Radius of the circle.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class CircleRoi(Roi2D):\n    \"\"\"ROI that represents a circle.\"\"\"\n\n    x: Scalar = Field(..., description=\"X-coordinate of the center.\")\n    y: Scalar = Field(..., description=\"Y-coordinate of the center.\")\n    radius: Scalar = Field(..., description=\"Radius of the circle.\")\n\n    def shifted(self, dx: float, dy: float) -&gt; CircleRoi:\n        return self.model_copy(update={\"x\": self.x + dx, \"y\": self.y + dy})\n\n    def area(self) -&gt; float:\n        return math.pi * self.radius**2\n\n    def circumference(self) -&gt; float:\n        return 2 * math.pi * self.radius\n\n    def bbox(self) -&gt; Rect[float]:\n        return Rect(\n            self.x - self.radius,\n            self.y - self.radius,\n            2 * self.radius,\n            2 * self.radius,\n        )\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        _yy, _xx = np.indices(shape[-2:])\n        comp_a = (_yy - self.y) / self.radius\n        comp_b = (_xx - self.x) / self.radius\n        return comp_a**2 + comp_b**2 &lt;= 1\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.EllipseRoi","title":"<code>EllipseRoi</code>","text":"<p>ROI that represents an ellipse.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>x</code> <code>int | float</code> <p>X-coordinate of the left boundary.</p> required <code>y</code> <code>int | float</code> <p>Y-coordinate of the top boundary.</p> required <code>width</code> <code>int | float</code> <p>Diameter along the x-axis.</p> required <code>height</code> <code>int | float</code> <p>Diameter along the y-axis.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class EllipseRoi(Roi2D):\n    \"\"\"ROI that represents an ellipse.\"\"\"\n\n    x: Scalar = Field(..., description=\"X-coordinate of the left boundary.\")\n    y: Scalar = Field(..., description=\"Y-coordinate of the top boundary.\")\n    width: Scalar = Field(..., description=\"Diameter along the x-axis.\")\n    height: Scalar = Field(..., description=\"Diameter along the y-axis.\")\n\n    def center(self) -&gt; tuple[float, float]:\n        return self.x + self.width / 2, self.y + self.height / 2\n\n    def shifted(self, dx: float, dy: float) -&gt; EllipseRoi:\n        return self.model_copy(update={\"x\": self.x + dx, \"y\": self.y + dy})\n\n    def area(self) -&gt; float:\n        return math.pi * self.width * self.height / 4\n\n    def eccentricity(self) -&gt; float:\n        \"\"\"Eccentricity of the ellipse.\"\"\"\n        return _utils.eccentricity(self.width / 2, self.height / 2)\n\n    def bbox(self) -&gt; Rect[float]:\n        return Rect(self.x, self.y, self.width, self.height)\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        _yy, _xx = np.indices(shape[-2:])\n        cx, cy = self.center()\n        if self.height == 0 or self.width == 0:\n            return np.zeros(shape, dtype=bool)\n        comp_a = (_yy - cy) / self.height * 2\n        comp_b = (_xx - cx) / self.width * 2\n        return comp_a**2 + comp_b**2 &lt;= 1\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.EllipseRoi.eccentricity","title":"<code>eccentricity()</code>","text":"<p>Eccentricity of the ellipse.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def eccentricity(self) -&gt; float:\n    \"\"\"Eccentricity of the ellipse.\"\"\"\n    return _utils.eccentricity(self.width / 2, self.height / 2)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.LineRoi","title":"<code>LineRoi</code>","text":"<p>A 2D line ROI.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>start</code> <code>tuple[float, float]</code> <p>(X, Y) coordinate of the start point.</p> required <code>end</code> <code>tuple[float, float]</code> <p>(X, Y) coordinate of the end point.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class LineRoi(Roi2D):\n    \"\"\"A 2D line ROI.\"\"\"\n\n    start: tuple[float, float] = Field(..., description=\"(X, Y) coordinate of the start point.\")  # fmt: skip\n    end: tuple[float, float] = Field(..., description=\"(X, Y) coordinate of the end point.\")  # fmt: skip\n\n    @property\n    def x1(self) -&gt; float:\n        return self.start[0]\n\n    @property\n    def y1(self) -&gt; float:\n        return self.start[1]\n\n    @property\n    def x2(self) -&gt; float:\n        return self.end[0]\n\n    @property\n    def y2(self) -&gt; float:\n        return self.end[1]\n\n    def shifted(self, dx: float, dy: float) -&gt; LineRoi:\n        \"\"\"Shift the line by the given amount.\"\"\"\n        return LineRoi(\n            start=(self.x1 + dx, self.y1 + dy),\n            end=(self.x2 + dx, self.y2 + dy),\n        )\n\n    def length(self) -&gt; float:\n        \"\"\"Length of the line.\"\"\"\n        dx = self.x2 - self.x1\n        dy = self.y2 - self.y1\n        return math.hypot(dx, dy)\n\n    def angle(self) -&gt; float:\n        \"\"\"Angle in degrees.\"\"\"\n        return math.degrees(self.angle_radian())\n\n    def angle_radian(self) -&gt; float:\n        dx = self.x2 - self.x1\n        dy = self.y1 - self.y2  # NOTE: invert y so that angle is CCW\n        return math.atan2(dy, dx)\n\n    def linspace(self, num: int) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n        \"\"\"Return a tuple of x and y coordinates of np.linspace along the line.\"\"\"\n        return np.linspace(self.x1, self.x2, num), np.linspace(self.y1, self.y2, num)\n\n    def arange(\n        self, step: float = 1.0\n    ) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n        \"\"\"Return a tuple of x and y coordinates of np.arange along the line.\"\"\"\n        radian = -self.angle_radian()\n        num, rem = divmod(self.length(), step)\n        xrem = rem * math.cos(radian)\n        yrem = rem * math.sin(radian)\n        return (\n            np.linspace(self.x1, self.x2 - xrem, int(num) + 1),\n            np.linspace(self.y1, self.y2 - yrem, int(num) + 1),\n        )\n\n    def bbox(self) -&gt; Rect[float]:\n        xmin, xmax = min(self.x1, self.x2), max(self.x1, self.x2)\n        ymin, ymax = min(self.y1, self.y2), max(self.y1, self.y2)\n        return Rect(xmin, ymin, xmax - xmin, ymax - ymin)\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        arr = np.zeros(shape, dtype=bool)\n        xs, ys = self.linspace(int(self.length() + 1))\n        xs = xs.round().astype(int)\n        ys = ys.round().astype(int)\n        arr[ys, xs] = True\n        return arr\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.LineRoi.angle","title":"<code>angle()</code>","text":"<p>Angle in degrees.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def angle(self) -&gt; float:\n    \"\"\"Angle in degrees.\"\"\"\n    return math.degrees(self.angle_radian())\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.LineRoi.arange","title":"<code>arange(step=1.0)</code>","text":"<p>Return a tuple of x and y coordinates of np.arange along the line.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def arange(\n    self, step: float = 1.0\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n    \"\"\"Return a tuple of x and y coordinates of np.arange along the line.\"\"\"\n    radian = -self.angle_radian()\n    num, rem = divmod(self.length(), step)\n    xrem = rem * math.cos(radian)\n    yrem = rem * math.sin(radian)\n    return (\n        np.linspace(self.x1, self.x2 - xrem, int(num) + 1),\n        np.linspace(self.y1, self.y2 - yrem, int(num) + 1),\n    )\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.LineRoi.length","title":"<code>length()</code>","text":"<p>Length of the line.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def length(self) -&gt; float:\n    \"\"\"Length of the line.\"\"\"\n    dx = self.x2 - self.x1\n    dy = self.y2 - self.y1\n    return math.hypot(dx, dy)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.LineRoi.linspace","title":"<code>linspace(num)</code>","text":"<p>Return a tuple of x and y coordinates of np.linspace along the line.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def linspace(self, num: int) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n    \"\"\"Return a tuple of x and y coordinates of np.linspace along the line.\"\"\"\n    return np.linspace(self.x1, self.x2, num), np.linspace(self.y1, self.y2, num)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.LineRoi.shifted","title":"<code>shifted(dx, dy)</code>","text":"<p>Shift the line by the given amount.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def shifted(self, dx: float, dy: float) -&gt; LineRoi:\n    \"\"\"Shift the line by the given amount.\"\"\"\n    return LineRoi(\n        start=(self.x1 + dx, self.y1 + dy),\n        end=(self.x2 + dx, self.y2 + dy),\n    )\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.PointRoi1D","title":"<code>PointRoi1D</code>","text":"<p>ROI that represents a point in 1D space.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>x</code> <code>float</code> <p>X-coordinate of the point.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class PointRoi1D(Roi1D):\n    \"\"\"ROI that represents a point in 1D space.\"\"\"\n\n    x: float = Field(..., description=\"X-coordinate of the point.\")\n\n    def shifted(self, dx: float) -&gt; PointRoi1D:\n        return PointRoi1D(x=self.x + dx)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.PointRoi2D","title":"<code>PointRoi2D</code>","text":"<p>ROI that represents a single point.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>x</code> <code>float</code> <p>X-coordinate of the point.</p> required <code>y</code> <code>float</code> <p>Y-coordinate of the point.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class PointRoi2D(Roi2D):\n    \"\"\"ROI that represents a single point.\"\"\"\n\n    x: float = Field(..., description=\"X-coordinate of the point.\")\n    y: float = Field(..., description=\"Y-coordinate of the point.\")\n\n    def shifted(self, dx: float, dy: float) -&gt; PointRoi2D:\n        return self.model_copy(update={\"x\": self.x + dx, \"y\": self.y + dy})\n\n    def bbox(self) -&gt; Rect[float]:\n        return Rect(self.x, self.y, 0, 0)\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        arr = np.zeros(shape, dtype=bool)\n        arr[..., int(round(self.y)), int(round(self.x))] = True\n        return arr\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.PointsRoi1D","title":"<code>PointsRoi1D</code>","text":"<p>ROI that represents a set of points in 1D space.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>xs</code> <code>Any</code> <p>List of x-coordinates.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class PointsRoi1D(Roi1D):\n    \"\"\"ROI that represents a set of points in 1D space.\"\"\"\n\n    xs: Any = Field(..., description=\"List of x-coordinates.\")\n\n    @field_validator(\"xs\")\n    def _validate_np_array(cls, v) -&gt; NDArray[np.number]:\n        out = np.asarray(v)\n        if out.dtype.kind not in \"if\":\n            raise ValueError(\"Must be a numerical array.\")\n        return out\n\n    def shifted(self, dx: float) -&gt; PointsRoi1D:\n        return PointsRoi1D(xs=self.xs + dx)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.PointsRoi2D","title":"<code>PointsRoi2D</code>","text":"<p>ROI that represents a set of points.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>xs</code> <code>Any</code> <p>List of x-coordinates.</p> required <code>ys</code> <code>Any</code> <p>List of y-coordinates.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class PointsRoi2D(Roi2D):\n    \"\"\"ROI that represents a set of points.\"\"\"\n\n    xs: Any = Field(..., description=\"List of x-coordinates.\")\n    ys: Any = Field(..., description=\"List of y-coordinates.\")\n\n    @field_validator(\"xs\", \"ys\")\n    def _validate_np_arrays(cls, v) -&gt; NDArray[np.number]:\n        out = np.asarray(v)\n        if out.dtype.kind not in \"if\":\n            raise ValueError(\"Must be a numerical array.\")\n        return out\n\n    def model_dump_typed(self) -&gt; dict[str, Any]:\n        out = super().model_dump_typed()\n        out[\"xs\"] = self.xs.tolist()\n        out[\"ys\"] = self.ys.tolist()\n        return out\n\n    def shifted(self, dx: float, dy: float) -&gt; PointsRoi2D:\n        return self.model_copy(update={\"xs\": self.xs + dx, \"ys\": self.ys + dy})\n\n    def bbox(self) -&gt; Rect[float]:\n        xmin, xmax = np.min(self.xs), np.max(self.xs)\n        ymin, ymax = np.min(self.ys), np.max(self.ys)\n        return Rect(xmin, ymin, xmax - xmin, ymax - ymin)\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        arr = np.zeros(shape, dtype=bool)\n        xs = np.asarray(self.xs).round().astype(int)\n        ys = np.asarray(self.ys).round().astype(int)\n        arr[..., ys, xs] = True\n        return arr\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.PolygonRoi","title":"<code>PolygonRoi</code>","text":"<p>ROI that represents a closed polygon.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>xs</code> <code>Any</code> <p>List of x-coordinates.</p> required <code>ys</code> <code>Any</code> <p>List of y-coordinates.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class PolygonRoi(SegmentedLineRoi):\n    \"\"\"ROI that represents a closed polygon.\"\"\"\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        return _utils.polygon_mask(shape, np.column_stack((self.ys, self.xs)))\n\n    def area(self) -&gt; float:\n        dot_xy = np.dot(self.xs, np.roll(self.ys, 1))\n        dot_yx = np.dot(self.ys, np.roll(self.xs, 1))\n        return np.abs(dot_xy - dot_yx) / 2\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RectangleRoi","title":"<code>RectangleRoi</code>","text":"<p>ROI that represents a rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>x</code> <code>int | float</code> <p>X-coordinate of the top-left corner.</p> required <code>y</code> <code>int | float</code> <p>Y-coordinate of the top-left corner.</p> required <code>width</code> <code>int | float</code> <p>Width of the rectangle.</p> required <code>height</code> <code>int | float</code> <p>Height of the rectangle.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class RectangleRoi(Roi2D):\n    \"\"\"ROI that represents a rectangle.\"\"\"\n\n    x: Scalar = Field(..., description=\"X-coordinate of the top-left corner.\")\n    y: Scalar = Field(..., description=\"Y-coordinate of the top-left corner.\")\n    width: Scalar = Field(..., description=\"Width of the rectangle.\")\n    height: Scalar = Field(..., description=\"Height of the rectangle.\")\n\n    def shifted(self, dx: float, dy: float) -&gt; RectangleRoi:\n        \"\"\"Return a new rectangle shifted by the given amount.\"\"\"\n        return self.model_copy(update={\"x\": self.x + dx, \"y\": self.y + dy})\n\n    def area(self) -&gt; float:\n        \"\"\"Return the area of the rectangle.\"\"\"\n        return self.width * self.height\n\n    def bbox(self) -&gt; Rect[float]:\n        \"\"\"Return the bounding box of the rectangle.\"\"\"\n        return Rect(self.x, self.y, self.width, self.height)\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        bb = self.bbox().adjust_to_int(\"inner\")\n        arr = np.zeros(shape, dtype=bool)\n        arr[..., bb.top : bb.bottom, bb.left : bb.right] = True\n        return arr\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RectangleRoi.area","title":"<code>area()</code>","text":"<p>Return the area of the rectangle.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def area(self) -&gt; float:\n    \"\"\"Return the area of the rectangle.\"\"\"\n    return self.width * self.height\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RectangleRoi.bbox","title":"<code>bbox()</code>","text":"<p>Return the bounding box of the rectangle.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def bbox(self) -&gt; Rect[float]:\n    \"\"\"Return the bounding box of the rectangle.\"\"\"\n    return Rect(self.x, self.y, self.width, self.height)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RectangleRoi.shifted","title":"<code>shifted(dx, dy)</code>","text":"<p>Return a new rectangle shifted by the given amount.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def shifted(self, dx: float, dy: float) -&gt; RectangleRoi:\n    \"\"\"Return a new rectangle shifted by the given amount.\"\"\"\n    return self.model_copy(update={\"x\": self.x + dx, \"y\": self.y + dy})\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.Roi1D","title":"<code>Roi1D</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>class Roi1D(RoiModel):\n    def shifted(self, dx: float) -&gt; Self:\n        \"\"\"Return a new 1D ROI translated by the given amount.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.Roi1D.shifted","title":"<code>shifted(dx)</code>","text":"<p>Return a new 1D ROI translated by the given amount.</p> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>def shifted(self, dx: float) -&gt; Self:\n    \"\"\"Return a new 1D ROI translated by the given amount.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.Roi2D","title":"<code>Roi2D</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>class Roi2D(RoiModel):\n    def bbox(self) -&gt; Rect[float]:\n        \"\"\"Return the bounding box of the ROI.\"\"\"\n        raise NotImplementedError\n\n    def shifted(self, dx: float, dy: float) -&gt; Self:\n        \"\"\"Return a new 2D ROI translated by the given amount.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.Roi2D.bbox","title":"<code>bbox()</code>","text":"<p>Return the bounding box of the ROI.</p> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>def bbox(self) -&gt; Rect[float]:\n    \"\"\"Return the bounding box of the ROI.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.Roi2D.shifted","title":"<code>shifted(dx, dy)</code>","text":"<p>Return a new 2D ROI translated by the given amount.</p> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>def shifted(self, dx: float, dy: float) -&gt; Self:\n    \"\"\"Return a new 2D ROI translated by the given amount.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.Roi3D","title":"<code>Roi3D</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>class Roi3D(RoiModel):\n    def shifted(self, dx: float, dy: float, dz: float) -&gt; Self:\n        \"\"\"Return a new 3D ROI translated by the given amount.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.Roi3D.shifted","title":"<code>shifted(dx, dy, dz)</code>","text":"<p>Return a new 3D ROI translated by the given amount.</p> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>def shifted(self, dx: float, dy: float, dz: float) -&gt; Self:\n    \"\"\"Return a new 3D ROI translated by the given amount.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RoiListModel","title":"<code>RoiListModel</code>  <code>dataclass</code>","text":"<p>List of ROIs, with useful methods.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>str</code> <code>array([], dtype=object)</code> <code>indices</code> <code>str</code> <code>array([], shape=(0, 0), dtype=int32)</code> <code>axis_names</code> <code>str</code> <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\standards\\roi\\_list.py</code> <pre><code>class RoiListModel(NDObjectCollection[RoiModel]):\n    \"\"\"List of ROIs, with useful methods.\"\"\"\n\n    def model_dump_typed(self) -&gt; dict:\n        return {\n            \"rois\": [roi.model_dump_typed() for roi in self],\n            \"indices\": self.indices.tolist() if self.indices is not None else None,\n            \"axis_names\": self.axis_names,\n        }\n\n    @classmethod\n    def construct(cls, dict_: dict) -&gt; RoiListModel:\n        \"\"\"Construct an instance from a dictionary.\"\"\"\n        rois = []\n        for roi_dict in dict_[\"rois\"]:\n            if not isinstance(roi_dict, dict):\n                raise ValueError(f\"Expected a dictionary for 'rois', got: {roi_dict!r}\")\n            roi_type = roi_dict.pop(\"type\")\n            roi = RoiModel.construct(roi_type, roi_dict)\n            rois.append(roi)\n        return cls(\n            items=rois,\n            indices=np.array(dict_[\"indices\"], dtype=np.int32),\n            axis_names=dict_[\"axis_names\"],\n        )\n\n    @classmethod\n    def model_validate_json(cls, text: str) -&gt; RoiListModel:\n        \"\"\"Validate the json string and return an instance.\"\"\"\n        js = json.loads(text)\n        return cls.construct(js)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RoiListModel.construct","title":"<code>construct(dict_)</code>  <code>classmethod</code>","text":"<p>Construct an instance from a dictionary.</p> Source code in <code>src\\himena\\standards\\roi\\_list.py</code> <pre><code>@classmethod\ndef construct(cls, dict_: dict) -&gt; RoiListModel:\n    \"\"\"Construct an instance from a dictionary.\"\"\"\n    rois = []\n    for roi_dict in dict_[\"rois\"]:\n        if not isinstance(roi_dict, dict):\n            raise ValueError(f\"Expected a dictionary for 'rois', got: {roi_dict!r}\")\n        roi_type = roi_dict.pop(\"type\")\n        roi = RoiModel.construct(roi_type, roi_dict)\n        rois.append(roi)\n    return cls(\n        items=rois,\n        indices=np.array(dict_[\"indices\"], dtype=np.int32),\n        axis_names=dict_[\"axis_names\"],\n    )\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RoiListModel.model_validate_json","title":"<code>model_validate_json(text)</code>  <code>classmethod</code>","text":"<p>Validate the json string and return an instance.</p> Source code in <code>src\\himena\\standards\\roi\\_list.py</code> <pre><code>@classmethod\ndef model_validate_json(cls, text: str) -&gt; RoiListModel:\n    \"\"\"Validate the json string and return an instance.\"\"\"\n    js = json.loads(text)\n    return cls.construct(js)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RoiModel","title":"<code>RoiModel</code>","text":"<p>Base class for ROIs (Region of Interest) in images.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>class RoiModel(BaseModel):\n    \"\"\"Base class for ROIs (Region of Interest) in images.\"\"\"\n\n    name: str | None = Field(None, description=\"Name of the ROI.\")\n\n    def model_dump_typed(self) -&gt; dict:\n        return {\n            \"type\": _strip_roi_suffix(type(self).__name__.lower()),\n            **self.model_dump(),\n        }\n\n    @classmethod\n    def construct(cls, typ: str, dict_: dict) -&gt; RoiModel:\n        \"\"\"Construct an instance from a dictionary.\"\"\"\n        model_type = pick_roi_model(typ)\n        return model_type.model_validate(dict_)\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        raise NotImplementedError\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RoiModel.construct","title":"<code>construct(typ, dict_)</code>  <code>classmethod</code>","text":"<p>Construct an instance from a dictionary.</p> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>@classmethod\ndef construct(cls, typ: str, dict_: dict) -&gt; RoiModel:\n    \"\"\"Construct an instance from a dictionary.\"\"\"\n    model_type = pick_roi_model(typ)\n    return model_type.model_validate(dict_)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RotatedEllipseRoi","title":"<code>RotatedEllipseRoi</code>","text":"<p>ROI that represents a rotated ellipse.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>start</code> <code>tuple[float, float]</code> <p>(X, Y) coordinate of the start point.</p> required <code>end</code> <code>tuple[float, float]</code> <p>(X, Y) coordinate of the end point.</p> required <code>width</code> <code>float</code> <p>Width of the ROI.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class RotatedEllipseRoi(RotatedRoi2D):\n    \"\"\"ROI that represents a rotated ellipse.\"\"\"\n\n    def area(self) -&gt; float:\n        return self.length() * self.width * math.pi / 4\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        _yy, _xx = np.indices(shape[-2:])\n        start_x, start_y = self.start\n        end_x, end_y = self.end\n        length = math.hypot(end_x - start_x, end_y - start_y)\n        cx, cy = (start_x + end_x) / 2, (start_y + end_y) / 2\n        angle = self.angle_radian()\n        comp_a = (_yy - cy) / length * 2\n        comp_b = (_xx - cx) / self.width * 2\n        comp_a, comp_b = (\n            comp_a * math.cos(angle) - comp_b * math.sin(angle),\n            comp_a * math.sin(angle) + comp_b * math.cos(angle),\n        )\n        return comp_a**2 + comp_b**2 &lt;= 1\n\n    def eccentricity(self) -&gt; float:\n        \"\"\"Eccentricity of the ellipse.\"\"\"\n        return _utils.eccentricity(self.length() / 2, self.width / 2)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RotatedEllipseRoi.eccentricity","title":"<code>eccentricity()</code>","text":"<p>Eccentricity of the ellipse.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def eccentricity(self) -&gt; float:\n    \"\"\"Eccentricity of the ellipse.\"\"\"\n    return _utils.eccentricity(self.length() / 2, self.width / 2)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RotatedRectangleRoi","title":"<code>RotatedRectangleRoi</code>","text":"<p>ROI that represents a rotated rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>start</code> <code>tuple[float, float]</code> <p>(X, Y) coordinate of the start point.</p> required <code>end</code> <code>tuple[float, float]</code> <p>(X, Y) coordinate of the end point.</p> required <code>width</code> <code>float</code> <p>Width of the ROI.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class RotatedRectangleRoi(RotatedRoi2D):\n    \"\"\"ROI that represents a rotated rectangle.\"\"\"\n\n    def area(self) -&gt; float:\n        return self.length() * self.width\n\n    def bbox(self) -&gt; Rect[float]:\n        p00, p01, p11, p10 = self._get_vertices()\n        xmin = min(p00[0], p01[0], p10[0], p11[0])\n        xmax = max(p00[0], p01[0], p10[0], p11[0])\n        ymin = min(p00[1], p01[1], p10[1], p11[1])\n        ymax = max(p00[1], p01[1], p10[1], p11[1])\n        return Rect(xmin, ymin, xmax - xmin, ymax - ymin)\n\n    def _get_vertices(self):\n        start_x, start_y = self.start\n        end_x, end_y = self.end\n        vx, vy = self._get_vx_vy()\n        center = np.array([start_x + end_x, start_y + end_y]) / 2\n        p00 = center - vx / 2 - vy / 2\n        p01 = center - vx / 2 + vy / 2\n        p10 = center + vx / 2 - vy / 2\n        p11 = center + vx / 2 + vy / 2\n        return p00, p01, p11, p10\n\n    def to_mask(self, shape: tuple[int, ...]):\n        vertices = np.stack(self._get_vertices(), axis=0)\n        return _utils.polygon_mask(shape, vertices[:, ::-1])\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.SegmentedLineRoi","title":"<code>SegmentedLineRoi</code>","text":"<p>ROI that represents a segmented line.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>xs</code> <code>Any</code> <p>List of x-coordinates.</p> required <code>ys</code> <code>Any</code> <p>List of y-coordinates.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class SegmentedLineRoi(PointsRoi2D):\n    \"\"\"ROI that represents a segmented line.\"\"\"\n\n    def length(self) -&gt; np.float64:\n        return np.sum(self.lengths())\n\n    def lengths(self) -&gt; NDArray[np.float64]:\n        return np.hypot(np.diff(self.xs), np.diff(self.ys))\n\n    def linspace(self, num: int) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n        \"\"\"Return a tuple of x and y coordinates of np.linspace along the line.\"\"\"\n        tnots = np.cumsum(np.concatenate([[0], self.lengths()], dtype=np.float64))\n        teval = np.linspace(0, tnots[-1], num)\n        xi = np.interp(teval, tnots, self.xs)\n        yi = np.interp(teval, tnots, self.ys)\n        return xi, yi\n\n    def arange(\n        self, step: float = 1.0\n    ) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n        tnots = np.cumsum(np.concatenate([[0], self.lengths()], dtype=np.float64))\n        length = tnots[-1]\n        num, rem = divmod(length, step)\n        teval = np.linspace(0, length - rem, int(num + 1))\n        xi = np.interp(teval, tnots, self.xs)\n        yi = np.interp(teval, tnots, self.ys)\n        return xi, yi\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        arr = np.zeros(shape, dtype=bool)\n        xs, ys = self.linspace(int(math.ceil(self.length())))\n        xs = xs.round().astype(int)\n        ys = ys.round().astype(int)\n        arr[ys, xs] = True\n        return arr\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.SegmentedLineRoi.linspace","title":"<code>linspace(num)</code>","text":"<p>Return a tuple of x and y coordinates of np.linspace along the line.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def linspace(self, num: int) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n    \"\"\"Return a tuple of x and y coordinates of np.linspace along the line.\"\"\"\n    tnots = np.cumsum(np.concatenate([[0], self.lengths()], dtype=np.float64))\n    teval = np.linspace(0, tnots[-1], num)\n    xi = np.interp(teval, tnots, self.xs)\n    yi = np.interp(teval, tnots, self.ys)\n    return xi, yi\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.SpanRoi","title":"<code>SpanRoi</code>","text":"<p>ROI that represents a span in 1D space.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>start</code> <code>float</code> <p>Start of the span.</p> required <code>end</code> <code>float</code> <p>End of the span.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class SpanRoi(Roi1D):\n    \"\"\"ROI that represents a span in 1D space.\"\"\"\n\n    start: float = Field(..., description=\"Start of the span.\")\n    end: float = Field(..., description=\"End of the span.\")\n\n    def shifted(self, dx: float) -&gt; SpanRoi:\n        return SpanRoi(start=self.start + dx, end=self.end + dx)\n\n    def width(self) -&gt; float:\n        return self.end - self.start\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.SplineRoi","title":"<code>SplineRoi</code>","text":"<p>ROI that represents a spline curve.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>degree</code> <code>int</code> <p>Degree of the spline curve.</p> <code>3</code> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class SplineRoi(Roi2D):\n    \"\"\"ROI that represents a spline curve.\"\"\"\n\n    degree: int = Field(3, description=\"Degree of the spline curve.\", ge=1)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.default_roi_label","title":"<code>default_roi_label(nth)</code>","text":"<p>Return a default label for the n-th ROI.</p> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>def default_roi_label(nth: int) -&gt; str:\n    \"\"\"Return a default label for the n-th ROI.\"\"\"\n    return f\"ROI-{nth}\"\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.pick_roi_model","title":"<code>pick_roi_model(typ)</code>  <code>cached</code>","text":"<p>Pick an ROI model class from the given type string</p> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>@cache\ndef pick_roi_model(typ: str) -&gt; type[RoiModel]:\n    \"\"\"Pick an ROI model class from the given type string\"\"\"\n    for sub in iter_subclasses(RoiModel):\n        if _strip_roi_suffix(sub.__name__.lower()) == typ:\n            return sub\n    raise ValueError(f\"Unknown ROI type: {typ!r}\")\n</code></pre>"},{"location":"dev/","title":"Developer's Guide","text":"<p>In this section, you will learn how to develop plugins for <code>himena</code>.</p> <ul> <li>The WidgetDataModel Standard</li> <li>Plugin System</li> <li>Reader and Writer Functions</li> <li>Register Functions</li> <li>Register Widgets</li> <li>Register Dock Widgets</li> </ul> <p>Here's some useful standardized objects to make plugins compatible with each other.</p> <ul> <li>Plotting in Himena</li> </ul>"},{"location":"dev/drag_and_drop/","title":"Drag and Drop","text":"<p>Implementation of drag and drop is indispensable for a good user experience of a plugin widget. Currently, Qt is the only supported GUI framework, and Qt provides overriddable methods for drag and drop; therefore, you can just define the behavior at the widget level. However, low-level implementation of drag and drop ignores the rich functionality of <code>himena</code>, especially the workflow. This section describes how to implement drag and drop nicely.</p>"},{"location":"dev/drag_and_drop/#drag-a-command-and-associated-parameters","title":"Drag a Command and Associated Parameters","text":"<p>In <code>himena</code>, dragging a part of the widget is more like dragging a set of command and associated parameters. The command is supposed to be executed when the user drops it.</p> <p>To do this, you need to first register a command, and call <code>drag_command</code> method when the user starts dragging. Because mouse dragging event can only handled at the Qt level, you usually need to override the <code>mouseMoveEvent</code> methods to trigger a drag.</p>"},{"location":"dev/drag_and_drop/#1-register-a-command","title":"1. Register a command","text":"<p>First, you need to register a command that will be executed when the user drops the item. The way you register a command is exactly the same as registering any other commands.</p> <p>Following is an example of registering a command that just creates a text data.</p> <pre><code>from himena import WidgetDataModel, Parametric, StandardType\nfrom himena.plugins import register_hidden_function\n\n@register_hidden_function(command_id=\"test-drag\")\ndef test_drag() -&gt; Parametric:\n    def run(text: str) -&gt; WidgetDataModel:\n        return WidgetDataModel(value=text, type=StandardType.TEXT)\n    return run\n</code></pre>"},{"location":"dev/drag_and_drop/#2-implement-a-widget","title":"2. Implement a widget","text":"<p><code>drag_command</code> must be called when dragging starts. It takes parameters that specify the <code>QDrag</code> source object, resulting type, command to be executed, and associated parameters. <code>command_id</code> and <code>with_params</code> work similarly as the <code>exec_action</code> method of the main window.</p> <p>Following is a simple widget that starts dragging event when the user moves the mouse while holding the right button.</p> <pre><code>from qtpy import QtCore, QtGui, QtWidgets as QtW\nfrom himena.qt import drag_command\n\nclass MyWidget(QtW.QWidget):\n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self._is_dragging = False\n\n    def mouseMoveEvent(self, a0):\n        if self._is_dragging:\n            return super().mouseMoveEvent(a0)\n        if a0.buttons() &amp; QtCore.Qt.MouseButton.RightButton:\n            self._is_dragging = True\n            drag_command(\n                source=self,\n                type=StandardType.TEXT,\n                command_id=\"test-drag\",\n                with_params={\"text\": \"TEST DRAG\"},\n                desc=\"Testing Drag ...\",\n            )\n            return\n        return super().mouseMoveEvent(a0)\n\n    def mouseReleaseEvent(self, a0: QtGui.QMouseEvent | None) -&gt; None:\n        self._is_dragging = False\n        return super().mouseReleaseEvent(a0)\n</code></pre>"},{"location":"dev/drag_and_drop/#3-test-it","title":"3. Test it!","text":"<p>Now, you can test the drag and drop functionality by directly adding the widget to the main window.</p> <pre><code>from himena import new_window\n\nui = new_window()\nui.add_widget(MyWidget())\nui.show()\n</code></pre>"},{"location":"dev/io_provider/","title":"Reader and Writer Functions","text":"<p>This section tells you how to extend the \"Open File(s) ...\" and \"Save ...\" actions so that it works for any file types you'd like to use in <code>himena</code>.</p>"},{"location":"dev/io_provider/#readerwriter-plugins","title":"Reader/Writer Plugins","text":"<p><code>himena</code> uses a <code>register_reader_plugin</code> and <code>register_writer_plugin</code> functions to register functions as reader/writer plugins.</p> <p>The example below is a simple text file reader plugin.</p> <pre><code>from pathlib import Path\nfrom himena.consts import StandardType\nfrom himena.plugins import register_reader_plugin\n\n@register_reader_plugin\ndef read_text(path: Path):\n    text_value = path.read_text()\n    return WidgetDataModel(\n        value=text_value,\n        type=StandardType.TEXT,\n        title=path.name,\n    )\n</code></pre> <p>Now <code>read_text</code> is a reader plugin object.</p> <pre><code>read_text\n</code></pre> Output<pre><code>&lt;ReaderPlugin read_text&gt;\n</code></pre> <p>This is not enough. When a path is given, <code>himena</code> does not know which reader function to be used. To let \".txt\" match the reader function we have just defined, use the <code>define_matcher</code> method. The matcher function must return <code>str</code> of data type if it can read the file, and <code>None</code> otherwise.</p> <pre><code>@read_text.define_matcher\ndef _(path: Path):\n    if path.suffix == \".txt\":\n        return StandardType.TEXT\n    return None\n</code></pre> Plugin priority <p>You can define the priority of the plugin to be chosen by passing the <code>priority</code> argument.</p> <pre><code>@register_reader_plugin(priority=10)\ndef read_text(path: Path):\n    ...\n</code></pre> <p><code>priority</code> is set to <code>100</code> by default, and the default providers have <code>priority=0</code>, which means that if you override the reader/writer for a file type, your provider will always be used.</p> <p>If <code>priority</code> is negative, the plugin will not be used unless users explicitly choose your plugin by \"Open File With ...\" command.</p> <p>Matcher must be fast</p> <p>The matcher function must not be a time-consuming function. When the application tries to open a file, all registered matcher functions are called.</p> <p>Similarly, you can define a writer plugin.</p> <pre><code>from pathlib import Path\nfrom himena.consts import StandardType\nfrom himena.plugins import register_writer_plugin\n\n@register_writer_plugin\ndef write_text(path: Path, model: WidgetDataModel):\n    return path.write_text(model.value)\n\n@write_text.define_matcher\ndef _(path: Path):\n    if path.suffix == \".txt\":\n        return True\n    return False\n</code></pre> <p>Unlike readers, matcher function returns <code>True</code> if the writer can write the file, and <code>False</code> otherwise.</p>"},{"location":"dev/plotting/","title":"Plotting in Himena","text":"<p><code>himena</code> supports <code>matplotlib</code> plotting by default. You can pass a <code>Figure</code> object and the type <code>\"matplotlib-figure\"</code> (<code>StandardType.MPL_FIGURE</code>) to a <code>WidgetDataModel</code> to create a sub-window with a <code>matplotlib</code> figure.</p> <p>However, directly using <code>matplotlib</code> object is not the best way to plot in <code>himena</code> because of the following reasons:</p> <ul> <li>The plot is not serializable. You cannot save the plot in a structured way.</li> <li>The plot result cannot be reused in other plot backends.</li> </ul> <p><code>himena</code> provides a standard plotting interface to create plots.</p>"},{"location":"dev/plotting/#plotting-standard","title":"Plotting Standard","text":"<p>The standard objects and plotting API are defined in <code>himena.standards.plotting</code>.</p> <pre><code>from himena.standards import plotting as hplt\n</code></pre> <p>Many methods are similar to <code>matplotlib</code>. You can run following code in the Python interpreter console (Ctrl+Shift+I) to see the plot.</p> <pre><code>import numpy as np\n\nfig = hplt.figure()\nx = np.linspace(0, 1, 100)\ny = np.sin(x * 2 * np.pi)\nfig.scatter(x, y, face_color=\"yellow\", edge_color=\"black\")\nfig.plot(x, -x, color=\"gray\", style=\"--\")\nfig.show()  # add to the current main window\n</code></pre> <p>What the functions do is just udpating the standard plotting models. They are converted to <code>matplotlib</code> object inside the plugin.</p>"},{"location":"dev/plugin_system/","title":"Plugin System","text":""},{"location":"dev/plugin_system/#defining-the-entry-point","title":"Defining the Entry Point","text":"<p>To make your module discoverable by <code>himena</code>, you need to configure the <code>pyproject.toml</code> file.</p> <p>For example, if you have a module named <code>himena_my_plugin</code> and all the IO functions are registered in the <code>io</code> submodule, you need to add the following configuration to the <code>pyproject.toml</code> file.</p> <pre><code>[project.entry-points.\"himena.plugin\"]\n\"My Plugin IO\" = \"himena_my_plugin.io\"\n</code></pre> <p>The \"My Plugin IO\" is the display name of your plugin, and the value \"himena_my_plugin.io\" is the import path to the submodule.</p> <p>Note</p> <p>You don't have to create a new package just for the plugin. This single TOML field will allow your package integrated with <code>himena</code>.</p> <p>To improve the customizability of your plugin, your plugin should be well categorized. For example, IO, widgets, and data processing functions should be separated into different submodules.</p> <pre><code>[project.entry-points.\"himena.plugin\"]\n\"My Plugin IO\" = \"himena_my_plugin.io\"\n\"My Plugin Widgets\" = \"himena_my_plugin.widgets\"\n\"My Plugin Data Processing\" = \"himena_my_plugin.processing\"\n</code></pre>"},{"location":"dev/plugin_system/#testing-plugins","title":"Testing Plugins","text":"<p>To locally test your plugin, first install your package to the python environment</p> <pre><code>pip install -e .\n</code></pre> <p>and run the following command to install to a <code>himena</code> profile.</p> <pre><code>himena &lt;my-profile&gt; --install himena-my-plugin\n</code></pre> <p>All the submodules listed in the \"himena.plugin\" entry point will be imported on the application startup.</p> <p>Note</p> <p>Make sure all the files are imported in the <code>__init__.py</code> file of the submodule.</p>"},{"location":"dev/plugin_system/#test-using-pytest","title":"Test using <code>pytest</code>","text":"<p>Testing <code>himena</code> plugins sometimes causes problems because <code>himena</code> application is initialized multiple times in the same test session. To avoid this, you can use the <code>install_plugin()</code> helper function to ensure that the plugin is installed only once in the beginning.</p> tests/conftest.py<pre><code>from himena.testing import install_plugin\nimport pytest\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef init_pytest(request):\n    install_plugin(\"himena-image\")\n</code></pre>"},{"location":"dev/plugin_system/#single-file-plugin","title":"Single-file Plugin","text":"<p>Sometimes you may prefer to create a plugin in a single file. This is useful for such as daily data analysis, in which you want to define different functions under different folders.</p> <p>You can do this by simply installing a python file.</p> <pre><code>himena &lt;my-profile&gt; --install path/to/my_plugin.py\n</code></pre> <p>The installed files will be run as a script on the startup.</p>"},{"location":"dev/register_dock_widgets/","title":"Dock Widgets","text":"<p>Dock widgets can be added to the <code>himena</code> main window. Unlike the widgets that are supposed to be added to inside sub-windows, dock widgets don't need any <code>WidgetDataModel</code> to represent their state.</p> When to use dock widgets? <p>Unlike sub-windows, dock widgets are always visible to the user but don't have any internal data. Therefore, dock widgets are suitable for widgets that make data processing routines more efficiently. For example, dock widgets defined in <code>himena_builtins</code> include:</p> <ul> <li>Python interpreter console.</li> <li>File explorers.</li> <li>Command history viewer.</li> </ul>"},{"location":"dev/register_dock_widgets/#register-widget","title":"Register Widget","text":"<pre><code>from himena.plugin import register_dock_widget_action\n\nclass MyDockWidget:\n    ...  # implementation\n\n@register_dock_widget_action(\n    title=\"My Dock Widget\",  # (1)!\n    area=\"bottom\",  # (2)!\n    singleton=True,  # (3)!\n)\ndef my_dock_widget_action(ui):\n    # Construct and return the dock widget.\n    return MyDockWidget(ui)\n</code></pre> <ol> <li><code>title</code>: The title of the dock widget.</li> <li><code>area</code>: The area where the dock widget is placed. The value can be one of <code>\"left\"</code>,    <code>\"right\"</code>, <code>\"top\"</code>, or <code>\"bottom\"</code>.</li> <li><code>singleton</code>: If <code>True</code>, only one instance of the dock widget can be created.</li> </ol>"},{"location":"dev/register_dock_widgets/#plugin-configuration","title":"Plugin Configuration","text":"<p><code>himena</code> natively supports plugin configuration that can be defined by the developer and customized by the end user in the setting dialog.</p> <p>To define a plugin configuration, the simplest way is to define a data class.</p> <pre><code>from dataclasses import dataclass, field\n\n@dataclass\nclass MyPluginConfig:\n    some_default_value: str = field(default=\"Hello, world!\")\n</code></pre> <p>Pass the configuration instance to the <code>register_dock_widget_action</code> decorator</p> <pre><code>@register_dock_widget_action(\n    title=\"My Dock Widget\",\n    area=\"bottom\",\n    config=MyPluginConfig(),\n)\ndef my_dock_widget_action(ui):\n    ...\n</code></pre> <p>and define <code>update_configs</code> method in the dock widget class.</p> <pre><code>class MyDockWidget:\n    def update_configs(self, cfg: MyPluginConfig):\n        ... # update the widget state based on the configuration\n</code></pre> <p>This way, <code>MyPluginConfig</code> can be customized in the setting dialog and serialized to the user profile so that it is persistent across sessions.</p>"},{"location":"dev/register_functions/","title":"Register Functions","text":"<p>To process and analyze data, you need functions that convert an object into another. This section tells you how to register such functions so that you can run them on the GUI.</p>"},{"location":"dev/register_functions/#function-definition","title":"Function Definition","text":"<p>Basically, a function that processes data is a function that takes a <code>WidgetDataModel</code> object and returns another <code>WidgetDataModel</code> object. For example, the following function formats a non-indented json text data into an indented, pretty json text data.</p> <pre><code>from himena import WidgetDataModel\n\ndef format_json(model: WidgetDataModel) -&gt; WidgetDataModel:\n    value = json.dumps(json.loads(model.value), indent=4)\n    return WidgetDataModel(value=value, type=\"text\")\n</code></pre> <p>Because <code>himena</code> has its default widget for <code>\"text\"</code>-type model, this function can be readly used in the GUI. You can register this function using <code>register_function()</code> function.</p> <pre><code>from himena import WidgetDataModel\nfrom himena.plugins import register_function\nimport json\n\n@register_function(title=\"Format JSON Text\")\ndef format_json(model: WidgetDataModel) -&gt; WidgetDataModel:\n    value = json.dumps(json.loads(model.value), indent=4)\n    return WidgetDataModel(value=value, type=\"text\")\n</code></pre> <p>The registered function will be shown in the menu bar (under the \"Plugins\" menu by default) and the command palette. When this function is called from the GUI, currently active window will be converted into a <code>WidgetDataModel</code> object and passed to the function. The returned <code>WidgetDataModel</code> object will then be converted into another window.</p> Running <p>Because all the internal data is stored in <code>WidgetDataModel</code> objects, you can even run functions without registered widgets.</p>"},{"location":"dev/register_functions/#dependency-injection-and-type-narrowing","title":"Dependency Injection and Type Narrowing","text":"<p><code>himena</code> uses <code>in_n_out</code> library to inject the application context into functions. For example, in the previous example, the <code>WidgetDataModel</code> of the current window is injected to the <code>model</code> argument of the <code>format_json</code> function. If no window is activated, the \"Format JSON Text\" menu is grayed out.</p> <p>Here are the list of type hints that will be provided to the argument of the registered functions.</p> <ul> <li><code>WidgetDataModel</code>: The current window's data.</li> <li><code>TabArea</code>: The current tab area.</li> <li><code>SubWindow</code>: The current sub-window.</li> <li><code>MainWindow</code>: The main window.</li> <li><code>ClipboardDataModel</code>: The clipboard data.</li> </ul> <p>And here are the list of return types that will be processed.</p> <ul> <li><code>WidgetDataModel</code>: The returned value will be added to the current tab.</li> <li><code>list[WidgetDataModel]</code>: Each item will be added to the current tab.</li> <li><code>Parametric</code>: The returned function will be converted into a GUI for user input of   parameters (see here).</li> <li><code>ClipboardDataModel</code>: The returned data will overwrite the system clipboard.</li> <li><code>WidgetConstructor</code>: The returned function will be executed to add a new sub-window with the constructed widget.</li> <li><code>concurrent.Future</code>: The returned job will be executed asynchronously.</li> </ul> <p>A problem of the example above is that the <code>model</code> argument may contain any type of data (not only <code>\"text\"</code>-type data). To narrow the type of data, you can use the <code>types</code> argument of the <code>register_function()</code> decorator.</p> <pre><code>from himena.consts import StandardType\n\n@register_function(\n    title=\"Format JSON Text\",\n    types=[StandardType.TEXT],\n)\ndef format_json(model: WidgetDataModel) -&gt; WidgetDataModel:\n    ...\n</code></pre> <p>With this, the \"Format JSON Text\" menu will be enabled only if the current window is a widget for <code>\"text\"</code>-type data. Another benefit is that this command will be added to the model menu of the <code>\"text\"</code>-type widget.</p>"},{"location":"dev/register_functions/#place-the-function-in-any-places-in-menu-bar","title":"Place the Function in Any Places in Menu Bar","text":"<p>The place to put the function in the menu bar can be specified by the <code>menus</code> argument of the <code>register_function()</code> decorator. Each menu is specified by a \"/\"-separated string identifier. Following is an example that puts the function in the \"my-plugins &gt; my-text-plugins\" menu.</p> <pre><code>from himena import WidgetDataModel, StandardType\nfrom himena.plugins import register_function\n\n@register_function(\n    title=\"Format JSON Text\",\n    types=[StandardType.TEXT],\n    menus=[\"my-plugins/my-text-plugins\"],\n)\ndef format_json(model: WidgetDataModel) -&gt; WidgetDataModel:\n    ...\n</code></pre> <p>To define how to display the menu title, you can use <code>configure_submenu()</code>.</p> <pre><code>from himena.plugins import configure_submenu\n\nconfigure_submenu(\"my-plugins\", title=\"My Plugins\")\nconfigure_submenu(\"my-plugins/my-text-plugins\", title=\"My Text Plugins\")\n</code></pre> <p>If a menu has many items, it is better to group them. You can use the <code>group</code> argument of <code>configure_submenu()</code> for this purpose. Groups are sorted alphabetically, so it is a good idea to prefix the group name with a number to control the order.</p> <pre><code>configure_submenu(\n    \"my-plugins/my-text-plugins\",\n    title=\"My Text Plugins\",\n    group=\"00_process-text\",\n)\n</code></pre>"},{"location":"dev/register_functions/#parametric-functions","title":"Parametric Functions","text":"<p>Many functions require user parameter inputs. It is very easy to implement a parametric function in Python: just add more arguments to the function. However, implementing parametric functions in GUI is usually tedious, as you need to create a specific widget for every function.</p> <p><code>himena</code> uses <code>magicgui</code> package to convert a function with parameters into a GUI widget based on the type hints of the function. Therefore, you can easily register a parametric function just by returning a function that takes parameters.</p> <p>To tell <code>himena</code> that the returned value should be converted into a GUI for user input of parameters, you need to annotate the returned value with the <code>Parametric</code> type.</p> <pre><code>from himena.plugins import register_function\nfrom himena import Parametric, StandardType, WidgetDataModel\n\n@register_function(\n    title=\"Format JSON Text\",\n    types=[StandardType.TEXT],\n)\ndef format_json(model: WidgetDataModel) -&gt; Parametric:\n    def run_format_json(indent: int = 4):\n        value = json.dumps(json.loads(model.value), indent=indent)\n        return WidgetDataModel(value=value, type=\"text\")\n    return run_format_json\n</code></pre> <p>The type-to-widget mapping is as follows:</p> <ul> <li><code>int</code>, <code>float</code>, <code>str</code>, <code>list[int]</code>, <code>list[float]</code> \u2192 Line edit with the   corresponding type.</li> <li><code>bool</code> \u2192 Toggle switch.</li> <li><code>enum.Enum</code>, <code>typing.Literal</code> \u2192 Combo box with the choices.</li> <li><code>pathlib.Path</code> \u2192 Entry with a file dialog button.</li> <li><code>tuple</code> \u2192 Group box with the corresponding types.</li> <li><code>WidgetDataModel</code>, <code>list[WidgetDataModel]</code>, <code>SubWindow</code>, <code>list[SubWindow]</code>   \u2192 Drop area that can drop other sub-windows to provide the corresponding data.</li> </ul> <p>Serialization</p> <p>The input parameters should be serializable for workflow recording. Although <code>magicgui</code> can support various type-to-widget mapping, the input values are restricted to those that can be serialized by <code>himena</code>. For example, <code>slice</code> and <code>range</code> objects are not supported as input types in <code>himena</code>.</p>"},{"location":"dev/register_functions/#configure-parameter-input-window","title":"Configure Parameter Input Window","text":"<p>The parameter input window is automatically generated by <code>magicgui</code>. You can further customize its appearance and GUI properties by <code>configure_gui()</code> decorator.</p> <pre><code>from himena.plugins import register_function, configure_gui\nfrom himena import Parametric, StandardType, WidgetDataModel\n\n@register_function(\n    title=\"Format JSON Text\",\n    types=[StandardType.TEXT],\n)\ndef format_json(model: WidgetDataModel) -&gt; Parametric:\n    @configure_gui(indent={\"label\": \"Indent in Spaces\", \"min\": 0, \"max\": 8})\n    def run_format_json(indent: int = 4):\n        value = json.dumps(json.loads(model.value), indent=indent)\n        return WidgetDataModel(value=value, type=\"text\")\n    return run_format_json\n</code></pre> <p><code>configure_gui</code> takes keyword arguments that are passed to the function it decorates, and use <code>dict</code> to configure the widget used for the parameter input.</p> <p>Here's some of the options you can use.</p> <ul> <li><code>label</code>: The label of the input field.</li> <li><code>value</code>: The default value.</li> <li><code>choices</code>: List of choices.</li> <li><code>widget_type</code>: Widget class to use. This option must be a <code>magicgui</code> ValueWidget.</li> <li><code>min</code>: The minimum value (if applicable).</li> <li><code>max</code>: The maximum value (if applicable).</li> </ul> <p>Note</p> <p>To avoid argument name collision, you can pass the options as a dict to <code>gui_options</code>.</p> <pre><code>@configure_gui(\n    gui_options={\"indent\": {\"label\": \"Indent in Spaces\", \"min\": 0, \"max\": 8}},\n)\ndef run_format_json(indent: int = 4):\n    ...\n</code></pre>"},{"location":"dev/register_functions/#bind-values-to-parameter-input","title":"Bind Values to Parameter Input","text":"<p>Some parameters are better to be retrieved from the input sub-window. For example, if a function counts the number of \"a\"s in a subset of a text, the user may want to select the text in the sub-window and pass the selected range to the function instead of requesting a range (int, int) using a parameter input.</p> <p>The \"bind\" option of <code>magicgui</code> is very useful for this purpose. The value passed to the \"bind\" option will be directly used as the value for the parameter. Because the selected range is available in the <code>TextMeta</code> metadata as the <code>selection</code> property, you can define a function as follows.</p> <pre><code>from himena.plugins import register_function, configure_gui\nfrom himena import Parametric, StandardType, WidgetDataModel\n\n@register_function(\n    title=\"Count 'a'\",\n    types=[StandardType.TEXT],\n)\ndef count_a(model: WidgetDataModel) -&gt; Parametric:\n    @configure_gui(text_range={\"bind\": model.metadata.selection})\n    def run_count_a(text_range: tuple[int, int]):\n        start, end = text_range\n        print(model.value[start:end].count(\"a\"))\n    return run_count_a\n</code></pre> <p>This function does not have any parameter that can be specified by the user, thus no parameter input widget will be shown. The function will be immediately called when the command menu is clicked.</p> <p>If the function has other parameters that do not have bound values, the parameter input widget will be shown as usual.</p> <pre><code>from himena.plugins import register_function, configure_gui\nfrom himena import Parametric, StandardType, WidgetDataModel\n\n@register_function(\n    title=\"Count 'a'\",\n    types=[StandardType.TEXT],\n)\ndef count_a_2(model: WidgetDataModel) -&gt; Parametric:\n    @configure_gui(text_range={\"bind\": model.metadata.selection})\n    def run_count_a(text_range: tuple[int, int], case_sensitive: bool = False):\n        start, end = text_range\n        if not case_sensitive:\n            text = model.value[start:end].lower()\n        else:\n            text = model.value[start:end]\n        print(text.count(\"a\"))\n    return run_count_a\n</code></pre> Why do we ever need to bind values? <p>You may ask why don't we just directly use <code>model.metadata.selection</code> inside the registered function, instead of returning a function to make the command parametric.</p> <pre><code>@register_function(\n    title=\"Count 'a'\",\n    types=[StandardType.TEXT],\n)\ndef count_a(model: WidgetDataModel):\n    start, end = model.metadata.selection\n    print(model.value[start:end].count(\"a\"))\n</code></pre> <p>A benefit of using a parametric function is that the function becomes reproducible. When the function is re-executed from a workflow, the input text edit does not necessarily in the same state as when the function was executed. In the example above, the text selection range is not likely to be the same, so that you will get a different result.</p> <p>In general, all the information in the <code>metadata</code> property should not be directly used in commands; they should always be passed as \"bind\" options.</p>"},{"location":"dev/register_functions/#preview-function-outputs","title":"Preview Function Outputs","text":"<p>In some cases, parameters should be tuned based on the output of the function. For example in the case of the <code>format_json</code> function, the user may want to see the output so that the json string looks good. To add a \"preview\" toggle button to the parameter input window, just add the <code>preview</code> argument to the <code>configure_gui()</code> decorator.</p> <pre><code>@register_function(\n    title=\"Format JSON Text\",\n    types=[StandardType.TEXT],\n)\ndef format_json(model: WidgetDataModel) -&gt; Parametric:\n    @configure_gui(preview=True)\n    def run_format_json(indent: int = 4):\n        value = json.dumps(json.loads(model.value), indent=indent)\n        return WidgetDataModel(value=value, type=\"text\")\n    return run_format_json\n</code></pre> <p></p>"},{"location":"dev/register_functions/#asynchronous-execution","title":"Asynchronous Execution","text":"<p>It is also very easy to make your function asynchronous (make the application responsive during the execution). Just add the <code>run_async=True</code> argument to the <code>register_function()</code> decorator.</p> <pre><code>@register_function(\n    title=\"Format JSON Text\",\n    types=[StandardType.TEXT],\n    run_async=True,\n)\ndef format_json(model: WidgetDataModel) -&gt; Parametric:\n    def run_format_json(indent: int = 4):\n        value = json.dumps(json.loads(model.value), indent=indent)\n        return WidgetDataModel(value=value, type=\"text\")\n    return run_format_json\n</code></pre> <p>Do not update the GUI from an asynchronous function</p> <p>You should not update the GUI from an asynchronous function, because it can only be updated in the main thread.</p> This function crashes the application<pre><code>@register_function(\n    title=\"Add widget\",\n    run_async=True,\n)\ndef add_widget(ui: MainWindow):\n    ui.add_widget(QtW.QLabel(\"Hello, world!\"))\n</code></pre>"},{"location":"dev/register_functions/#functions-that-only-works-in-a-specific-widget","title":"Functions That Only Works in A Specific Widget","text":"<p>If you know that the function only works in a specific widget <code>T</code>, you can use the annotation <code>SubWindow[T]</code>. This command will only be enabled when the current sub-window is built with the widget <code>T</code>.</p> <p>For example, the following built-in plugin function only works for the <code>QImageView</code> widget.</p> <pre><code>@register_function(\n    title=\"Scale bar ...\",\n    ...,\n)\ndef setup_image_scale_bar(win: SubWindow[QImageView]) -&gt; Parametric:\n    ...\n</code></pre>"},{"location":"dev/register_widgets/","title":"Register Widgets","text":"<p>In this section, you will learn how to define and register custom widgets for specific data types.</p>"},{"location":"dev/register_widgets/#protocols","title":"Protocols","text":"<p>To avoid the potential dangers of metaclass collision and method collision, <code>himena</code> do not use a super class to define plugin widgets. Instead, your plugin widgets have to implement protocols (methods with correct name and arguments) to enable the communication between the plugin and the main application.</p> Check misspelling <p>Because the plugin widgets do not inherit anything like plugin classes, you have to be careful not to misspell the method name. To check if the method name is correct, you can decorate the protocol methods with <code>validate_protocol</code> decorator.</p> <pre><code>from himena.plugins import validate_protocol\n\nclass MyWidget:\n    @validate_protocol\n    def udpate_model(self, model):  # misspelled, raises error\n        ...\n</code></pre> <p>All the protocols are optional except for <code>update_model</code>, which is called when the widget is constructed from a data model. To make the plugin better, you should implement as many protocols as possible.</p>"},{"location":"dev/register_widgets/#compatibility-with-widgetdatamodel-standard","title":"Compatibility with <code>WidgetDataModel</code> Standard","text":"<p>To make the plugin widgets compatible with the <code>WidgetDataModel</code> standard that is used everywhere in <code>himena</code>, you have to implement the following protocols:</p> <ul> <li><code>update_model(self, model: WidgetDataModel) -&gt; None</code>: Update the widget state based   on the model.</li> <li><code>to_model(self) -&gt; WidgetDataModel</code>: Return the model that represents the current   state of the widget.</li> <li><code>model_type(self) -&gt; str</code>: Return the type of the model that the widget uses. Model   type is frequently checked in many occasions, so you should implement this method if   <code>to_model</code> is computationally expensive.</li> <li><code>update_value(self, value: Any) -&gt; None</code>: Update the widget state based on the value   without changing the states that are described by the <code>metadata</code> field of the   <code>WidgetDataModel</code>. This method is preferentially called by the <code>update_value</code> method   of <code>SubWindow</code> class.</li> </ul>"},{"location":"dev/register_widgets/#control-widget","title":"Control Widget","text":"<p>The control widget is a widget that is added to the tool bar of the main window to make the sub-window area tidy. This widget can be defined by implementing the following protocol.</p> <ul> <li><code>control_widget(self) -&gt; &lt;backend widget type&gt;</code>: Construct and return the control   widget.</li> </ul> <p>The return type must be interpretable by the backend GUI library. For example, if your plugin widget is implemented using <code>Qt</code>, the return type should be a <code>QWidget</code> object as well.</p>"},{"location":"dev/register_widgets/#use-wrapper-class","title":"Use Wrapper Class","text":"<p>Python already has a lot of libraries that wrap other GUI libraries to provide better interface. In <code>himena</code>, you can directly use these wrapper classes and implement all the protocols on the wrapper class. In this case, you will have to tell where the backend widget is located, which can be done by implementing the following protocol.</p> <ul> <li><code>native_widget(self) -&gt; &lt;backend widget type&gt;</code>: Return the backend widget that is   wrapped by the wrapper class.</li> </ul>"},{"location":"dev/register_widgets/#widget-interactivity","title":"Widget Interactivity","text":"<p>Widgets can be interactively modified by the user. To change the interactivity, or to programmatically mark the widget as modified, you can implement the following protocols.</p> <ul> <li><code>is_editable(self) -&gt; bool</code>: Return whether the widget is editable or not.</li> <li><code>set_editable(self, editable: bool) -&gt; None</code>: Set the widget editable or not.</li> <li><code>is_modified(self) -&gt; bool</code>: Return whether the underlying data is modified or not.</li> <li><code>set_modified(self, modified: bool) -&gt; None</code>: Set the modified state of the widget.</li> </ul>"},{"location":"dev/register_widgets/#response-to-the-gui-events","title":"Response to the GUI Events","text":"<p>Sometimes your widget needs to catch the GUI events to update the widget state.</p> <ul> <li><code>theme_changed_callback(self, theme: Theme) -&gt; None</code>: Called when the theme of the   application is changed. The <code>Theme</code> object is a data class that contains the color   theme of the application.</li> <li><code>widget_added_callback(self) -&gt; None</code>: Called when the sub-window containing this   widget is added to the main window.</li> <li><code>widget_activated_callback(self) -&gt; None</code>: Called when the sub-window containing this   widget is activated (clicked or focus).</li> <li><code>widget_closed_callback(self) -&gt; None</code>:  Called when the sub-window containing this   widget is closed.</li> <li><code>widget_resized_callback(self, old_size: Size, new_size: Size) -&gt; None</code>: Called when   the sub-window containing this widget is resized from the old size to a new size.   <code>Size</code> is a tuple like object with <code>width</code> and <code>height</code> fields.</li> </ul>"},{"location":"dev/register_widgets/#drag-and-drop","title":"Drag and Drop","text":"<p>Drag-and-drop operation is handled using <code>DragDataModel</code>.</p> <ul> <li><code>dropped_callback(self, model: DragDataModel) -&gt; None</code>: Callback method when an item   is dropped on the widget.</li> <li><code>allowed_drop_types(self) -&gt; list[str]</code>: List of types that the widget accepts.</li> </ul>"},{"location":"dev/register_widgets/#widget-appearance","title":"Widget Appearance","text":"<ul> <li><code>size_hint(self) -&gt; tuple[int, int]</code>: Return the size hint of the widget. This method   is called when the widget is added to the main window.</li> <li><code>default_title(self) -&gt; str</code>: Return the default title of the widget. This method is   called when the widget is added to the main window without specifying the title.</li> </ul>"},{"location":"dev/register_widgets/#register-the-widget","title":"Register the Widget","text":"<pre><code>from qtpy import QtWidgets as QtW\nfrom himena.plugins import validate_protocol\n\nclass MyWidget(QtW.QTextEdit):\n    def __init__(self):\n        super().__init__()\n\n    @validate_protocol\n    def update_model(self, model):\n        assert model.type == \"text\"\n        self.setPlainText(model.value)\n\n    @validate_protocol\n    def to_model(self):\n        return WidgetDataModel(value=self.toPlainText(), type=\"text\")\n\n    @validate_protocol\n    def size_hint(self):\n        return 400, 300\n</code></pre> <p>Once you have implemented the protocols like above, you can register the widget class using the <code>register_widget_class</code> function.</p> <pre><code>from himena import StandardType\nfrom himena.plugins import register_widget_class\n\nregister_widget_class(StandardType.TEXT, MyWidget)\n</code></pre> <p>The first argument is the type of the data the widget class is supposed to handle. Whenever the application is requested to add a data model of that type, this widget will be constructed like below:</p> <pre><code>widget = MyWidget()\nwidget.update_model(model)\n</code></pre> <p>and added to the main window inside a sub-window.</p> Register function instead of class <p>Because what is done here is just calling the constructor of the widget class, the object registered by the <code>register_widget_class</code> function does not have to be a class. You can also register a function that returns the widget object.</p> <pre><code>def create_widget():\n    return MyWidget()\n\nregister_widget_class(StandardType.TEXT, create_widget)\n</code></pre> <p>This is useful when you want to execute the file that defines the widget class lazily, in order to reduce the startup time of the application.</p>"},{"location":"dev/widget_data_model/","title":"The WidgetDataModel Standard","text":"<p>All the widgets in <code>himena</code> are built on the <code>WidgetDataModel</code> standard. A <code>WidgetDataModel</code> is a Python object that represents a value of any type, tagged with some additional information of how to interpret the value in GUI. For example, a text data \"xyz\" read from a txt file can be written as follows:</p> <pre><code>WidgetDataModel(value=\"abc\", type=\"text\")\n</code></pre> <p>All the \"data-embedded\" widgets in <code>himena</code> implements <code>update_model()</code> method to update the state of the widget from a <code>WidgetDataModel</code> object, and <code>to_model()</code> method to dump the state of the widget to a <code>WidgetDataModel</code> object.</p> <pre><code>class TextViewer:\n    def __init__(self):\n        # some GUI-specific initialization ...\n\n    def update_model(self, model: WidgetDataModel):\n        self.set_text(model.value)  # (1)!\n\n    def to_model(self) -&gt; WidgetDataModel:\n        return WidgetDataModel(value=self.get_text(), type=\"text\")  # (2)!\n</code></pre> <p>(1) The incoming text data is stored in <code>model.value</code>. The <code>set_text()</code> method is just     an example. (2) A <code>WidgetDataModel</code> must be returned here. The \"text\" type is the standard type     string for the string-type text data.</p> <p>This widget can be registered as a widget that represents a <code>\"text\"</code>-type data using <code>register_widget_class()</code> function.</p> <pre><code>from himena.plugins import register_widget_class\n\nregister_widget_class(\"text\", widget_class=TextViewer)\n</code></pre> <p>The <code>WidgetDataModel</code> standard makes the different part of development very clear-cut.</p> <ul> <li> <p>Reader function is a GUI-independent function that reads a file and returns   a <code>WidgetDataModel</code>.</p> Example reader function<pre><code>def read_txt(file_path: Path) -&gt; WidgetDataModel:\n    text_value = file_path.read_text()\n    return WidgetDataModel(value=text_value, type=\"text\")\n</code></pre> <p>A proper widget class will be automatically selected based on the <code>type</code> field, and updated based on the returned model using <code>update_model()</code> method.</p> </li> <li> <p>Writer function is a GUI-independent function that writes a <code>WidgetDataModel</code>   to a file.</p> Example writer function<pre><code>def write_text(file_path: Path, model: WidgetDataModel):\n    file_path.write_text(model.value)\n</code></pre> <p>A widget will be automatically converted to a model using <code>to_model()</code> method before calling this writer function.</p> </li> <li> <p>Any function for data processing or analysis is also GUI-independent functions   that just convert a <code>WidgetDataModel</code> into another.</p> Example data processing function<pre><code>def to_upper(model: WidgetDataModel) -&gt; WidgetDataModel:\n    assert isinstance(model.value, str)\n    return WidgetDataModel(value=model.value.upper(), type=\"text\")\n</code></pre> <p>A widget will be automatically converted to a model using <code>to_model()</code> method before calling this function, and sent back to the GUI as another widget created based on the returned model.</p> </li> </ul>"},{"location":"dev/widget_data_model/#to-summarize","title":"To summarize","text":"<p>Let's say you intend to read a text file, convert it into a table and save it to the local disk.</p> <p></p> <ul> <li>If you are a user, you will not see the \"memory\" layer. You will open the text file   (1, 2), run the command to convert it to a table (3, 4, 5), and save the table to the   local disk (6, 7).</li> <li>If you are a plugin developer, you will implement the reader function (1), the text   editor widget with the proper protocols (2, 3), the converter function (4), the table   viewer widget with the proper protocols (5, 6), and the writer function (7).</li> </ul> <p>It is interesting to note that what plugin developers do are always half step behind what users do.</p>"},{"location":"dev/widget_data_model/#choosing-the-type","title":"Choosing the Type","text":"<p>You can use any string for <code>type</code> field, but to make your widget interpretable for the <code>himena</code> built-in functions and probably for other plugins, you may want to use the <code>StandardType</code>.</p> <pre><code>from himena.const import StandardType\n\nStandardType.TEXT  # \"text\"\nStandardType.TABLE  # \"table\"\nStandardType.ARRAY  # \"array\"\nStandardType.IMAGE  # \"array.image\"\n</code></pre> The list of the pre-defined standards <p>Basic types</p> String type Constant Internal Python object type <code>\"text\"</code> <code>StandardType.TEXT</code> <code>str</code> <code>\"table\"</code> <code>StandardType.TABLE</code> <code>ndarray</code> of <code>np.dtypes.StringDType</code> <code>\"array\"</code> <code>StandardType.ARRAY</code> array-like object of numerical dtype <code>\"dataframe\"</code> <code>StandardType.DATAFRAME</code> Any dataframe-like object such as <code>dict[str, ndarray]</code>, <code>pandas.DataFrame</code> and <code>polars.DataFrame</code> <code>\"dict\"</code> <code>StandardType.DICT</code> <code>dict[str, T]</code>, where T is any type <code>\"plot\"</code> <code>StandardType.PLOT</code> <code>himena.standard.plotting.BaseLayoutModel</code> object <code>\"rois\"</code> <code>StandardType.ROIS</code> <code>himena.standard.roi.RoiListModel</code> object <code>\"matplotlib-figure\"</code> <code>StandardType.MPL_FIGURE</code> <code>matplotlib.Figure</code> object <code>\"mesh\"</code> <code>StandardType.MESH</code> tuple of vertices, faces and values <code>\"models\"</code> <code>StandardType.MODELS</code> <code>list[WidgetDataModel]</code> <code>\"function\"</code> <code>StandardType.FUNCTION</code> any callable object <code>\"lazy\"</code> <code>StandardType.LAZY</code> callable <code>() -&gt; WidgetDataModel</code> <code>\"workflow\"</code> <code>StandardType.WORKFLOW</code> <code>himena.workflow.Workflow</code> object <p>Subtypes</p> <p>|<code>\"array.image\"</code>   |<code>StandardType.IMAGE</code>     | array-like object of numerical dtype    | |<code>\"array.image.labels\"</code>|<code>StandardType.IMAGE_LABELS</code>| array-like object of integer dtype| |<code>\"dict.table\"</code>|<code>StandardType.EXCEL</code>| <code>dict[str, ndarray]</code>, where the dtype of the array is <code>np.dtypes.StringDType</code>|</p> <p>You can use \".\" to separate the type into a hierarchy. For example, the standard type <code>\"array.image\"</code> is used for an image data, but it is under \"array\" type because all the image data are essentially arrays. A benefit of this subtyping is that all the \"array\" functions can be applied to the \"array.image\" data.</p>"},{"location":"dev/widget_data_model/#more-specifications","title":"More Specifications","text":"<p>You can set other fields of <code>WidgetDataModel</code> to provide more details of how to convert the data to a widget.</p> <pre><code>WidgetDataModel(\n    value=\"abc\",\n    type=\"text\",\n    title=\"My Text\"  # title of the widget\n    extension_default=\".txt\",  # default file extension in the save dialog\n    extensions=[\".txt\", \".md\"]  # allowed file extensions in the save dialog\n)\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>In this section, you will learn the more details of the <code>himena</code> application.</p> <ul> <li>Basics</li> <li>Tab/Window Manipluation</li> <li>Workflows</li> <li>Sessions</li> <li>Built-in Widgets</li> </ul>"},{"location":"usage/basics/","title":"Basics","text":""},{"location":"usage/basics/#application-design","title":"Application Design","text":""},{"location":"usage/basics/#appearance","title":"Appearance","text":"<p><code>himena</code> GUI has components as shown below.</p> <p></p> <ol> <li>Menu bar. It contains most of the registered commands in the application.</li> <li>Tool bar. It contains frequently used commands.</li> <li>Tab bar. Each tab contains a sub-window area where widgets are placed.</li> <li>Sub-window. Each sub-window contains a widget as its content.</li> <li>Control widget. Each widget has a control widget that provides functionalities    specific to the widget.</li> <li>Python interpreter console. A console widget that can execute Python codes.</li> <li>Dock widget. Widgets docked to the main window. These widgets are usually added    by plugins. The Python interpreter console is also a dock widget.</li> <li>Status bar. It shows simple one-line messages.</li> </ol>"},{"location":"usage/basics/#sub-window","title":"Sub-window","text":"<p>A sub-window usually represents a single data, such as a <code>ndarray</code> or <code>DataFrame</code>. Therefore, data processing is usually done by taking sub-windows as input and output.</p> <p></p> <p>Each data is wrapped by a <code>WidgetDataModel</code> object, which is tagged with some GUI-related information, so that the application understands how to display, save and track the data.</p> <p>In the Python interpreter console (Ctrl+Shift+C), variable <code>ui</code> is available as the handler of the main window.</p> <pre><code>from himena.types import WidgetDataModel\nimport numpy as np\n\ndata = WidgetDataModel(value=np.arange(10), type=\"array\", title=\"my array\")  # (1)!\nwin = ui.add_data_model(data)  # (2)!\n</code></pre> <ol> <li>Create a WidgetDataModel object. To interpret the data as an array, set the <code>type</code>     attribute to <code>\"array\"</code>.</li> <li>Add the data model to the application as a sub-window.</li> </ol> <p>More simply, you can just call <code>ui.add_object</code> method to directly add an object to the application.</p> <pre><code>win = ui.add_object(np.arange(10), type=\"array\", title=\"my array\")\n</code></pre> <p>Data can be retrieved from the sub-window by calling <code>to_model</code> method.</p> <pre><code>win.to_model()\n</code></pre> Output<pre><code>WidgetDataModel(value=&lt;ndarray&gt;, source=None, type='array', title='my array')\n</code></pre> <p><pre><code>win.to_model().value\n</code></pre> Output<pre><code>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n</code></pre></p>"},{"location":"usage/basics/#opening-and-saving-files","title":"Opening and Saving Files","text":""},{"location":"usage/basics/#new-file","title":"New file","text":"<p>Press Ctrl+N and you will see a command palette pops up. This palette contains many commands that are related to adding new items to the application. This category includes</p> <ul> <li>Empty window, such as a text or table.</li> <li>Opening a sample data.</li> </ul> <p>For example, the \"New Text\" command will add a new text editor sub-window to the current tab.</p>"},{"location":"usage/basics/#open-files-from-the-local-disk","title":"Open files from the local disk","text":"<p><code>himena</code> supports several ways to open files from the local disk.</p>"},{"location":"usage/basics/#1-open-a-file-as-a-sub-window","title":"(1) Open a file as a sub-window","text":"<p>This is the most common way to open a file. You can open a file from \"File\" menu press Ctrl+O or drag-and-drop the file to the application.</p> <p>Whether the file can be opened, and the opened data can be displayed as a widget, depends on the plugins installed in the application profile. For example, <code>himena</code> built-in readers cannot open TIFF files, but a TIFF reader is available in the <code>himena-image</code> plugin.</p> Data analysis without widget plugin <p>If <code>himena</code> cannot find a widget to represent the data that has just been read, you will see a widget saying \"No widget registered for ...\". This does not mean <code>himena</code> cannot read the data. You just don't have a \"nice\" way to visualize the data. You can still use the internal data model in the application.</p>"},{"location":"usage/basics/#2-open-a-folder-as-a-sub-window","title":"(2) Open a folder as a sub-window","text":"<p>A special built-in widget can display a list of <code>WidgetDataModel</code> as a nested widget. Opening a folder will read the folder contents as a collection like below. This command is available from the \"File\" menu, Ctrl+K \u2192 Ctrl+O, or drag-and-drop the folder to the application.</p> <p></p>"},{"location":"usage/basics/#3-open-a-group-of-files-as-a-sub-window","title":"(3) Open a group of files as a sub-window","text":"<p>Instead of opening a folder, you can open a group of files as a sub-window just like (2).</p>"},{"location":"usage/basics/#saving-files-to-the-local-disk","title":"Saving files to the local disk","text":"<p>You can save the data in the sub-window to the local disk by selecting \"File\" \u2192 \"Save\" or pressing Ctrl+S. Whether the data can be saved to the specified format depends on the plugins installed in the application profile.</p>"},{"location":"usage/basics/#data-processing","title":"Data Processing","text":"<p>Most of the functions for data processing are defined by functions that take a <code>WidgetDataModel</code> as the input and another <code>WidgetDataModel</code> as the output.</p> <p>For example, starting from the data below</p> <pre><code>df = {\"a\": [2, 3, 5], \"b\": [1.3, 3.2, -1.2]}\nui.add_object(df, type=\"dataframe\")\n</code></pre> <p>you can find \"Filter DataFrame ...\" command in the model menu. This command will open a window for the parameter input, filter the data frame and show the result in a new sub-window.</p> <p></p> <p>The history of the data processing is recorded to the <code>WidgetDataModel</code>. You can open it from the \"Show workflow graph\" command in the window menu.</p> <p></p> <p>Note</p> <p>The workflow is just a <code>WidgetDataModel</code> with type <code>\"workflow\"</code>. Therefore, this operation is just a data processing like any other operations.</p>"},{"location":"usage/basics/#adding-custom-widgets","title":"Adding Custom Widgets","text":"<p>Currently, <code>himena</code> supports <code>Qt</code> as its GUI backend. Any <code>Qt</code> widgets can be added to the application using <code>add_widget()</code> method.</p> <pre><code>from qtpy.QtWidgets import QLabel\n\nlabel = QLabel(\"Hello, world!\")\nui.add_widget(label, title=\"My Label\")\n</code></pre> <p>If you have a widget wrapper of a <code>Qt</code> widget, it can also be added by defining the <code>native_widget()</code> interface method.</p> <pre><code>class MyLabel:\n    def __init__(self, text):\n        self._qt_label = QLabel(text)\n\n    def native_widget(self):\n        return self._qt_label\n\nlabel = MyLabel(\"Hello, world!\")\nui.add_widget(label, title=\"My Label Wrapper\")\n</code></pre> Using <code>magicgui</code> <p>Because <code>himena</code> depends on <code>magicgui</code> in many places, <code>magicgui</code> widgets can be directly used without the <code>native_widget()</code> method.</p> <pre><code>from magicgui import magicgui\n\n@magicgui\ndef my_func(x: int, y: str):\n    print(x, y)\n\nui.add_widget(my_func, title=\"My MagicGUI\")\n</code></pre> <p>Alternatively, you can add the widget as a dock widget using <code>add_dock_widget()</code>.</p> <pre><code>label = MyLabel(\"Hello, world!\")\nui.add_dock_widget(label, title=\"My Label Dock Widget\")\n</code></pre> <p>These rules also apply to the widget plugin system. See here for more details.</p>"},{"location":"usage/builtin_dock_widgets/","title":"Built-in Dock Widgets","text":"<p>The dock widget actions implemented in <code>himena_builtins</code> are listed under the \"Tools &gt; Dock Widgets\" menu.</p>"},{"location":"usage/builtin_dock_widgets/#python-interpreter-console","title":"Python Interpreter Console","text":"<p>This widget is for running Python code interactively. The widget uses the Jupyter QtConsole widget.</p> <p></p>"},{"location":"usage/builtin_dock_widgets/#file-explorer","title":"File Explorer","text":"<p>This widget is for browsing files and directories. You can open files by double-clicking the item, or drag-and-drop files to the main window area.</p> <p></p>"},{"location":"usage/builtin_dock_widgets/#remote-file-explorer-ssh","title":"Remote File Explorer (SSH)","text":"<p>This widget makes it easier to browse files on a remote server using <code>ssh</code>, and transfer files between the local and remote machines using either <code>scp</code> or <code>rsync</code>.</p> <p></p> <p>Tip</p> <p>This remote file explorer is compatible with the local file explorer dock widget. You can directly drag-and-drop files between these file explorers to send files.</p>"},{"location":"usage/builtin_dock_widgets/#command-history","title":"Command History","text":"<p>This widget shows the history of commands that have been executed since the start of the application. You can also re-run commands from this widget.</p> <p></p>"},{"location":"usage/builtin_dock_widgets/#output-widget","title":"Output Widget","text":"<p>This widget shows the standard output stream and the logging messages.</p> <p></p>"},{"location":"usage/builtin_widgets/","title":"Built-in Widgets","text":"<p><code>himena</code> provides <code>himena_builtins</code> plugin package for the most basic widgets for the widely-used data types.</p> <p>Note</p> <p>The detailed description of the widgets are available by running the \"what is this widget?\" command in the window menu.</p>"},{"location":"usage/builtin_widgets/#text-editor-widget","title":"Text Editor Widget","text":"<p>A text widget is simply used to display and edit a text data. Optionally, you can specify the language of the text data to enable syntax highlighting.</p> Specification widget class <code>himena_builtins.qt.widgets.QTextEdit</code> model type <code>\"text\"</code> (<code>StandardType.TEXT</code>) data type <code>str</code> <p></p> <pre><code>from himena.standards.model_meta import TextMeta\n\nui.add_object(\n    \"import numpy as np\\n\\nprint(np.arange(10))\",\n    type=\"text\",\n    title=\"Text Data\",\n    metadata=TextMeta(language=\"python\")\n)\n</code></pre>"},{"location":"usage/builtin_widgets/#spreadsheet-widget","title":"Spreadsheet Widget","text":"<p>A spreadsheet widget is used to display and edit a table data. All the items are stored as strings, so that numerical operations on this widget are not very efficient.</p> Specification widget class <code>himena_builtins.qt.widgets.QSpreadsheet</code> model type <code>\"table\"</code> (<code>StandardType.TABLE</code>) data type <code>ndarray</code> of string dtype <p></p> <pre><code>ui.add_object(\n    [[\"key\", \"value\"], [\"name\", \"Alice\"], [\"age\", 20]],\n    type=\"table\",\n    title=\"Table Data\"\n)\n</code></pre>"},{"location":"usage/builtin_widgets/#dataframe-viewer-widget","title":"DataFrame Viewer Widget","text":"<p>A dataframe viewer widget is used to display a dataframe-like object. Unlike a spreadsheet widget, the underlying data is structured and typed.</p> Specification widget class <code>himena_builtins.qt.widgets.QDataFrameView</code> model type <code>\"dataframe\"</code> (<code>StandardType.DATAFRAME</code>) data type dataframe-like object, such as <code>dict[str, list]</code>, <code>pandas.DataFrame</code>, <code>polars.DataFrame</code> <p></p> <pre><code>ui.add_object(\n    {\n        \"kind\": [\"cat\", \"dog\", \"cat\", \"dog\", \"cat\", \"dog\", \"cat\", \"dog\"],\n        \"size\": [\"small\", \"small\", \"large\", \"large\", \"small\", \"small\", \"large\", \"large\"],\n        \"weight\": [8, 10, 12, 15, 11, 13, 9, 14],\n    },\n    type=\"dataframe\",\n    title=\"DataFrame Data\",\n)\n</code></pre>"},{"location":"usage/builtin_widgets/#dataframe-plot-widget","title":"DataFrame Plot Widget","text":"<p>A dataframe plot widget contains a dataframe-like object just like a dataframe viewer, but the data is supposed to be plotted. Therefore, non-numerical columns are not allowed.</p> Specification widget class <code>himena_builtins.qt.widgets.QDataFramePlotView</code> model type <code>\"dataframe.plot\"</code> (<code>StandardType.DATAFRAME_PLOT</code>) data type dataframe-like object, such as <code>dict[str, list]</code>, <code>pandas.DataFrame</code>, <code>polars.DataFrame</code> <p></p> <pre><code>import numpy as np\n\nx = np.linspace(0, 10, 100)\nui.add_object(\n    {\n        \"x\": x,\n        \"y1\": np.sin(x),\n        \"y2\": np.cos(x) * 1.4,\n    },\n    type=\"dataframe.plot\",\n    title=\"DataFrame Plot Data\",\n)\n</code></pre>"},{"location":"usage/builtin_widgets/#array-viewer-widget","title":"Array Viewer Widget","text":"<p>This widget is used to display a multi-dimensional array-like object.</p> Specification widget class <code>himena_builtins.qt.widgets.QArrayView</code> model type <code>\"array\"</code> (<code>StandardType.ARRAY</code>) data type array-like object, such as <code>numpy.ndarray</code>, <code>xarray.DataArray</code>, <code>dask.Array</code> <p></p> <pre><code>import numpy as np\n\nrng = np.random.default_rng(10)\nui.add_object(\n    rng.normal(size=(3, 40, 18)),\n    type=\"array\",\n    title=\"Array Data\",\n)\n</code></pre>"},{"location":"usage/builtin_widgets/#image-viewer-widget","title":"Image Viewer Widget","text":"<p>This widget is for displaying a multi-dimensional image data. Its design is inspired by ImageJ.</p> <p>2D image slices are displayed in the main view, and the current slice can be changed by the slider. This widget also supports drawing ROIs (Region of Interests) on the image. RGB, complex value and multi-channel images are also supported.</p> Specification widget class <code>himena_builtins.qt.widgets.QImageView</code> model type <code>\"array.image\"</code> (<code>StandardType.IMAGE</code>) data type array-like object, such as <code>numpy.ndarray</code>, <code>xarray.DataArray</code>, <code>dask.Array</code> <p></p> <pre><code>import numpy as np\nfrom himena.standards.model_meta import ImageMeta\nfrom himena.standards import roi\n\nyy, xx = np.indices((100, 100))\nimage_stack = []\nfor n in range(3):\n    image_stack.append(np.sin(xx / 10 * n) * np.cos(yy / 8))\nimage = np.stack(image_stack, axis=0)\nui.add_object(\n    image,\n    type=\"array.image\",\n    metadata=ImageMeta(\n        current_roi=roi.RectangleRoi(x=11, y=28, width=32, height=20),\n        axes=[\"z\", \"y\", \"x\"],\n    ),\n    title=\"Image Data\",\n)\n</code></pre>"},{"location":"usage/builtin_widgets/#plot-widget","title":"Plot Widget","text":"<p><code>himena_builtins</code> provides two types of plot widgets. One is based on the standard plot model defined in <code>himena.standards.plotting</code>, and the other is a direct display of <code>matplotlib.Figure</code> object.</p> <p>The standard plot model is designed to be inter-changeable between different plotting libraries, and <code>himena</code> can understand the underlying structure. Therefore, the plotted data can be read, modified and written consistently. On the other hand, the <code>matplotlib</code> figure object supports the complete set of <code>matplotlib</code> functions.</p> himena standard plot modelmatplotlib figure object Specification widget class <code>himena_builtins.qt.widgets.QModelMatplotlibCanvas</code> model type <code>\"plot\"</code> (<code>StandardType.PLOT</code>) data type the standard plot model defined in <code>himena.standards.plotting</code> Specification widget class <code>himena_builtins.qt.widgets.QMatplotlibCanvas</code> model type <code>\"matplotlib-figure\"</code> (<code>StandardType.MPL_FIGURE</code>) data type <code>matplotlib.Figure</code> object <p></p> <pre><code>from himena.standards import plotting as hplt\nimport numpy as np\n\nfig = hplt.figure()\nx = np.linspace(-1, 1, 100)\nfig.plot(x, np.cos(x) * np.exp(-x**2 / 2))\nxsparse = np.linspace(-1, 1, 9)\nfig.scatter(xsparse, np.cos(xsparse) * np.exp(-xsparse**2 / 2), color=\"black\")\nui.add_object(fig, type=\"plot\", title=\"Plot Data\")\n</code></pre>"},{"location":"usage/builtin_widgets/#excel-like-widget","title":"Excel-like Widget","text":"<p>This widget is used to display and edit a dictionary of tables, which is technically an Excel-like data. The keys of the dictionary are the names of the sheets.</p> Specification widget class <code>himena_builtins.qt.widgets.QExcelEdit</code> model type <code>\"dict.table\"</code> (<code>StandardType.EXCEL</code>) data type <code>dict[str, ndarray]</code> <p></p> <pre><code>ui.add_object(\n    {\n        \"format\": [[\"key\", \"value\"], [\"name\", \"\"], [\"age\", \"\"]],\n        \"example\": [[\"key\", \"value\"], [\"name\", \"Alice\"], [\"age\", 20]],\n    },\n    type=\"dict.table\",\n    title=\"Excel-like Data\",\n)\n</code></pre>"},{"location":"usage/builtin_widgets/#function-widget","title":"Function Widget","text":"<p>This widget contains a non-editable function object. A function widget is usually created by the \"Compile as a function\" command on a text data. A function widget is useful to be used as callable inputs for custom commands, such as <code>scipy.optimization</code> or <code>scipy.integrate</code>.</p> Specification widget class <code>himena_builtins.qt.widgets.QFunctionEdit</code> model type <code>\"function\"</code> (<code>StandardType.FUNCTION</code>) data type callable object <p></p> <pre><code>from himena.standards.model_meta import FunctionMeta\n\ndef example_function(x):\n    return x**2\n\nui.add_object(\n    example_function,\n    type=\"function\",\n    title=\"Function Data\",\n)\n</code></pre>"},{"location":"usage/builtin_widgets/#roi-widget","title":"ROI Widget","text":"<p>This widget represents a list of ROIs (Region of Interests). ROIs are usually used in images, and the built-in image viewer supports drawing ROIs on the image.</p> Specification widget class <code>himena_builtins.qt.widgets.QImageRoiView</code> model type <code>\"rois\"</code> (<code>StandardType.ROIS</code>) data type standard roi-list model in <code>himena.standards.roi</code> <p></p> <pre><code>from himena.standards import roi\n\nroilist = roi.RoiListModel(\n    items=[\n        roi.LineRoi(start=(4, 6), end=(18, -1), name=\"line-roi-0\"),\n        roi.LineRoi(start=(12, 14), end=(6, 4), name=\"line-roi-1\"),\n        roi.RectangleRoi(x=6, y=7, width=8, height=8.4, name=\"rect-roi-0\"),\n        roi.LineRoi(start=(4, 6), end=(18, -1), name=\"line-roi-2\"),\n        roi.EllipseRoi(x=6, y=7, width=8, height=8.4, name=\"ellipse-roi-0\")\n    ]\n)\nwin = ui.add_object(roilist, type=\"rois\")\nwin.size = (200, 180)\n</code></pre>"},{"location":"usage/builtin_widgets/#jupyter-notebook-widget","title":"Jupyter Notebook Widget","text":"<p>Text contents in \"ipynb\" format can be rendered in a way similar to Jupyter Notebook.</p> Specification widget class <code>himena_builtins.qt.widgets.QIpynbEdit</code> model type <code>\"text.json.ipynb\"</code> (<code>StandardType.IPYNB</code>) data type <code>str</code> in the IPython Notebook format <p></p> <pre><code>text = r\"\"\"{\n \"cells\": [\n  {\n   \"cell_type\": \"code\",\n   \"outputs\": [{\"name\": \"stdout\", \"output_type\": \"stream\", \"text\": [\"[0 1 2 3 4]\\n\"]}],\n   \"source\": [\"import numpy as np\\n\", \"import matplotlib.pyplot as plt\\n\", \"\\n\", \"print(np.arange(5))\"]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"source\": [\"# Test\\n\", \"\\n\", \"- this is a test file.\"]\n  }\n ]\n}\"\"\"\n\nui.add_object(text, type=\"text.json.ipynb\", title=\"Jupyter Notebook\")\n</code></pre>"},{"location":"usage/builtin_widgets/#model-stack-widget","title":"Model Stack Widget","text":"<p>This widget is used for displaying a folder. Data is lazily loaded so that opening a large folder does not take much time.</p> Specification widget class <code>himena_builtins.qt.widgets.QModelStack</code> model type <code>\"models\"</code> (<code>StandardType.MODELS</code>) data type <code>list[WidgetDataModel]</code> <p></p> <pre><code>from himena.types import WidgetDataModel\n\nmodels = [\n    WidgetDataModel(value=[[\"key\", \"value\"], [\"name\", \"Alice\"], [\"age\", 20]], type=\"table\", title=\"Table Data\"),\n    WidgetDataModel(value=\"\", type=\"text\", title=\"Text Data\"),\n]\nwin = ui.add_object(models, type=\"models\", title=\"Model Stack\")\nwin.size = (300, 250)\n</code></pre>"},{"location":"usage/builtin_widgets/#workflow-viewer-widget","title":"Workflow Viewer Widget","text":"<p>The workflow of each data can be visualized in this widget.</p> Specification widget class <code>himena_builtins.qt.widgets.QWorkflowView</code> model type <code>\"workflow\"</code> (<code>StandardType.WORKFLOW</code>) data type <code>himena.workflows.Workflow</code> object <p></p> <pre><code>ui.exec_action(\"builtins:new-text\")\nwin = ui.add_object(ui.current_model.workflow, type=\"workflow\", title=\"Workflow\")\nwin.size = (280, 120)\n</code></pre>"},{"location":"usage/customization/","title":"Customization","text":"<p>You can customize your application profile from the setting dialog.</p>"},{"location":"usage/customization/#application-color-theme","title":"Application Color Theme","text":"<p>There are several color themes available. You can select your favorite one from the appearance tab in the setting dialog.</p> <p></p> <p>Alternatively, you can programmatically change it by setting the <code>theme</code> property.</p> <pre><code>ui.theme = \"dark-green\"\n</code></pre>"},{"location":"usage/customization/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"<p>You can customize keyboard shortcuts for various actions registered in the application.</p> <p></p>"},{"location":"usage/customization/#plugin-settings","title":"Plugin Settings","text":"<p>Many settings that are not directly relevant to the data itself (such as the table cell size, default SSH host name, etc.) can be configured from the plugin settings tab.</p> <p></p>"},{"location":"usage/sessions/","title":"Sessions","text":"<p>A \"session\" is a collection of tabs and sub-windows that can be saved and restored later. Sessions are useful for saving your work halfway through. To save a session, click the \"File &gt; Session &gt; Save Session ...\" menu.</p> <p>Warning</p> <p>The session feature is still experimental. The saved session may not be restored in some special cases. Please make sure you will not lose your important data.</p>"},{"location":"usage/sessions/#how-it-works","title":"How it Works","text":"<p>A session is saved as a zip file suffixed with <code>.session.zip</code>. The zip file contains:</p> <ol> <li>Files created by writing all the sub-windows in the application.</li> <li>Directories that store the metadata of each data model.</li> <li><code>session.yaml</code> that describes many other states of the application.</li> </ol> <p>During saving the session, <code>himena</code> tries to find the best writer plugin to write every sub-window. Therefore, if any of the windows cannot be written to files, saving the session will lose the data (or use workflows to avoid this).</p>"},{"location":"usage/sessions/#make-the-session-portable","title":"Make the Session Portable","text":"<p>By default, sub-windows directly read from the local disk will not be saved again in the session. However, this session will not work on another computer, or if the file is moved. To make the session portable, you have to check the \"save copies\" option.</p>"},{"location":"usage/sessions/#restore-subset-of-the-data-by-workflows","title":"Restore Subset of the Data by Workflows","text":"<p>Instead of saving a sub-window as a file, you can restore the data by re-running all the commands needed to generate the data. As each sub-window has its workflow to track its history, this workflow can be used to restore the data.</p> <p>In the \"Save Session ...\" dialog, you can select which command you will allow to be executed. All the sub-windows that are directly generated by the command will not be saved as files, but will be restored by the workflow when the session is loaded.</p> <p>For example, if you have the following workflow:</p> <pre><code>        Command A         Command B\nData X0 --------&gt; Data X1 --------&gt; Data X2\n</code></pre> <p>and allowed Command A to be executed, the session will save Data X2 if \"Save copies\" is not checked, or will save Data X0 and Data X2 if \"Save copies\" is checked.</p>"},{"location":"usage/tab_and_window/","title":"Tab/Window Manipulation","text":"<p>The current state of the application can be programmatically manipulated.</p>"},{"location":"usage/tab_and_window/#access-to-tabs-and-sub-windows","title":"Access to Tabs and Sub-windows","text":"<p><code>ui.tabs</code> is a list-like object that contains all the tabs. Each tab is another list-like objects that contains all the sub-windows.</p> <pre><code>ui.tabs[0]  # The first tab\n</code></pre> Output Example<pre><code>TabArea([\n  SubWindow(title='Table-0', widget=&lt;builtins:QSpreadsheet&gt;),\n  SubWindow(title='Untitled-1', widget=&lt;builtins:QTextEdit&gt;),\n])\n</code></pre> <pre><code>ui.tabs[0][1]  # The second sub-window in the first tab\n</code></pre> Output Example<pre><code>SubWindow(title='Untitled-1', widget=&lt;builtins:QTextEdit&gt;)\n</code></pre> <p>Indices of the active tab or sub-window can be accessed by following properties.</p> <pre><code>ui.tabs.current_index  # The index of the current tab\nui.tabs[0].current_index  # The index of the current sub-window in the first tab\n</code></pre> <p>There are shortcut methods to access the current sub-window and the underlying data model.</p> <pre><code>ui.current_window  # The current sub-window\nui.current_model  # The current data model\n</code></pre>"},{"location":"usage/tab_and_window/#adding-tabs-and-sub-windows","title":"Adding Tabs and Sub-windows","text":"<p>To add a new tab, use <code>ui.add_tab</code> method.</p> <pre><code>ui.add_tab()\nui.add_tab(\"new tab\")  # with a name\n</code></pre> <p>Both main window and tab have methods of same names to add sub-windows. If a method is called from the main window, sub-window will be added to the current tab, or to a new tab if there is no tab.</p> <pre><code># add array object to the current tab\nui.add_object(np.arange(10), type=\"array\", title=\"my array\")\n\n# add array object to the first tab\nui.tabs[0].add_object(np.arange(10), type=\"array\", title=\"my array\")\n\n# add a WidgetDataModel\nmodel = WidgetDataModel(value=np.arange(10), type=\"array\", title=\"my array\")\nui.add_data_model(model)\n\n# add any Qt widget\nfrom qtpy.QtWidgets import QPushButton\n\nui.add_widget(QPushButton(\"Hello, world!\"))\n\n# add a magicgui widget\nfrom magicgui.widgets import LineEdit\n\nui.add_widget(LineEdit(name=\"name\", value=\"abc\"))\n</code></pre>"},{"location":"usage/tab_and_window/#access-to-the-data-and-widget-states","title":"Access to the Data and Widget States","text":"<p>Basically, the sub-window state is obtained by a <code>WidgetDataModel</code>.</p> <pre><code>win = ui.add_object(\"abc\", type=\"text\", title=\"my text\")\nmodel = win.to_model()  # a WidgetDataModel object\nmodel.value  # \"abc\"\n</code></pre> <p>Widget states that are irrelevant to the data are stored in the <code>metadata</code> property. The type of this property differs between data types, and sometimes, widget types. In the case of text data, <code>TextMeta</code> object is used in the default widget.</p> <pre><code>model.metadata\n</code></pre> Output<pre><code>TextMeta(\n  language='Plain Text',\n  spaces=4,\n  selection=(0, 0),\n  font_family='Consolas',\n  font_size=10.0,\n  encoding='utf-8',\n)\n</code></pre>"},{"location":"usage/tab_and_window/#closing-tabs-and-sub-windows","title":"Closing Tabs and Sub-windows","text":"<p>Tabs and sub-windows can be closed by <code>del</code>.</p> <pre><code>del ui.tabs[0]  # close the first tab\ndel ui.tabs[0][1]  # close the second sub-window in the first tab\n</code></pre>"},{"location":"usage/tab_and_window/#resizing-and-moving-sub-windows","title":"Resizing and Moving Sub-windows","text":"<p>The geometry of sub-windows can be manipulated by <code>rect</code> property. It is a tuple-like <code>WindowRect</code> object.</p> <pre><code>win = ui.current_window\nwin.rect\n</code></pre> Output<pre><code>WindowRect(left=28, top=28, width=400, height=300)\n</code></pre> <pre><code>win.rect = (50, 40, 200, 250)  # update the geometry\n</code></pre> <p>If you only want to resize the window, you can use the <code>size</code> property.</p> <pre><code>win.size = (200, 250)  # resize the window\n</code></pre> <p>To move sub-windows, <code>WindowRect</code> object has several useful methods.</p> <ul> <li><code>move_top_left</code></li> <li><code>move_top_right</code></li> <li><code>move_bottom_left</code></li> <li><code>move_bottom_right</code></li> </ul> <p>These methods return a new <code>WindowRect</code> object with updated positions.</p> <pre><code>win.rect = win.rect.move_top_left(10, 20)\nwin.rect\n</code></pre> Output<pre><code>WindowRect(left=10, top=20, width=200, height=250)\n</code></pre>"},{"location":"usage/tab_and_window/#changing-the-window-state","title":"Changing the Window State","text":"<p>The window state can be changed by <code>state</code> property. The state is a <code>WindowState</code> enum object, but it can be set by a string. Supported states are: \"min\", \"max\", \"normal\" and \"full\".</p> <pre><code>ui.current_window.state = \"max\"\nui.current_window.state\n</code></pre> Output<pre><code>&lt;WindowState.MAX: 'max'&gt;\n</code></pre>"},{"location":"usage/workflows/","title":"Workflows","text":"<p>A \"workflow\" is a record of the commands and parameters you used to create a data model. For complicated data analysis tasks, looking at the workflow will help you remember what you did.</p>"},{"location":"usage/workflows/#built-in-workflow-viewer","title":"Built-in Workflow Viewer","text":"<p><code>himena-builtins</code> subpackage provides a built-in workflow viewer. You can view the workflow of a sub-window.</p> <p>A workflow viewer is not a special widget. It is also a standard widget using the <code>WidgetDataModel</code> standard.</p>"},{"location":"usage/workflows/#execute-workflow","title":"Execute workflow","text":"<p>A workflow is a full record to regenerate the data model. Therefore, you can execute the workflow to get the result.</p> <p></p>"}]}