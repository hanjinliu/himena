{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"himena","text":"<p><code>himena</code> is a GUI application framework aiming for highly cooperative GUI development, mainly focusing on data analysis and visualization.</p>"},{"location":"#source","title":"Source","text":"<p>Jump to GitHub repository.</p>"},{"location":"#index","title":"Index","text":"<ul> <li>Tutorial</li> <li>Developper's Guide</li> </ul>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#installation","title":"Installation","text":"<p><code>himena</code> is available on PyPI. You can install it with the recommended dependencies:</p> <pre><code>pip install himena[recommended]\n</code></pre> <p>or with the minimal dependencies:</p> <pre><code>pip install himena\n</code></pre>"},{"location":"tutorial/#start-application","title":"Start Application","text":"<p>After installation, you can start the application by running the <code>himena</code> command:</p> <pre><code>himena\n</code></pre> <p><code>himena</code> can manage multiple profiles. A profile is a set of configurations, color theme and plugins. You can create a new profile with:</p> <pre><code>himena --new test\n</code></pre> <p>and start the application with the profile:</p> <pre><code>himena test\n</code></pre> <p>Note</p> <p>A profile can be used to separate the configurations for different users, or for different purposes. For example, you can have a profile \"img\" for image analysis, in which <code>himena img</code> is just like a sub-command of <code>himena</code>.</p>"},{"location":"tutorial/#open-a-data","title":"Open a Data","text":"<p>Let's start with a simple example. From the menubar, select <code>File &gt; New &gt; Seaborn &gt; iris</code>. This command will fetch the iris dataset online open it as a subwindow.</p> <p></p> <p>In <code>himena</code>, a subwindow represents a single data model. For example, this iris dataset is opened as a \"table\" data model. <code>himena</code> automatically picked the table viewer widget to display the data.</p> <p>Of course, you can open a local file from <code>File &gt; Open File(s) ...</code> menu, Ctrl+O shortcut, drag-and-drop or directly paste the data from the clipboard.</p> <p>There are also several ways to create a new window. They are listed in <code>File &gt; New</code> menu, or you can use Ctrl+N shortcut to look for the available options.</p>"},{"location":"tutorial/#execute-commands","title":"Execute Commands","text":"<p>Many commands are registered on the startup of the application. There are several ways to run a command.</p>"},{"location":"tutorial/#window-menu-button","title":"Window Menu Button","text":"<p>The \"window menu button\" will show a menu that contains the commands relevant to the operation on the current window. These commands are always available regardless of the data model the window represents. For example, \"Duplicate window\" and \"Copy path to cliboard\" are in the window menu.</p>"},{"location":"tutorial/#model-menu-button","title":"Model Menu Button","text":"<p>The \"model menu button\" will show a menu that contains the commands relevant to the type of the underlying data model. For example, the \"Convert table to text\" is available in the window \"iris\" just opened above.</p>"},{"location":"tutorial/#command-palette","title":"Command Palette","text":"<p>All the commands are accessible from the command palette. Press Ctrl+Shift+P to open the command palette.</p>"},{"location":"tutorial/#manage-plugins","title":"Manage Plugins","text":"<p><code>himena</code> is designed to be highly extensible. You can install plugins to add new IO supports, new widgets, and commands. For example, <code>himena-stats</code>, a himena plugin for statistical analysis, can be installed with the following lines.</p> <pre><code>pip install himena-stats -U\nhimena --install himena-stats\nhimena your-profile-name --install himena-stats  # install to a specific profile\n</code></pre> <p>You can also select which plugins installed to the Python virtual environment to be included in the <code>himena</code> profile from the setting. A setting dialog can be opened from <code>File &gt; Settings ...</code> or shortcut Ctrl+,</p> <p></p>"},{"location":"tutorial/#the-python-interpreter-console","title":"The Python Interpreter Console","text":"<p>A built-in Qt console dock widget plugin is registered by default. You can oepn it by shortcut Ctrl+Shift+C.</p> <p></p>"},{"location":"api/consts/","title":"himena.consts","text":""},{"location":"api/consts/#himena.consts.MenuId","title":"<code>MenuId</code>","text":"<p>Preset of menu IDs.</p> Source code in <code>src\\himena\\consts.py</code> <pre><code>class MenuId(StrEnum):\n    \"\"\"Preset of menu IDs.\"\"\"\n\n    FILE = \"file\"\n    FILE_RECENT = \"file/recent\"\n    FILE_NEW = \"file/new\"\n    FILE_SCREENSHOT = \"file/screenshot\"\n    FILE_SESSION = \"file/session\"\n    WINDOW = \"window\"\n    WINDOW_RESIZE = \"window/resize\"\n    WINDOW_ALIGN = \"window/align\"\n    WINDOW_ANCHOR = \"window/anchor\"\n    WINDOW_NTH = \"window/nth\"\n    WINDOW_LAYOUT = \"window/layout\"\n    VIEW = \"view\"\n\n    # \"Tools\" menu\n    TOOLS = \"tools\"\n    TOOLS_DOCK = \"tools/dock\"\n    \"\"\"Menu ID for the dock widgets.\"\"\"\n    TOOLS_ARRAY = \"tools/array\"\n    \"\"\"Menu ID for the commands related to \"array\"-type data.\"\"\"\n    TOOLS_DATAFRAME = \"tools/dataframe\"\n    \"\"\"Menu ID for the commands related to \"dataframe\"-type data.\"\"\"\n    TOOLS_EXCEL = \"tools/excel\"\n    \"\"\"Menu ID for the commands related to \"excel\"-type data.\"\"\"\n    TOOLS_IMAGE = \"tools/image\"\n    \"\"\"Menu ID for the commands related to \"image\"-type data.\"\"\"\n    TOOLS_IMAGE_ROI = \"tools/image/roi\"\n    \"\"\"Menu ID for the commands related to image ROIs.\"\"\"\n    TOOLS_IMAGE_CHANNELS = \"tools/image/channels\"\n    \"\"\"Menu ID for the commands related to image channels.\"\"\"\n    TOOLS_PLOT = \"tools/plot\"\n    \"\"\"Menu ID for the commands related to \"plot\"-type data.\"\"\"\n    TOOLS_TEXT = \"tools/text\"\n    \"\"\"Menu ID for the commands related to \"text\"-type data.\"\"\"\n    TOOLS_TABLE = \"tools/table\"\n    \"\"\"Menu ID for the commands related to \"table\"-type data.\"\"\"\n    TOOLS_TABLE_COPY = \"tools/table/copy\"\n    \"\"\"Menu ID for the commands that copy the \"table\"-type data.\"\"\"\n    TOOLS_MODELS = \"tools/models\"\n    \"\"\"Menu ID for the commands related to \"models\"-type data.\"\"\"\n    TOOLS_FUNCTION = \"tools/function\"\n    \"\"\"Menu ID for the commands related to \"function\"-type data.\"\"\"\n\n    # Others\n    TOOLBAR = \"toolbar\"\n    HELP = \"help\"\n\n    RECENT_ALL = \"file/.recent-all\"\n    STARTUP = \"file/.startup\"\n    MODEL_MENU = \"/model_menu\"\n</code></pre>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_ARRAY","title":"<code>TOOLS_ARRAY = 'tools/array'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands related to \"array\"-type data.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_DATAFRAME","title":"<code>TOOLS_DATAFRAME = 'tools/dataframe'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands related to \"dataframe\"-type data.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_DOCK","title":"<code>TOOLS_DOCK = 'tools/dock'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the dock widgets.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_EXCEL","title":"<code>TOOLS_EXCEL = 'tools/excel'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands related to \"excel\"-type data.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_FUNCTION","title":"<code>TOOLS_FUNCTION = 'tools/function'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands related to \"function\"-type data.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_IMAGE","title":"<code>TOOLS_IMAGE = 'tools/image'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands related to \"image\"-type data.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_IMAGE_CHANNELS","title":"<code>TOOLS_IMAGE_CHANNELS = 'tools/image/channels'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands related to image channels.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_IMAGE_ROI","title":"<code>TOOLS_IMAGE_ROI = 'tools/image/roi'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands related to image ROIs.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_MODELS","title":"<code>TOOLS_MODELS = 'tools/models'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands related to \"models\"-type data.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_PLOT","title":"<code>TOOLS_PLOT = 'tools/plot'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands related to \"plot\"-type data.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_TABLE","title":"<code>TOOLS_TABLE = 'tools/table'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands related to \"table\"-type data.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_TABLE_COPY","title":"<code>TOOLS_TABLE_COPY = 'tools/table/copy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands that copy the \"table\"-type data.</p>"},{"location":"api/consts/#himena.consts.MenuId.TOOLS_TEXT","title":"<code>TOOLS_TEXT = 'tools/text'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Menu ID for the commands related to \"text\"-type data.</p>"},{"location":"api/consts/#himena.consts.StandardType","title":"<code>StandardType</code>","text":"<p>Conventions for standard model types.</p> <p>Developers should use these types as much as possible to ensure compatibility with other plugins.</p> Source code in <code>src\\himena\\consts.py</code> <pre><code>class StandardType(SimpleNamespace):\n    \"\"\"Conventions for standard model types.\n\n    Developers should use these types as much as possible to ensure compatibility with\n    other plugins.\n    \"\"\"\n\n    ### Basic types ###\n    TEXT = \"text\"  # any text\n    TABLE = \"table\"  # 2D data without any special structure\n    ARRAY = \"array\"  # nD grid data such as numpy array\n    DICT = \"dict\"  # dictionary\n    DATAFRAME = \"dataframe\"  # DataFrame object\n\n    ### Subtypes ###\n    # dict subtypes\n    EXCEL = \"dict.table\"  # Excel file (~= tabbed tables)\n    DATAFRAMES = \"dict.dataframe\"\n    ARRAYS = \"dict.array\"\n    IMAGES = \"dict.array.image\"\n\n    # text subtypes\n    HTML = \"text.html\"  # HTML text\n    SVG = \"text.svg\"  # SVG text\n    MARKDOWN = \"text.markdown\"  # markdown text\n    JSON = \"text.json\"  # JSON text\n    IPYNB = \"text.json.ipynb\"  # Jupyter notebook\n\n    # image data\n    IMAGE = \"array.image\"\n    # uint image data that will be interpreted as labels\n    IMAGE_LABELS = \"array.image.labels\"\n\n    # (N, D) numerical array, such as D-dimensional point cloud\n    COORDINATES = \"array.coordinates\"\n\n    # DataFrame that is supposed to be plotted immediately (such as image line scan)\n    DATAFRAME_PLOT = \"dataframe.plot\"\n\n    ### plotting ###\n    PLOT = \"plot\"  # objects that satisfy the plotting standard\n    MPL_FIGURE = \"matplotlib-figure\"  # matplotlib figure object\n\n    ### 3D ###\n    MESH = \"mesh\"  # vertices, faces and values for 3D mesh\n\n    ### Nested models ###\n    MODELS = \"models\"  # list or dict of models\n    LAZY = \"lazy\"  # lazy loading of models\n\n    ### Other types ###\n    WORKFLOW = \"workflow\"  # himena workflow object\n    GROUPBY = \"groupby\"  # DataFrame GroupBy object\n    ROIS = \"rois\"  # regions of interest\n    FUNCTION = \"function\"  # callable object\n    DISTRIBUTION = \"distribution\"  # probablistic distribution object\n\n    # fallback when no reader is found for the file (which means that the file could be\n    # opened as a text file)\n    READER_NOT_FOUND = \"reader_not_found\"\n\n    # fallback when no specific widget can be used for the data\n    ANY = \"any\"\n</code></pre>"},{"location":"api/layout/","title":"himena.layout","text":""},{"location":"api/layout/#himena.layout.BoxLayout1D","title":"<code>BoxLayout1D</code>","text":"Source code in <code>src\\himena\\layout.py</code> <pre><code>class BoxLayout1D(Layout1D):\n    def __init__(self, main=None, *, margins=(0, 0, 0, 0), spacing=0):\n        super().__init__(main, margins=margins, spacing=spacing)\n        self._stretches: list[float] = []\n\n    def insert(self, index: int, child: Layout, *, stretch: float = 1) -&gt; None:\n        \"\"\"Insert a child layout at the specified index.\"\"\"\n        if stretch &lt;= 0:\n            raise ValueError(f\"stretch must be positive, got {stretch!r}\")\n        if not isinstance(child, Layout):\n            raise TypeError(f\"Can only insert a Layout object, got {type(child)}\")\n        self._children.insert(index, child)\n        child._main_window_ref = self._main_window_ref\n        child._parent_layout_ref = weakref.ref(self)\n        self._stretches.insert(index, float(stretch))\n        self._resize_children(self.rect)\n        return self\n\n    def append(self, child: Layout, *, stretch: float = 1) -&gt; None:\n        return self.insert(len(self), child, stretch=stretch)\n\n    def add(\n        self,\n        child: Layout | Iterable[Layout],\n        *more: Layout,\n        stretch: float = 1,\n    ) -&gt; Self:\n        \"\"\"Add child layout(s) to the layout.\"\"\"\n        if not isinstance(child, Layout):\n            child, more = child[0], [*child[1:], *more]\n        self.append(child, stretch=stretch)\n        for ch in more:\n            self.append(ch, stretch=stretch)\n        return self\n\n    def __delitem__(self, key: int):\n        _assert_supports_index(key)\n        child = self._children.pop(key)\n        child._parent_layout_ref = _no_ref\n        del self._stretches[key]\n        self._resize_children(self.rect)\n\n    def add_vbox_layout(self, *, margins=(0, 0, 0, 0), spacing=0) -&gt; VBoxLayout:\n        layout = VBoxLayout(self._main_window_ref(), margins=margins, spacing=spacing)\n        self.append(layout)\n        return layout\n\n    def add_hbox_layout(self, *, margins=(0, 0, 0, 0), spacing=0) -&gt; HBoxLayout:\n        layout = HBoxLayout(self._main_window_ref(), margins=margins, spacing=spacing)\n        self.append(layout)\n        return layout\n\n    def _may_take_child(\n        self, child: Layout, rect_old: WindowRect, rect_new: WindowRect\n    ) -&gt; Layout:\n        # window moved\n        dist2 = (rect_old.top - rect_new.top) ** 2 + (\n            rect_old.left - rect_new.left\n        ) ** 2\n        if dist2 &gt; 60**2:\n            # remove window from the layout\n            self.remove(child)\n        self._resize_children(self.rect)\n</code></pre>"},{"location":"api/layout/#himena.layout.BoxLayout1D.add","title":"<code>add(child, *more, stretch=1)</code>","text":"<p>Add child layout(s) to the layout.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>def add(\n    self,\n    child: Layout | Iterable[Layout],\n    *more: Layout,\n    stretch: float = 1,\n) -&gt; Self:\n    \"\"\"Add child layout(s) to the layout.\"\"\"\n    if not isinstance(child, Layout):\n        child, more = child[0], [*child[1:], *more]\n    self.append(child, stretch=stretch)\n    for ch in more:\n        self.append(ch, stretch=stretch)\n    return self\n</code></pre>"},{"location":"api/layout/#himena.layout.BoxLayout1D.insert","title":"<code>insert(index, child, *, stretch=1)</code>","text":"<p>Insert a child layout at the specified index.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>def insert(self, index: int, child: Layout, *, stretch: float = 1) -&gt; None:\n    \"\"\"Insert a child layout at the specified index.\"\"\"\n    if stretch &lt;= 0:\n        raise ValueError(f\"stretch must be positive, got {stretch!r}\")\n    if not isinstance(child, Layout):\n        raise TypeError(f\"Can only insert a Layout object, got {type(child)}\")\n    self._children.insert(index, child)\n    child._main_window_ref = self._main_window_ref\n    child._parent_layout_ref = weakref.ref(self)\n    self._stretches.insert(index, float(stretch))\n    self._resize_children(self.rect)\n    return self\n</code></pre>"},{"location":"api/layout/#himena.layout.EmptyLayout","title":"<code>EmptyLayout</code>","text":"<p>A layout that does not contain anything.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>class EmptyLayout(Layout):\n    \"\"\"A layout that does not contain anything.\"\"\"\n\n    def __init__(self, main: BackendMainWindow | None = None):\n        super().__init__(main)\n        self._rect = WindowRect(0, 0, 0, 0)\n\n    @property\n    def rect(self):\n        return self._rect\n\n    @rect.setter\n    def rect(self, value):\n        rect_old = self._rect\n        self._rect = WindowRect.from_tuple(*value)\n        if parent := self._parent_layout_ref():\n            parent._adjust_child_resize(self, rect_old, self._rect)\n\n    def _serialize_layout(self):\n        return {\"type\": \"empty\", \"rect\": self.rect}\n\n    @classmethod\n    def _deserialize_layout(cls, obj, main: MainWindow):\n        self = cls(main._backend_main_window)\n        self.rect = obj[\"rect\"]\n        return self\n</code></pre>"},{"location":"api/layout/#himena.layout.GridLayout","title":"<code>GridLayout</code>","text":"Source code in <code>src\\himena\\layout.py</code> <pre><code>class GridLayout(LayoutContainer):\n    def __init__(\n        self,\n        main: BackendMainWindow | None = None,\n        *,\n        margins: Margins[int] | tuple[int, int, int, int] = (0, 0, 0, 0),\n        spacing: Size[int] | tuple[int, int] = 0,\n    ):\n        super().__init__(main)\n        self._margins = Margins(*margins)\n        self._spacing = Size(*spacing)\n\n    @property\n    def margins(self) -&gt; Margins[int]:\n        \"\"\"Margins around the layout.\"\"\"\n        return self._margins\n\n    @margins.setter\n    def margins(self, value: Margins[int] | tuple[int, int, int, int]):\n        self._margins = Margins(*value)\n        self._resize_children(self.rect)\n\n    @property\n    def spacing(self) -&gt; Size:\n        \"\"\"Spacing between children.\"\"\"\n        return self._spacing\n\n    @spacing.setter\n    def spacing(self, value: Size[int] | tuple[int, int]):\n        self._spacing = Size(*value)\n        self._resize_children(self.rect)\n</code></pre>"},{"location":"api/layout/#himena.layout.GridLayout.margins","title":"<code>margins</code>  <code>property</code> <code>writable</code>","text":"<p>Margins around the layout.</p>"},{"location":"api/layout/#himena.layout.GridLayout.spacing","title":"<code>spacing</code>  <code>property</code> <code>writable</code>","text":"<p>Spacing between children.</p>"},{"location":"api/layout/#himena.layout.HBoxLayout","title":"<code>HBoxLayout</code>","text":"<p>A horizontal box layout.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>class HBoxLayout(BoxLayout1D):\n    \"\"\"A horizontal box layout.\"\"\"\n\n    def _iter_edge_and_span(self, rect: WindowRect) -&gt; Iterator[tuple[int, int]]:\n        num = len(self._children)\n        if num == 0:\n            yield from ()\n            return\n        w_cumsum = np.cumsum([0] + self._stretches, dtype=np.float32)\n        edges = (w_cumsum / w_cumsum[-1] * rect.width).astype(np.int32)\n        dx = self.spacing // 2\n        edges[0] += self._margins.left - dx\n        edges[-1] += self._margins.right + dx\n        for i in range(num):\n            left = edges[i] + dx\n            width = edges[i + 1] - edges[i] - self.spacing\n            yield left, width\n\n    def _ortho_region(self, rect: WindowRect) -&gt; tuple[int, int]:\n        height = rect.height - self._margins.top - self._margins.bottom\n        top = rect.top + self._margins.top\n        return top, height\n\n    def _resize_children(self, rect: WindowRect):\n        top, height = self._ortho_region(rect)\n        with self._adjust_child_resize_context():\n            for i, (left, width) in enumerate(self._iter_edge_and_span(rect)):\n                irect = WindowRect(left, top, width, height)\n                self._children[i].rect = irect\n        return None\n\n    def _adjust_child_resize(self, child: Layout, rect_old, rect_new):\n        if self._is_calling_adjust_child_resize:\n            return\n        left_changed = rect_old.left != rect_new.left\n        right_changed = rect_old.right != rect_new.right\n        with self._adjust_child_resize_context():\n            if left_changed and right_changed:\n                return self._may_take_child(child, rect_old, rect_new)\n\n            top, height = self._ortho_region(self.rect)\n            new_rect = child.rect\n            stretches = self._stretches.copy()\n            for i, (left, width) in enumerate(self._iter_edge_and_span(self.rect)):\n                stretches[i] = width\n                if left_changed and self._children[i] is child:\n                    if i == 0:\n                        child.rect = WindowRect(left, top, width, height)\n                    else:\n                        old_sum = stretches[i - 1] + stretches[i]\n                        w0 = stretches[i - 1] = old_sum - new_rect.width\n                        self._children[i - 1].rect = self._children[\n                            i - 1\n                        ].rect.with_width(w0)\n                        stretches[i] = new_rect.width\n                elif right_changed and self._children[i - 1] is child:\n                    if i == len(self) - 1:\n                        child.rect = WindowRect(left, top, width, height)\n                    else:\n                        old_sum = stretches[i - 1] + stretches[i]\n                        w0 = stretches[i] = old_sum - new_rect.width\n                        self._children[i].rect = new_rect.with_width(w0)\n                        stretches[i - 1] = new_rect.width\n                else:\n                    child.rect = WindowRect(left, top, width, height)\n            self._stretches = stretches\n            self._resize_children(self.rect)\n</code></pre>"},{"location":"api/layout/#himena.layout.Layout","title":"<code>Layout</code>","text":"Source code in <code>src\\himena\\layout.py</code> <pre><code>class Layout(ABC):\n    def __init__(self, main: BackendMainWindow | None = None):\n        self._anchor = _anc.NoAnchor\n        if main:\n            self._main_window_ref = weakref.ref(main)\n        else:\n            self._main_window_ref = _no_ref\n        self._parent_layout_ref: Callable[[], LayoutContainer | None] = _no_ref\n\n    @property\n    @abstractmethod\n    def rect(self) -&gt; WindowRect:\n        \"\"\"Position and size of the sub-window.\"\"\"\n\n    @rect.setter\n    def rect(self, value: tuple[int, int, int, int] | WindowRect) -&gt; None: ...\n\n    @abstractmethod\n    def _serialize_layout(self) -&gt; Any:\n        \"\"\"Serialize the layout instance.\"\"\"\n\n    @classmethod\n    @abstractmethod\n    def _deserialize_layout(cls, obj, main: MainWindow) -&gt; Any:\n        \"\"\"Deserialize the layout instance.\"\"\"\n\n    @property\n    def size(self) -&gt; Size[int]:\n        \"\"\"Size of the object.\"\"\"\n        return self.rect.size()\n\n    @size.setter\n    def size(self, value: tuple[int, int]) -&gt; None:\n        self.rect = (self.rect.left, self.rect.top, *value)\n        return None\n\n    @property\n    def anchor(self) -&gt; _anc.WindowAnchor:\n        return self._anchor\n\n    @anchor.setter\n    def anchor(self, anchor: _anc.WindowAnchor | None):\n        if anchor is None:\n            anchor = _anc.NoAnchor\n        elif isinstance(anchor, str):\n            anchor = self._anchor_from_str(anchor)\n        elif not isinstance(anchor, _anc.WindowAnchor):\n            raise TypeError(f\"Expected WindowAnchor, got {type(anchor)}\")\n        self._anchor = anchor\n\n    def _reanchor(self, size: Size):\n        \"\"\"Reanchor all windows if needed (such as minimized windows).\"\"\"\n        if rect := self._anchor.apply_anchor(size, self.size):\n            self.rect = rect\n\n    def _anchor_from_str(self, anchor: str):\n        rect = self.rect\n        main = self._main_window_ref()\n        if main is None:\n            w0, h0 = 100, 100\n        else:\n            w0, h0 = main._area_size()\n        if anchor in (\"top-left\", \"top left\", \"top_left\"):\n            return _anc.TopLeftConstAnchor(rect.left, rect.top)\n        elif anchor in (\"top-right\", \"top right\", \"top_right\"):\n            return _anc.TopRightConstAnchor(w0 - rect.right, rect.top)\n        elif anchor in (\"bottom-left\", \"bottom left\", \"bottom_left\"):\n            return _anc.BottomLeftConstAnchor(rect.left, h0 - rect.bottom)\n        elif anchor in (\"bottom-right\", \"bottom right\", \"bottom_right\"):\n            return _anc.BottomRightConstAnchor(w0 - rect.right, h0 - rect.bottom)\n        else:\n            raise ValueError(f\"Unknown anchor: {anchor}\")\n</code></pre>"},{"location":"api/layout/#himena.layout.Layout.rect","title":"<code>rect</code>  <code>abstractmethod</code> <code>property</code> <code>writable</code>","text":"<p>Position and size of the sub-window.</p>"},{"location":"api/layout/#himena.layout.Layout.size","title":"<code>size</code>  <code>property</code> <code>writable</code>","text":"<p>Size of the object.</p>"},{"location":"api/layout/#himena.layout.Layout._deserialize_layout","title":"<code>_deserialize_layout(obj, main)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Deserialize the layout instance.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>@classmethod\n@abstractmethod\ndef _deserialize_layout(cls, obj, main: MainWindow) -&gt; Any:\n    \"\"\"Deserialize the layout instance.\"\"\"\n</code></pre>"},{"location":"api/layout/#himena.layout.Layout._reanchor","title":"<code>_reanchor(size)</code>","text":"<p>Reanchor all windows if needed (such as minimized windows).</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>def _reanchor(self, size: Size):\n    \"\"\"Reanchor all windows if needed (such as minimized windows).\"\"\"\n    if rect := self._anchor.apply_anchor(size, self.size):\n        self.rect = rect\n</code></pre>"},{"location":"api/layout/#himena.layout.Layout._serialize_layout","title":"<code>_serialize_layout()</code>  <code>abstractmethod</code>","text":"<p>Serialize the layout instance.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>@abstractmethod\ndef _serialize_layout(self) -&gt; Any:\n    \"\"\"Serialize the layout instance.\"\"\"\n</code></pre>"},{"location":"api/layout/#himena.layout.Layout1D","title":"<code>Layout1D</code>","text":"<p>Layout container that arranges children in 1D at the constant interval.</p> <p>Properties <code>margins</code> and <code>spacing</code> are defined as follows. <pre><code>        spacing                 margin\n         &gt; &lt;                     &gt; &lt;\n[ [child1] [   child2   ] [child3] ]\n           &lt;-  stretch -&gt;\n</code></pre></p> <p>Abstract methods: - <code>_resize_children(self, rect: WindowRect) -&gt; None</code> - <code>insert(self, index: int, child: Layout) -&gt; None</code></p> Source code in <code>src\\himena\\layout.py</code> <pre><code>class Layout1D(LayoutContainer, MutableSequence[Layout]):\n    \"\"\"Layout container that arranges children in 1D at the constant interval.\n\n    Properties `margins` and `spacing` are defined as follows.\n    ```\n            spacing                 margin\n             &gt; &lt;                     &gt; &lt;\n    [ [child1] [   child2   ] [child3] ]\n               &lt;-  stretch -&gt;\n    ```\n\n    Abstract methods:\n    - `_resize_children(self, rect: WindowRect) -&gt; None`\n    - `insert(self, index: int, child: Layout) -&gt; None`\n    \"\"\"\n\n    def __init__(\n        self,\n        main: BackendMainWindow | None = None,\n        *,\n        margins: Margins[int] | tuple[int, int, int, int] = (0, 0, 0, 0),\n        spacing: int = 0,\n    ):\n        super().__init__(main)\n        self._children: list[Layout] = []\n        self._margins = Margins(*margins)\n        self._spacing = spacing\n\n    @property\n    def margins(self) -&gt; Margins[int]:\n        \"\"\"Margins around the layout.\"\"\"\n        return self._margins\n\n    @margins.setter\n    def margins(self, value: Margins[int] | tuple[int, int, int, int]):\n        self._margins = Margins(*value)\n        self._resize_children(self.rect)\n\n    @property\n    def spacing(self) -&gt; int:\n        \"\"\"Spacing between children.\"\"\"\n        return self._spacing\n\n    @spacing.setter\n    def spacing(self, value: int):\n        if value &lt; 0 or not isinstance(value, (int, np.int_)):\n            raise ValueError(f\"spacing must be non-negative integer, got {value}\")\n        self._spacing = value\n        self._resize_children(self.rect)\n\n    def set_margins(\n        self,\n        *,\n        left: int | None = None,\n        top: int | None = None,\n        right: int | None = None,\n        bottom: int | None = None,\n    ):\n        \"\"\"Update margins around the layout.\"\"\"\n        margins_old = self.margins\n        left = left if left is not None else margins_old.left\n        top = top if top is not None else margins_old.top\n        right = right if right is not None else margins_old.right\n        bottom = bottom if bottom is not None else margins_old.bottom\n        self.margins = left, top, right, bottom\n        return None\n\n    def __len__(self) -&gt; int:\n        return len(self._children)\n\n    def __iter__(self) -&gt; Iterator[Layout]:\n        for _, child in self._children:\n            yield child\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}({self._children!r})\"\n\n    def __getitem__(self, key) -&gt; Layout:\n        _assert_supports_index(key)\n        return self._children[key]\n\n    def __setitem__(self, key, layout: Layout):\n        if not isinstance(layout, Layout):\n            raise TypeError(f\"Can only set a Layout object, got {type(layout)}\")\n        _assert_supports_index(key)\n        self._children[key] = layout\n        layout._main_window_ref = self._main_window_ref\n        layout._parent_layout_ref = weakref.ref(self)\n        self._resize_children(self.rect)\n\n    def remove(self, child: Layout) -&gt; None:\n        MutableSequence.remove(self, child)\n        child._parent_layout_ref = _no_ref\n        if len(self) &gt; 1:\n            self._resize_children(self.rect)\n        elif len(self) == 1:\n            self.remove(self[0])\n\n    def _serialize_layout(self):\n        return {\n            \"type\": type(self).__name__.lower(),\n            \"children\": [child._serialize_layout() for child in self._children],\n            \"margins\": list(self.margins),\n            \"spacing\": self.spacing,\n        }\n\n    @classmethod\n    def _deserialize_layout(cls, obj, main: MainWindow) -&gt; Self:\n        self = cls(\n            main._backend_main_window, margins=obj[\"margins\"], spacing=obj[\"spacing\"]\n        )\n        for child_obj in obj[\"children\"]:\n            child = construct_layout(child_obj, main)\n            self.append(child)\n        return self\n</code></pre>"},{"location":"api/layout/#himena.layout.Layout1D.margins","title":"<code>margins</code>  <code>property</code> <code>writable</code>","text":"<p>Margins around the layout.</p>"},{"location":"api/layout/#himena.layout.Layout1D.spacing","title":"<code>spacing</code>  <code>property</code> <code>writable</code>","text":"<p>Spacing between children.</p>"},{"location":"api/layout/#himena.layout.Layout1D.set_margins","title":"<code>set_margins(*, left=None, top=None, right=None, bottom=None)</code>","text":"<p>Update margins around the layout.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>def set_margins(\n    self,\n    *,\n    left: int | None = None,\n    top: int | None = None,\n    right: int | None = None,\n    bottom: int | None = None,\n):\n    \"\"\"Update margins around the layout.\"\"\"\n    margins_old = self.margins\n    left = left if left is not None else margins_old.left\n    top = top if top is not None else margins_old.top\n    right = right if right is not None else margins_old.right\n    bottom = bottom if bottom is not None else margins_old.bottom\n    self.margins = left, top, right, bottom\n    return None\n</code></pre>"},{"location":"api/layout/#himena.layout.LayoutContainer","title":"<code>LayoutContainer</code>","text":"<p>Layout that can contain other layouts.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>class LayoutContainer(Layout):\n    \"\"\"Layout that can contain other layouts.\"\"\"\n\n    def __init__(self, main: BackendMainWindow | None = None):\n        self._rect = WindowRect(0, 0, 1000, 1000)\n        super().__init__(main)\n        self._anchor = _anc.AllCornersAnchor()\n        self._is_calling_adjust_child_resize = False\n\n    @contextmanager\n    def _adjust_child_resize_context(self):\n        was = self._is_calling_adjust_child_resize\n        self._is_calling_adjust_child_resize = True\n        try:\n            yield\n        finally:\n            self._is_calling_adjust_child_resize = was\n\n    @property\n    def rect(self):\n        return self._rect\n\n    @rect.setter\n    def rect(self, value):\n        rect = WindowRect.from_tuple(*value)\n        rect_old = self._rect\n        self._rect = rect\n        self._resize_children(rect)\n        if parent := self._parent_layout_ref():\n            parent._adjust_child_resize(self, rect_old, rect)\n\n    @abstractmethod\n    def _resize_children(self, rect: WindowRect):\n        \"\"\"Resize all children layouts based on the geometry of this layout.\"\"\"\n\n    @abstractmethod\n    def remove(self, child: Layout) -&gt; None:\n        \"\"\"Remove a child layout from this layout.\"\"\"\n\n    # @abstractmethod\n    def _adjust_child_resize(\n        self, child: Layout, rect_old: WindowRect, rect_new: WindowRect\n    ):\n        \"\"\"Adjust layout container based on the child resize/move.\"\"\"\n</code></pre>"},{"location":"api/layout/#himena.layout.LayoutContainer._adjust_child_resize","title":"<code>_adjust_child_resize(child, rect_old, rect_new)</code>","text":"<p>Adjust layout container based on the child resize/move.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>def _adjust_child_resize(\n    self, child: Layout, rect_old: WindowRect, rect_new: WindowRect\n):\n    \"\"\"Adjust layout container based on the child resize/move.\"\"\"\n</code></pre>"},{"location":"api/layout/#himena.layout.LayoutContainer._resize_children","title":"<code>_resize_children(rect)</code>  <code>abstractmethod</code>","text":"<p>Resize all children layouts based on the geometry of this layout.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>@abstractmethod\ndef _resize_children(self, rect: WindowRect):\n    \"\"\"Resize all children layouts based on the geometry of this layout.\"\"\"\n</code></pre>"},{"location":"api/layout/#himena.layout.LayoutContainer.remove","title":"<code>remove(child)</code>  <code>abstractmethod</code>","text":"<p>Remove a child layout from this layout.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>@abstractmethod\ndef remove(self, child: Layout) -&gt; None:\n    \"\"\"Remove a child layout from this layout.\"\"\"\n</code></pre>"},{"location":"api/layout/#himena.layout.VBoxLayout","title":"<code>VBoxLayout</code>","text":"<p>A vertical box layout.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>class VBoxLayout(BoxLayout1D):\n    \"\"\"A vertical box layout.\"\"\"\n\n    def _iter_edge_and_span(self, rect: WindowRect) -&gt; Iterator[tuple[int, int]]:\n        num = len(self._children)\n        if num == 0:\n            yield from ()\n            return\n        h_cumsum = np.cumsum([0] + self._stretches, dtype=np.float32)\n        edges = (h_cumsum / h_cumsum[-1] * rect.height).astype(np.int32)\n        dy = self.spacing // 2\n        edges[0] += self._margins.top - dy\n        edges[-1] += self._margins.bottom + dy\n        for i in range(num):\n            top = edges[i] + dy\n            height = edges[i + 1] - edges[i] - self.spacing\n            yield top, height\n\n    def _ortho_region(self, rect: WindowRect) -&gt; tuple[int, int]:\n        width = rect.width - self._margins.left - self._margins.right\n        left = rect.left + self._margins.left\n        return left, width\n\n    def _resize_children(self, rect: WindowRect):\n        left, width = self._ortho_region(rect)\n        with self._adjust_child_resize_context():\n            for i, (top, height) in enumerate(self._iter_edge_and_span(rect)):\n                irect = WindowRect(left, top, width, height)\n                self._children[i].rect = irect\n        return None\n\n    def _adjust_child_resize(self, child: Layout, rect_old, rect_new):\n        if self._is_calling_adjust_child_resize:\n            return\n        top_changed = rect_old.top != rect_new.top\n        bottom_changed = rect_old.bottom != rect_new.bottom\n        with self._adjust_child_resize_context():\n            if top_changed and bottom_changed:\n                return self._may_take_child(child, rect_old, rect_new)\n\n            top, height = self._ortho_region(self.rect)\n            new_rect = child.rect\n            stretches = self._stretches.copy()\n            for i, (left, width) in enumerate(self._iter_edge_and_span(self.rect)):\n                stretches[i] = width\n                if top_changed and self._children[i] is child:\n                    if i == 0:\n                        child.rect = WindowRect(left, top, width, height)\n                    else:\n                        old_sum = stretches[i - 1] + stretches[i]\n                        stretches[i - 1] = old_sum - new_rect.height\n                        stretches[i] = new_rect.height\n                elif bottom_changed and self._children[i - 1] is child:\n                    if i == len(self) - 1:\n                        child.rect = WindowRect(left, top, width, height)\n                    else:\n                        old_sum = stretches[i - 1] + stretches[i]\n                        stretches[i] = old_sum - new_rect.height\n                        stretches[i - 1] = new_rect.height\n                else:\n                    child.rect = WindowRect(left, top, width, height)\n            self._stretches = stretches\n            self._resize_children(self.rect)\n</code></pre>"},{"location":"api/layout/#himena.layout.VStackLayout","title":"<code>VStackLayout</code>","text":"Source code in <code>src\\himena\\layout.py</code> <pre><code>class VStackLayout(Layout1D):\n    def __init__(\n        self,\n        main: BackendMainWindow | None = None,\n        *,\n        margins: Margins[int] | tuple[int, int, int, int] = (0, 0, 0, 0),\n        spacing: int = 0,\n        inverted: bool = False,\n    ):\n        super().__init__(main, margins=margins, spacing=spacing)\n        self._inverted = inverted\n\n    @property\n    def inverted(self) -&gt; bool:\n        return self._inverted\n\n    @inverted.setter\n    def inverted(self, value: bool):\n        self._inverted = bool(value)\n        self._resize_children(self.rect)\n\n    def insert(self, index: int, child: Layout) -&gt; None:\n        \"\"\"Insert a child layout at the specified index.\"\"\"\n        self._children.insert(index, child)\n        child._main_window_ref = self._main_window_ref\n        child._parent_layout_ref = weakref.ref(self)\n        self._resize_children(self.rect)\n        return self\n\n    def append(self, child: Layout) -&gt; None:\n        return self.insert(len(self), child)\n\n    def add(self, child: Layout) -&gt; Self:\n        self.append(child)\n        return self\n\n    def __delitem__(self, key: int):\n        _assert_supports_index(key)\n        self._children[key]._parent_layout_ref = _no_ref\n        del self._children[key]\n        self._resize_children(self.rect)\n\n    def _resize_children(self, rect):\n        num = len(self._children)\n        if num == 0:\n            return\n        heights = [ch.rect.height for ch in self._children]\n        h_cumsum = np.cumsum([0] + heights, dtype=np.uint32)\n        if self._inverted:\n            bottoms = rect.bottom - h_cumsum[:-1] + self._margins.bottom\n            for i, child in enumerate(self._children):\n                child.rect = child.rect.move_bottom_left(rect.left, bottoms[i])\n        else:\n            tops = h_cumsum[:-1] + rect.top + self._margins.top\n            for i, child in enumerate(self._children):\n                child.rect = child.rect.move_top_left(rect.left, tops[i])\n</code></pre>"},{"location":"api/layout/#himena.layout.VStackLayout.insert","title":"<code>insert(index, child)</code>","text":"<p>Insert a child layout at the specified index.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>def insert(self, index: int, child: Layout) -&gt; None:\n    \"\"\"Insert a child layout at the specified index.\"\"\"\n    self._children.insert(index, child)\n    child._main_window_ref = self._main_window_ref\n    child._parent_layout_ref = weakref.ref(self)\n    self._resize_children(self.rect)\n    return self\n</code></pre>"},{"location":"api/plugins/","title":"himena.plugins","text":""},{"location":"api/plugins/#himena.plugins.AppActionRegistry","title":"<code>AppActionRegistry</code>","text":"Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>class AppActionRegistry:\n    _global_instance: AppActionRegistry | None = None\n\n    def __init__(self):\n        self._actions: dict[str, Action] = {}\n        self._actions_dynamic: set[str] = set()\n        self._submenu_titles: dict[str, str] = {MenuId.TOOLS_DOCK: \"Dock widgets\"}\n        self._submenu_groups: dict[str, str] = {MenuId.TOOLS_DOCK: \"00_dock\"}\n        self._installed_plugins: list[str] = []\n        self._plugin_default_configs: dict[str, PluginConfigTuple] = {}\n\n    @classmethod\n    def instance(cls) -&gt; AppActionRegistry:\n        \"\"\"Get the global instance of the registry.\"\"\"\n        if cls._global_instance is None:\n            cls._global_instance = cls()\n        return cls._global_instance\n\n    def add_action(self, action: Action, is_dynamic: bool = False) -&gt; None:\n        \"\"\"Add an action to the registry.\"\"\"\n        id_ = action.id\n        if id_ in self._actions:\n            raise ValueError(f\"Action ID {id_} already exists.\")\n        self._actions[id_] = action\n        if is_dynamic:\n            self._actions_dynamic.add(id_)\n\n    @property\n    def installed_plugins(self) -&gt; list[str]:\n        \"\"\"List of modules or python paths that are installed as plugins.\"\"\"\n        return self._installed_plugins\n\n    def iter_actions(self, app: HimenaApplication) -&gt; Iterator[Action]:\n        for id_, action in self._actions.items():\n            if id_ not in app.commands:\n                yield action\n\n    def submenu_title(self, id: str) -&gt; str:\n        \"\"\"Get the title of a submenu.\"\"\"\n        if title := self._submenu_titles.get(id):\n            return title\n        return id.split(\"/\")[-1].title()\n\n    def submenu_group(self, id: str) -&gt; str | None:\n        \"\"\"Get the group of a submenu.\"\"\"\n        return self._submenu_groups.get(id, None)\n\n    @property\n    def submenu_titles(self) -&gt; dict[str, str]:\n        return self._submenu_titles\n\n    def install_to(\n        self,\n        app: HimenaApplication,\n        actions: list[Action] | None = None,\n    ) -&gt; list[str]:\n        \"\"\"Install actions to the application.\n\n        This method automatically adds submenus if they are not already exists, and\n        returns the list of added root menu IDs. Note that this does NOT updates the\n        GUI menubar and toolbar.\n        \"\"\"\n        # look for existing menu items\n        if actions is None:\n            actions = list(self.iter_actions(app))\n        existing_menu_ids = {_id.value for _id in MenuId if \"/\" not in _id.value}\n        for menu_id, menu in app.menus:\n            existing_menu_ids.add(menu_id)\n            for each in menu:\n                if isinstance(each, SubmenuItem):\n                    existing_menu_ids.add(each.submenu)\n\n        added_menu_ids = OrderedSet[str]()\n        for action in actions:\n            if action.menus is not None:\n                ids = [a.id for a in action.menus]\n                added_menu_ids.update(ids)\n\n        # add submenus if not exists\n        to_add: list[tuple[str, SubmenuItem]] = []\n        new_menu_ids: list[str] = []\n\n        for place in added_menu_ids - existing_menu_ids:\n            place_components = place.split(\"/\")\n            if len(place_components) == 1:\n                new_menu_ids.append(place)\n            for i in range(1, len(place_components)):\n                menu_id = \"/\".join(place_components[:i])\n                submenu = \"/\".join(place_components[: i + 1])\n                if submenu in existing_menu_ids:\n                    continue\n                title = self.submenu_title(submenu)\n                group = self.submenu_group(submenu)\n                item = SubmenuItem(title=title, submenu=submenu, group=group)\n                to_add.append((menu_id, item))\n\n        app.register_actions(actions)\n        app.menus.append_menu_items(to_add)\n        app._dynamic_command_ids.update(self._actions_dynamic)\n        return new_menu_ids\n</code></pre>"},{"location":"api/plugins/#himena.plugins.AppActionRegistry.installed_plugins","title":"<code>installed_plugins</code>  <code>property</code>","text":"<p>List of modules or python paths that are installed as plugins.</p>"},{"location":"api/plugins/#himena.plugins.AppActionRegistry.add_action","title":"<code>add_action(action, is_dynamic=False)</code>","text":"<p>Add an action to the registry.</p> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>def add_action(self, action: Action, is_dynamic: bool = False) -&gt; None:\n    \"\"\"Add an action to the registry.\"\"\"\n    id_ = action.id\n    if id_ in self._actions:\n        raise ValueError(f\"Action ID {id_} already exists.\")\n    self._actions[id_] = action\n    if is_dynamic:\n        self._actions_dynamic.add(id_)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.AppActionRegistry.install_to","title":"<code>install_to(app, actions=None)</code>","text":"<p>Install actions to the application.</p> <p>This method automatically adds submenus if they are not already exists, and returns the list of added root menu IDs. Note that this does NOT updates the GUI menubar and toolbar.</p> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>def install_to(\n    self,\n    app: HimenaApplication,\n    actions: list[Action] | None = None,\n) -&gt; list[str]:\n    \"\"\"Install actions to the application.\n\n    This method automatically adds submenus if they are not already exists, and\n    returns the list of added root menu IDs. Note that this does NOT updates the\n    GUI menubar and toolbar.\n    \"\"\"\n    # look for existing menu items\n    if actions is None:\n        actions = list(self.iter_actions(app))\n    existing_menu_ids = {_id.value for _id in MenuId if \"/\" not in _id.value}\n    for menu_id, menu in app.menus:\n        existing_menu_ids.add(menu_id)\n        for each in menu:\n            if isinstance(each, SubmenuItem):\n                existing_menu_ids.add(each.submenu)\n\n    added_menu_ids = OrderedSet[str]()\n    for action in actions:\n        if action.menus is not None:\n            ids = [a.id for a in action.menus]\n            added_menu_ids.update(ids)\n\n    # add submenus if not exists\n    to_add: list[tuple[str, SubmenuItem]] = []\n    new_menu_ids: list[str] = []\n\n    for place in added_menu_ids - existing_menu_ids:\n        place_components = place.split(\"/\")\n        if len(place_components) == 1:\n            new_menu_ids.append(place)\n        for i in range(1, len(place_components)):\n            menu_id = \"/\".join(place_components[:i])\n            submenu = \"/\".join(place_components[: i + 1])\n            if submenu in existing_menu_ids:\n                continue\n            title = self.submenu_title(submenu)\n            group = self.submenu_group(submenu)\n            item = SubmenuItem(title=title, submenu=submenu, group=group)\n            to_add.append((menu_id, item))\n\n    app.register_actions(actions)\n    app.menus.append_menu_items(to_add)\n    app._dynamic_command_ids.update(self._actions_dynamic)\n    return new_menu_ids\n</code></pre>"},{"location":"api/plugins/#himena.plugins.AppActionRegistry.instance","title":"<code>instance()</code>  <code>classmethod</code>","text":"<p>Get the global instance of the registry.</p> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>@classmethod\ndef instance(cls) -&gt; AppActionRegistry:\n    \"\"\"Get the global instance of the registry.\"\"\"\n    if cls._global_instance is None:\n        cls._global_instance = cls()\n    return cls._global_instance\n</code></pre>"},{"location":"api/plugins/#himena.plugins.AppActionRegistry.submenu_group","title":"<code>submenu_group(id)</code>","text":"<p>Get the group of a submenu.</p> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>def submenu_group(self, id: str) -&gt; str | None:\n    \"\"\"Get the group of a submenu.\"\"\"\n    return self._submenu_groups.get(id, None)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.AppActionRegistry.submenu_title","title":"<code>submenu_title(id)</code>","text":"<p>Get the title of a submenu.</p> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>def submenu_title(self, id: str) -&gt; str:\n    \"\"\"Get the title of a submenu.\"\"\"\n    if title := self._submenu_titles.get(id):\n        return title\n    return id.split(\"/\")[-1].title()\n</code></pre>"},{"location":"api/plugins/#himena.plugins.ReaderPlugin","title":"<code>ReaderPlugin</code>","text":"Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>class ReaderPlugin(_IOPluginBase):\n    def __init__(\n        self,\n        reader: Callable[[Path | list[Path]], WidgetDataModel],\n        matcher: Callable[[Path | list[Path]], bool] | None = None,\n        *,\n        priority: int = 100,\n    ):\n        super().__init__(reader, matcher, priority=priority)\n        self._skip_if_list = False\n        if hasattr(reader, \"__annotations__\"):\n            annot_types = list(reader.__annotations__.values())\n            if len(annot_types) == 1 and annot_types[0] in (\n                Path,\n                \"Path\",\n                ForwardRef(\"Path\"),\n            ):\n                self._skip_if_list = True\n\n    def read(self, path: Path | list[Path]) -&gt; WidgetDataModel:\n        \"\"\"Read file(s) and return a data model.\"\"\"\n        if isinstance(path, list):\n            paths: list[Path] = []\n            for p in path:\n                if not p.exists():\n                    raise FileNotFoundError(f\"File {p!r} does not exist.\")\n                paths.append(p)\n            out = self._func(paths)\n        else:\n            path = Path(path)\n            if not path.exists():\n                raise FileNotFoundError(f\"File {path!r} does not exist.\")\n            out = self._func(path)\n        if not isinstance(out, WidgetDataModel):\n            raise TypeError(f\"Reader plugin {self!r} did not return a WidgetDataModel.\")\n        return out\n\n    __call__ = read\n\n    def match_model_type(self, path: Path | list[Path]) -&gt; str | None:\n        \"\"\"True if the reader can read the file.\"\"\"\n        if self._skip_if_list and isinstance(path, list):\n            return None\n        if self._matcher is None:\n            return None\n        out = self._matcher(path)\n        if out is None or isinstance(out, str):\n            return out\n        raise TypeError(f\"Matcher {self._matcher!r} did not return a string.\")\n\n    def define_matcher(self, matcher: Callable[[Path | list[Path]], str | None]):\n        \"\"\"Mark a function as a matcher.\n\n        The matcher function should return a type string if the reader can read the\n        file, or None otherwise. If the reader function is annotated with `Path`, only\n        single Path input is forwarded to the matcher function, otherwise both `Path`\n        and `list[Path]` will be considered.\n\n        Examples\n        --------\n        A reader plugin that reads only text files:\n\n        ```python\n        @my_reader.define_matcher\n        def _(path: Path):\n            if path.suffix == \".txt\":\n                return \"text\"\n            return None\n        ```\n        \"\"\"\n        # NOTE: matcher don't have to return the priority. If users want to define\n        # a plugin that has different priority for different file type, they can just\n        # split the plugin function into two.\n        if self._matcher is self._undefined_matcher:\n            raise ValueError(f\"Matcher for {self!r} is already defined.\")\n        self._matcher = matcher\n        return matcher\n\n    def read_and_update_source(self, source: Path | list[Path]) -&gt; WidgetDataModel:\n        \"\"\"Update workflow to a local-reader method if it is not set.\"\"\"\n        model = self.read(source)\n        if len(model.workflow) == 0:\n            model = model._with_source(source=source, plugin=self.plugin)\n        return model\n</code></pre>"},{"location":"api/plugins/#himena.plugins.ReaderPlugin.define_matcher","title":"<code>define_matcher(matcher)</code>","text":"<p>Mark a function as a matcher.</p> <p>The matcher function should return a type string if the reader can read the file, or None otherwise. If the reader function is annotated with <code>Path</code>, only single Path input is forwarded to the matcher function, otherwise both <code>Path</code> and <code>list[Path]</code> will be considered.</p> <p>Examples:</p> <p>A reader plugin that reads only text files:</p> <pre><code>@my_reader.define_matcher\ndef _(path: Path):\n    if path.suffix == \".txt\":\n        return \"text\"\n    return None\n</code></pre> Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>def define_matcher(self, matcher: Callable[[Path | list[Path]], str | None]):\n    \"\"\"Mark a function as a matcher.\n\n    The matcher function should return a type string if the reader can read the\n    file, or None otherwise. If the reader function is annotated with `Path`, only\n    single Path input is forwarded to the matcher function, otherwise both `Path`\n    and `list[Path]` will be considered.\n\n    Examples\n    --------\n    A reader plugin that reads only text files:\n\n    ```python\n    @my_reader.define_matcher\n    def _(path: Path):\n        if path.suffix == \".txt\":\n            return \"text\"\n        return None\n    ```\n    \"\"\"\n    # NOTE: matcher don't have to return the priority. If users want to define\n    # a plugin that has different priority for different file type, they can just\n    # split the plugin function into two.\n    if self._matcher is self._undefined_matcher:\n        raise ValueError(f\"Matcher for {self!r} is already defined.\")\n    self._matcher = matcher\n    return matcher\n</code></pre>"},{"location":"api/plugins/#himena.plugins.ReaderPlugin.match_model_type","title":"<code>match_model_type(path)</code>","text":"<p>True if the reader can read the file.</p> Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>def match_model_type(self, path: Path | list[Path]) -&gt; str | None:\n    \"\"\"True if the reader can read the file.\"\"\"\n    if self._skip_if_list and isinstance(path, list):\n        return None\n    if self._matcher is None:\n        return None\n    out = self._matcher(path)\n    if out is None or isinstance(out, str):\n        return out\n    raise TypeError(f\"Matcher {self._matcher!r} did not return a string.\")\n</code></pre>"},{"location":"api/plugins/#himena.plugins.ReaderPlugin.read","title":"<code>read(path)</code>","text":"<p>Read file(s) and return a data model.</p> Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>def read(self, path: Path | list[Path]) -&gt; WidgetDataModel:\n    \"\"\"Read file(s) and return a data model.\"\"\"\n    if isinstance(path, list):\n        paths: list[Path] = []\n        for p in path:\n            if not p.exists():\n                raise FileNotFoundError(f\"File {p!r} does not exist.\")\n            paths.append(p)\n        out = self._func(paths)\n    else:\n        path = Path(path)\n        if not path.exists():\n            raise FileNotFoundError(f\"File {path!r} does not exist.\")\n        out = self._func(path)\n    if not isinstance(out, WidgetDataModel):\n        raise TypeError(f\"Reader plugin {self!r} did not return a WidgetDataModel.\")\n    return out\n</code></pre>"},{"location":"api/plugins/#himena.plugins.ReaderPlugin.read_and_update_source","title":"<code>read_and_update_source(source)</code>","text":"<p>Update workflow to a local-reader method if it is not set.</p> Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>def read_and_update_source(self, source: Path | list[Path]) -&gt; WidgetDataModel:\n    \"\"\"Update workflow to a local-reader method if it is not set.\"\"\"\n    model = self.read(source)\n    if len(model.workflow) == 0:\n        model = model._with_source(source=source, plugin=self.plugin)\n    return model\n</code></pre>"},{"location":"api/plugins/#himena.plugins.WriterPlugin","title":"<code>WriterPlugin</code>","text":"Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>class WriterPlugin(_IOPluginBase):\n    def __init__(\n        self,\n        writer: Callable[[WidgetDataModel, Path], Any],\n        matcher: Callable[[Path | list[Path]], bool] | None = None,\n        *,\n        priority: int = 100,\n    ):\n        super().__init__(writer, matcher, priority=priority)\n        if arg := get_widget_data_model_type_arg(writer):\n            self._value_type_filter = arg\n        else:\n            self._value_type_filter = None\n\n    def write(self, model: WidgetDataModel, path: Path) -&gt; None:\n        return self._func(model, path)\n\n    __call__ = write\n\n    def match_input(self, model: WidgetDataModel, path: Path) -&gt; bool:\n        if self._value_type_filter is not None and not isinstance(\n            model.value, self._value_type_filter\n        ):\n            return False\n        return self._matcher(model, path)\n\n    def define_matcher(\n        self, matcher: Callable[[WidgetDataModel, Path], bool]\n    ) -&gt; WriterPlugin:\n        \"\"\"Define how to match the input data model and the save path to this writer.\n\n        Examples\n        --------\n        ```python\n        @my_writer.define_matcher\n        def _(model: WidgetDataModel, path: Path) -&gt; bool:\n            return path.suffix == \".txt\" and model.type == \"text\"\n        \"\"\"\n        self._matcher = matcher\n        return self\n</code></pre>"},{"location":"api/plugins/#himena.plugins.WriterPlugin.define_matcher","title":"<code>define_matcher(matcher)</code>","text":"<p>Define how to match the input data model and the save path to this writer.</p> <p>Examples:</p> <p>```python @my_writer.define_matcher def _(model: WidgetDataModel, path: Path) -&gt; bool:     return path.suffix == \".txt\" and model.type == \"text\"</p> Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>def define_matcher(\n    self, matcher: Callable[[WidgetDataModel, Path], bool]\n) -&gt; WriterPlugin:\n    \"\"\"Define how to match the input data model and the save path to this writer.\n\n    Examples\n    --------\n    ```python\n    @my_writer.define_matcher\n    def _(model: WidgetDataModel, path: Path) -&gt; bool:\n        return path.suffix == \".txt\" and model.type == \"text\"\n    \"\"\"\n    self._matcher = matcher\n    return self\n</code></pre>"},{"location":"api/plugins/#himena.plugins.configure_gui","title":"<code>configure_gui(f=None, *, title=None, preview=False, auto_close=True, show_parameter_labels=True, gui_options=None, result_as='window', **kwargs)</code>","text":"<pre><code>configure_gui(f: _F, *, title: str | None = None, preview: bool = False, auto_close: bool = True, show_parameter_labels: bool = True, gui_options: dict[str, Any] | None = None, result_as: Literal['window', 'below', 'right'] = 'window', **kwargs) -&gt; _F\n</code></pre><pre><code>configure_gui(*, title: str | None = None, preview: bool = False, auto_close: bool = True, show_parameter_labels: bool = True, gui_options: dict[str, Any] | None = None, result_as: Literal['window', 'below', 'right'] = 'window', **kwargs) -&gt; Callable[[_F], _F]\n</code></pre> <p>Configure the parametric GUI.</p> <p>This decorator sets the configuration options for the parametric GUI window.</p> <pre><code>@configure_gui(a={\"label\": \"A\", \"widget_type\": \"FloatSlider\"})\ndef my_func(a: float):\n    pass\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title of the parametric GUI window. If not provided, this title will be determined by the action title where this function is returned.</p> <code>None</code> <code>preview</code> <code>bool</code> <p>If true, a preview toggle switch will be added to the GUI window. When the switch is on, the function will be called and the result will be displayed. Note that <code>configure_gui</code> does not consider whether the preview is a heavy operation.</p> <code>False</code> <code>auto_close</code> <code>bool</code> <p>If true, the parametric GUI window will be closed automatically after the function is executed.</p> <code>True</code> <code>show_parameter_labels</code> <code>bool</code> <p>If true, the parameter names will be shown in the GUI window.</p> <code>True</code> <code>gui_options</code> <code>dict</code> <p>Additional GUI options to be passed to the <code>magicgui</code> decorator. Keys can also be passed as variable keyword arguments **kwargs.</p> <code>None</code> Source code in <code>src\\himena\\plugins\\_signature.py</code> <pre><code>def configure_gui(\n    f=None,\n    *,\n    title: str | None = None,\n    preview: bool = False,\n    auto_close: bool = True,\n    show_parameter_labels: bool = True,\n    gui_options: dict[str, Any] | None = None,\n    result_as: Literal[\"window\", \"below\", \"right\"] = \"window\",\n    **kwargs,\n):\n    \"\"\"Configure the parametric GUI.\n\n    This decorator sets the configuration options for the parametric GUI window.\n\n    ``` python\n    @configure_gui(a={\"label\": \"A\", \"widget_type\": \"FloatSlider\"})\n    def my_func(a: float):\n        pass\n    ```\n\n    Parameters\n    ----------\n    title : str, optional\n        The title of the parametric GUI window. If not provided, this title will be\n        determined by the action title where this function is returned.\n    preview : bool, default False\n        If true, a preview toggle switch will be added to the GUI window. When the\n        switch is on, the function will be called and the result will be displayed. Note\n        that `configure_gui` does not consider whether the preview is a heavy operation.\n    auto_close : bool, default True\n        If true, the parametric GUI window will be closed automatically after the\n        function is executed.\n    show_parameter_labels : bool, default True\n        If true, the parameter names will be shown in the GUI window.\n    gui_options : dict, optional\n        Additional GUI options to be passed to the `magicgui` decorator. Keys can also\n        be passed as variable keyword arguments **kwargs.\n    \"\"\"\n    kwargs = dict(**kwargs, **(gui_options or {}))\n\n    def _inner(f):\n        sig = inspect.signature(f)\n        new_params = sig.parameters.copy()\n        if var_kwargs_name := _get_var_kwargs_name(sig):\n            new_params.pop(var_kwargs_name)\n\n        for k, v in kwargs.items():\n            if k not in new_params:\n                if var_kwargs_name is None:\n                    raise TypeError(f\"{k!r} is not a valid parameter for {f!r}.\")\n                # This allows using **kwargs in the target function so that magicgui\n                # widget can be created for a variable number of parameters.\n                param = inspect.Parameter(name=k, kind=inspect.Parameter.KEYWORD_ONLY)\n            else:\n                param = sig.parameters[k]\n            # unwrap Annotated types\n            if not _is_annotated(param.annotation):\n                annot = _prioritize_choices(param.annotation, v)\n                param = param.replace(annotation=Annotated[annot, v])\n            else:\n                typ, meta = _split_annotated_type(param.annotation)\n                meta.update(v)\n                typ = _prioritize_choices(typ, meta)\n                param = param.replace(annotation=Annotated[typ, meta])\n            new_params[k] = param\n        # update the signature with the normalize one\n        sig = sig.replace(parameters=list(new_params.values()))\n        f.__signature__ = sig\n        f.__annotations__ = {k: v.annotation for k, v in sig.parameters.items()}\n        if sig.return_annotation is not inspect.Parameter.empty:\n            f.__annotations__[\"return\"] = sig.return_annotation\n\n        GuiConfiguration(\n            title=title,\n            preview=preview,\n            auto_close=auto_close,\n            show_parameter_labels=show_parameter_labels,\n            result_as=result_as,\n        ).set(f)\n        return f\n\n    return _inner if f is None else _inner(f)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.configure_submenu","title":"<code>configure_submenu(submenu_id, title=None, *, group=None)</code>","text":"<p>Register a configuration for submenu(s).</p> <p>Parameters:</p> Name Type Description Default <code>submenu_id</code> <code>str or iterable of str</code> <p>Submenu ID(s) to configure.</p> required <code>title</code> <code>str</code> <p>Specify the title of the submenu.</p> <code>None</code> <code>group</code> <code>str</code> <p>Specify the group ID of the submenu.</p> <code>None</code> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>def configure_submenu(\n    submenu_id: str | Iterable[str],\n    title: str | None = None,\n    *,\n    group: str | None = None,\n) -&gt; None:\n    \"\"\"Register a configuration for submenu(s).\n\n    Parameters\n    ----------\n    submenu_id : str or iterable of str\n        Submenu ID(s) to configure.\n    title : str, optional\n        Specify the title of the submenu.\n    group : str, optional\n        Specify the group ID of the submenu.\n    \"\"\"\n    if isinstance(submenu_id, str):\n        submenu_id = [submenu_id]\n    for sid in submenu_id:\n        if title is not None:\n            AppActionRegistry.instance()._submenu_titles[sid] = title\n        if group is not None:\n            AppActionRegistry.instance()._submenu_groups[sid] = group\n</code></pre>"},{"location":"api/plugins/#himena.plugins.install_plugins","title":"<code>install_plugins(app, plugins)</code>","text":"<p>Install plugins to the application.</p> Source code in <code>src\\himena\\plugins\\install.py</code> <pre><code>def install_plugins(app: Application, plugins: list[str]) -&gt; list[PluginInstallResult]:\n    \"\"\"Install plugins to the application.\"\"\"\n    from importlib import import_module\n    from himena.plugins import AppActionRegistry\n    from himena.profile import load_app_profile\n\n    reg = AppActionRegistry.instance()\n    results = []\n    for name in plugins:\n        if name in reg._installed_plugins:\n            continue\n        _time_0 = timer()\n        _exc = None\n        if isinstance(name, str):\n            if name.endswith(\".py\"):\n                if not Path(name).exists():\n                    _LOGGER.error(f\"Plugin file {name} not found.\")\n                    continue\n                import runpy\n\n                runpy.run_path(name)\n            else:\n                try:\n                    import_module(name)\n                except ModuleNotFoundError:\n                    _LOGGER.error(f\"Plugin {name} not found.\")\n                    continue\n                except Exception as e:\n                    _LOGGER.error(f\"Error installing plugin {name}: {e}\")\n                    _exc = e\n        else:\n            raise TypeError(f\"Invalid plugin type: {type(name)}\")\n        _msec = (timer() - _time_0) * 1000\n        _LOGGER.info(f\"Plugin {name} installed in {_msec:.3f} msec.\")\n        results.append(PluginInstallResult(name, _msec, _exc))\n    reg.install_to(app)\n    reg._installed_plugins.extend(plugins)\n    prof = load_app_profile(app.name)\n\n    for k, cfg in reg._plugin_default_configs.items():\n        prof.plugin_configs.setdefault(k, cfg.as_dict())\n\n    prof.save()\n    return results\n</code></pre>"},{"location":"api/plugins/#himena.plugins.override_keybindings","title":"<code>override_keybindings(app, prof)</code>","text":"<p>Override keybindings in the application.</p> Source code in <code>src\\himena\\plugins\\install.py</code> <pre><code>def override_keybindings(app: Application, prof: AppProfile) -&gt; None:\n    \"\"\"Override keybindings in the application.\"\"\"\n    for ko in prof.keybinding_overrides:\n        if kb := app.keybindings.get_keybinding(ko.command_id):\n            app.keybindings._keybindings.remove(kb)\n        app.keybindings.register_keybinding_rule(\n            ko.command_id,\n            KeyBindingRule(primary=ko.key),\n        )\n</code></pre>"},{"location":"api/plugins/#himena.plugins.register_conversion_rule","title":"<code>register_conversion_rule(*args, **kwargs)</code>","text":"<pre><code>register_conversion_rule(func: _F, type_from: str, type_to: str, *, keybindings: KeyBindingsType | None = None, command_id: str | None = None) -&gt; _F\n</code></pre><pre><code>register_conversion_rule(type_from: str, type_to: str, *, keybindings: KeyBindingsType | None = None, command_id: str | None = None) -&gt; Callable[[_F], _F]\n</code></pre> <p>Register a function as a conversion rule.</p> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>def register_conversion_rule(*args, **kwargs):\n    \"\"\"Register a function as a conversion rule.\"\"\"\n    if len(args) == 0:\n        no_func = True\n    else:\n        if isinstance(args[0], str):\n            return register_conversion_rule(None, *args, **kwargs)\n        no_func = args[0] is None\n\n    def inner(func):\n        annot = getattr(func, \"__annotations__\", {})\n        annot.setdefault(\"return\", WidgetDataModel)\n        func.__annotations__ = annot\n        action = make_conversion_rule(func, *args, **kwargs)\n        AppActionRegistry.instance().add_action(action)\n        return func\n\n    return inner if no_func else inner(args[0])\n</code></pre>"},{"location":"api/plugins/#himena.plugins.register_dock_widget_action","title":"<code>register_dock_widget_action(widget_factory=None, *, menus=None, title=None, area=DockArea.RIGHT, allowed_areas=None, keybindings=None, singleton=False, plugin_configs=None, command_id=None)</code>","text":"<pre><code>register_dock_widget_action(widget_factory: _F, *, menus: str | Sequence[str] | None = None, title: str | None = None, area: DockArea | DockAreaString = DockArea.RIGHT, allowed_areas: Sequence[DockArea | DockAreaString] | None = None, keybindings: KeyBindingsType | None = None, singleton: bool = False, plugin_configs: PluginConfigType | None = None, command_id: str | None = None) -&gt; _F\n</code></pre><pre><code>register_dock_widget_action(widget_factory: None = None, *, menus: str | Sequence[str] | None = None, title: str | None = None, area: DockArea | DockAreaString = DockArea.RIGHT, allowed_areas: Sequence[DockArea | DockAreaString] | None = None, keybindings: KeyBindingsType | None = None, singleton: bool = False, plugin_configs: PluginConfigType | None = None, command_id: str | None = None) -&gt; Callable[[_F], _F]\n</code></pre> <p>Register a widget factory as a dock widget function.</p> <p>Parameters:</p> Name Type Description Default <code>widget_factory</code> <code>callable</code> <p>Class of dock widget, or a factory function for the dock widget.</p> <code>None</code> <code>menus</code> <code>str or sequence of str</code> <p>Menu ID or list of menu IDs where the action will be added.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title of the dock widget.</p> <code>None</code> <code>area</code> <code>DockArea or DockAreaString</code> <p>Initial area of the dock widget.</p> <code>RIGHT</code> <code>allowed_areas</code> <code>sequence of DockArea or DockAreaString</code> <p>List of areas that is allowed for the dock widget.</p> <code>None</code> <code>keybindings</code> <code>sequence of keybinding rule</code> <p>Keybindings to trigger the dock widget.</p> <code>None</code> <code>singleton</code> <code>bool</code> <p>If true, the registered dock widget will constructed only once.</p> <code>False</code> <code>plugin_configs</code> <code>(dict, dataclass or BaseModel)</code> <p>Default configuration for the plugin. This config will be saved in the application profile and will be used to update the dock widget via the method <code>update_configs(self, cfg) -&gt; None</code>. This argument must be a dict, dataclass or pydantic.BaseModel. If a dict, the format must be like:</p> <pre><code>plugin_configs = {\n   \"config_0\": {\"value\": 0, \"tooltip\": ...},\n   \"config_1\": {\"value\": \"xyz\", \"tooltip\": ...},\n}\n</code></pre> <p>where only \"value\" is required. If a dataclass or pydantic.BaseModel, field objects will be used instead of the dict.</p> <pre><code>@dataclass\nclass MyPluginConfig:\n    config_0: int = Field(default=0, metadata={\"tooltip\": ...})\n    config_1: str = Field(default=\"xyz\", metadata={\"tooltip\": ...})\nplugin_configs = MyPluginConfig()\n</code></pre> <code>None</code> <code>command_id</code> <code>str</code> <p>Command ID. If not given, the function name will be used.</p> <code>None</code> Source code in <code>src\\himena\\plugins\\widget_plugins.py</code> <pre><code>def register_dock_widget_action(\n    widget_factory=None,\n    *,\n    menus: str | Sequence[str] | None = None,\n    title: str | None = None,\n    area: DockArea | DockAreaString = DockArea.RIGHT,\n    allowed_areas: Sequence[DockArea | DockAreaString] | None = None,\n    keybindings=None,\n    singleton: bool = False,\n    plugin_configs: PluginConfigType | None = None,\n    command_id: str | None = None,\n):\n    \"\"\"Register a widget factory as a dock widget function.\n\n    Parameters\n    ----------\n    widget_factory : callable, optional\n        Class of dock widget, or a factory function for the dock widget.\n    menus : str or sequence of str, optional\n        Menu ID or list of menu IDs where the action will be added.\n    title : str, optional\n        Title of the dock widget.\n    area : DockArea or DockAreaString, optional\n        Initial area of the dock widget.\n    allowed_areas : sequence of DockArea or DockAreaString, optional\n        List of areas that is allowed for the dock widget.\n    keybindings : sequence of keybinding rule, optional\n        Keybindings to trigger the dock widget.\n    singleton : bool, default False\n        If true, the registered dock widget will constructed only once.\n    plugin_configs : dict, dataclass or pydantic.BaseModel, optional\n        Default configuration for the plugin. This config will be saved in the\n        application profile and will be used to update the dock widget via the method\n        `update_configs(self, cfg) -&gt; None`. This argument must be a dict, dataclass\n        or pydantic.BaseModel. If a dict, the format must be like:\n\n        ``` python\n        plugin_configs = {\n           \"config_0\": {\"value\": 0, \"tooltip\": ...},\n           \"config_1\": {\"value\": \"xyz\", \"tooltip\": ...},\n        }\n        ```\n\n        where only \"value\" is required. If a dataclass or pydantic.BaseModel, field\n        objects will be used instead of the dict.\n\n        ``` python\n        @dataclass\n        class MyPluginConfig:\n            config_0: int = Field(default=0, metadata={\"tooltip\": ...})\n            config_1: str = Field(default=\"xyz\", metadata={\"tooltip\": ...})\n        plugin_configs = MyPluginConfig()\n        ```\n    command_id : str, optional\n        Command ID. If not given, the function name will be used.\n    \"\"\"\n    kbs = normalize_keybindings(keybindings)\n    if menus is None:\n        menus = [MenuId.TOOLS_DOCK]\n\n    def _inner(wf: Callable):\n        _command_id = command_id_from_func(wf, command_id)\n        _callback = DockWidgetCallback(\n            wf,\n            title=title,\n            area=area,\n            allowed_areas=allowed_areas,\n            singleton=singleton,\n            uuid=uuid.uuid4(),\n            command_id=_command_id,\n        )\n        if singleton:\n            toggle_rule = ToggleRule(get_current=_callback.widget_visible)\n        else:\n            toggle_rule = None\n        action = Action(\n            id=_command_id,\n            title=_callback._title,\n            tooltip=tooltip_from_func(wf),\n            callback=_callback,\n            menus=norm_menus(menus),\n            keybindings=kbs,\n            toggled=toggle_rule,\n        )\n        reg = AppActionRegistry.instance()\n        reg.add_action(action)\n        if plugin_configs:\n            cfg_type = type(plugin_configs)\n            reg._plugin_default_configs[_command_id] = PluginConfigTuple(\n                _callback._title,\n                plugin_configs,\n                cfg_type,\n            )\n        return wf\n\n    return _inner if widget_factory is None else _inner(widget_factory)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.register_function","title":"<code>register_function(func=None, *, menus='plugins', title=None, types=None, enablement=None, keybindings=None, run_async=False, command_id=None)</code>","text":"<pre><code>register_function(func: None = None, *, menus: str | Sequence[str] = 'plugins', title: str | None = None, types: str | Sequence[str] | None = None, enablement: BoolOp | None = None, keybindings: Sequence[KeyBindingRule] | None = None, run_async: bool = False, command_id: str | None = None) -&gt; None\n</code></pre><pre><code>register_function(func: _F, *, menus: str | Sequence[str] = 'plugins', title: str | None = None, types: str | Sequence[str] | None = None, enablement: BoolOp | None = None, keybindings: Sequence[KeyBindingRule] | None = None, run_async: bool = False, command_id: str | None = None) -&gt; _F\n</code></pre> <p>Register a function as a callback of a plugin action.</p> <p>This function can be used either as a decorator or a simple function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>Function to register as an action.</p> <code>None</code> <code>menus</code> <code>str or sequence of str</code> <p>Menu(s) to add the action. Submenus are separated by <code>/</code>.</p> <code>\"plugins\"</code> <code>title</code> <code>str</code> <p>Title of the action. Name of the function will be used if not given.</p> <code>None</code> <code>types</code> <p>The <code>type</code> parameter(s) allowed as the WidgetDataModel. If this parameter is given, action will be grayed out if the active window does not satisfy the listed types.</p> <code>None</code> <code>enablement</code> <p>Expression that describes when the action will be enabled. As this argument is a generalized version of <code>types</code> argument, you cannot use both of them.</p> <code>None</code> <code>run_async</code> <code>bool</code> <p>If true, the function will be executed asynchronously. Note that if the function updates the GUI, running it asynchronously may cause issues.</p> <code>False</code> <code>command_id</code> <code>str</code> <p>Command ID. If not given, the function qualname will be used.</p> <code>None</code> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>def register_function(\n    func=None,\n    *,\n    menus=\"plugins\",\n    title=None,\n    types=None,\n    enablement=None,\n    keybindings=None,\n    run_async=False,\n    command_id=None,\n):\n    \"\"\"\n    Register a function as a callback of a plugin action.\n\n    This function can be used either as a decorator or a simple function.\n\n    Parameters\n    ----------\n    func : callable, optional\n        Function to register as an action.\n    menus : str or sequence of str, default \"plugins\"\n        Menu(s) to add the action. Submenus are separated by `/`.\n    title : str, optional\n        Title of the action. Name of the function will be used if not given.\n    types: str or sequence of str, optional\n        The `type` parameter(s) allowed as the WidgetDataModel. If this parameter\n        is given, action will be grayed out if the active window does not satisfy\n        the listed types.\n    enablement: Expr, optional\n        Expression that describes when the action will be enabled. As this argument\n        is a generalized version of `types` argument, you cannot use both of them.\n    run_async : bool, default False\n        If true, the function will be executed asynchronously. Note that if the function\n        updates the GUI, running it asynchronously may cause issues.\n    command_id : str, optional\n        Command ID. If not given, the function qualname will be used.\n    \"\"\"\n\n    def _inner(f: _F) -&gt; _F:\n        action = make_action_for_function(\n            f,\n            menus=menus,\n            title=title,\n            types=types,\n            enablement=enablement,\n            keybindings=keybindings,\n            run_async=run_async,\n            command_id=command_id,\n        )\n        AppActionRegistry.instance().add_action(action)\n        return f\n\n    return _inner if func is None else _inner(func)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.register_previewer_class","title":"<code>register_previewer_class(type_, widget_class)</code>","text":"<p>Register a widget class for previewing the given model type.</p> Source code in <code>src\\himena\\plugins\\widget_class.py</code> <pre><code>def register_previewer_class(type_: str, widget_class: type):\n    \"\"\"Register a widget class for previewing the given model type.\"\"\"\n\n    def inner(wcls):\n        import himena.qt\n\n        widget_id = get_widget_class_id(wcls)\n        if existing_class := _WIDGET_ID_TO_WIDGET_CLASS.get(widget_id):\n            raise ValueError(\n                f\"Widget class with ID {widget_id!r} already exists ({existing_class}).\"\n            )\n        _WIDGET_ID_TO_WIDGET_CLASS[widget_id] = wcls\n        himena.qt.register_widget_class(type_, wcls, priority=-10)\n        fn = OpenDataInFunction(type_, wcls)\n        AppActionRegistry.instance().add_action(fn.to_action(), is_dynamic=True)\n        fn = PreviewDataInFunction(type_, wcls)\n        AppActionRegistry.instance().add_action(fn.to_action(), is_dynamic=True)\n        return type_\n\n    return inner if widget_class is None else inner(widget_class)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.register_reader_plugin","title":"<code>register_reader_plugin(reader=None, *, priority=100)</code>","text":"<pre><code>register_reader_plugin(reader: Callable[[Path | list[Path]], WidgetDataModel], *, priority: int = 100) -&gt; ReaderPlugin\n</code></pre><pre><code>register_reader_plugin(*, priority: int = 100) -&gt; Callable[[Callable[[Path | list[Path]], WidgetDataModel]], ReaderPlugin]\n</code></pre> <p>Register a reader plugin function.</p> <p>Decorate a function to register it as a reader plugin. The function should take a <code>Path</code> or a list of <code>Path</code>s as input and return a WidgetDataModel.</p> <pre><code>from himena.plugins import register_reader_plugin\n\n@register_reader_plugin\ndef my_reader(path) -&gt; WidgetDataModel:\n    ...  # read file and return a WidgetDataModel\n</code></pre> <p>You will need to define a matcher function to tell whether this function can read a path using <code>define_matcher</code> method.</p> <pre><code>from himena import StandardType\n\n@my_reader.define_matcher\ndef _(path: Path):\n    if path.suffix == \".txt\":\n        return StandardType.TEXT  # StandardType.TEXT == \"text\"\n    return None\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>int</code> <p>Priority of choosing this reader when multiple readers are available. The default value 100 is higher than the himena builtin readers, so that your reader will prioritized over the default ones. If priority is less than 0, it will not be used unless users intentionally choose this plugin.</p> <code>100</code> Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>def register_reader_plugin(reader=None, *, priority=100):\n    \"\"\"Register a reader plugin function.\n\n    Decorate a function to register it as a reader plugin. The function should take a\n    `Path` or a list of `Path`s as input and return a WidgetDataModel.\n\n    ``` python\n    from himena.plugins import register_reader_plugin\n\n    @register_reader_plugin\n    def my_reader(path) -&gt; WidgetDataModel:\n        ...  # read file and return a WidgetDataModel\n    ```\n\n    You will need to define a matcher function to tell whether this function can read\n    a path using `define_matcher` method.\n\n    ```python\n    from himena import StandardType\n\n    @my_reader.define_matcher\n    def _(path: Path):\n        if path.suffix == \".txt\":\n            return StandardType.TEXT  # StandardType.TEXT == \"text\"\n        return None\n    ```\n\n    Parameters\n    ----------\n    priority : int, default 100\n        Priority of choosing this reader when multiple readers are available. The\n        default value 100 is higher than the himena builtin readers, so that your reader\n        will prioritized over the default ones. If priority is less than 0, it will not\n        be used unless users intentionally choose this plugin.\n    \"\"\"\n\n    def _inner(func):\n        if not callable(func):\n            raise ValueError(\"Reader plugin must be callable.\")\n        ins = ReaderStore().instance()\n\n        reader_plugin = ReaderPlugin(func, priority=priority)\n        ins.add_reader(reader_plugin)\n        return reader_plugin\n\n    return _inner if reader is None else _inner(reader)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.register_widget_class","title":"<code>register_widget_class(type_, widget_class=None, priority=100, plugin_configs=None)</code>","text":"<pre><code>register_widget_class(type_: str, widget_class: _T, priority: int = 100, plugin_configs: PluginConfigType | None = None) -&gt; _T\n</code></pre><pre><code>register_widget_class(type_: str, widget_class: None, priority: int = 100, plugin_configs: PluginConfigType | None = None) -&gt; Callable[[_T], _T]\n</code></pre> <p>Register a frontend widget class for the given model type.</p> <p>The <code>__init__</code> method of the registered class must not take any argument. The class must implement <code>update_model</code> method to update the widget state from a WidgetDataModel.</p> <pre><code>@register_widget(\"text\")\nclass MyTextEdit(QtW.QPlainTextEdit):\n    def update_model(self, model: WidgetDataModel):\n        self.setPlainText(model.value)\n</code></pre> <p>There are other method names that can be implemented to make the widget more functional.</p> <ul> <li><code>to_model(self) -&gt; WidgetDataModel</code>:</li> <li><code>model_type(self) -&gt; str</code>:</li> <li><code>control_widget(self) -&gt; &lt;widget&gt;</code>:</li> <li><code>is_modified(self) -&gt; bool</code>:</li> <li><code>set_modified(self, modified: bool)</code>:</li> <li><code>size_hint(self) -&gt; tuple[int, int]</code>:</li> <li><code>is_editable(self) -&gt; bool</code>:</li> <li><code>set_editable(self, editable: bool)</code>:</li> <li><code>dropped_callback(self, other: WidgetDataModel)</code>:</li> <li><code>allowed_drop_types(self) -&gt; list[str]</code>:</li> <li><code>display_name(cls) -&gt; str</code>:</li> <li><code>theme_changed_callback(self, theme: Theme)</code>:</li> <li><code>widget_activated_callback(self)</code>:</li> <li><code>widget_closed_callback(self)</code>:</li> <li><code>widget_resized_callback(self, size_old, size_new)</code>:</li> </ul> Source code in <code>src\\himena\\plugins\\widget_class.py</code> <pre><code>def register_widget_class(type_, widget_class=None, priority=100, plugin_configs=None):\n    \"\"\"Register a frontend widget class for the given model type.\n\n    The `__init__` method of the registered class must not take any argument. The class\n    must implement `update_model` method to update the widget state from a\n    WidgetDataModel.\n\n    ``` python\n    @register_widget(\"text\")\n    class MyTextEdit(QtW.QPlainTextEdit):\n        def update_model(self, model: WidgetDataModel):\n            self.setPlainText(model.value)\n    ```\n\n    There are other method names that can be implemented to make the widget more\n    functional.\n\n    - `to_model(self) -&gt; WidgetDataModel`:\n    - `model_type(self) -&gt; str`:\n    - `control_widget(self) -&gt; &lt;widget&gt;`:\n    - `is_modified(self) -&gt; bool`:\n    - `set_modified(self, modified: bool)`:\n    - `size_hint(self) -&gt; tuple[int, int]`:\n    - `is_editable(self) -&gt; bool`:\n    - `set_editable(self, editable: bool)`:\n    - `dropped_callback(self, other: WidgetDataModel)`:\n    - `allowed_drop_types(self) -&gt; list[str]`:\n    - `display_name(cls) -&gt; str`:\n    - `theme_changed_callback(self, theme: Theme)`:\n    - `widget_activated_callback(self)`:\n    - `widget_closed_callback(self)`:\n    - `widget_resized_callback(self, size_old, size_new)`:\n    \"\"\"\n\n    def inner(wcls):\n        import himena.qt\n\n        widget_id = get_widget_class_id(wcls)\n        if existing_class := _WIDGET_ID_TO_WIDGET_CLASS.get(widget_id):\n            raise ValueError(\n                f\"Widget class with ID {widget_id!r} already exists ({existing_class}).\"\n            )\n        _WIDGET_ID_TO_WIDGET_CLASS[widget_id] = wcls\n        himena.qt.register_widget_class(type_, wcls, priority=priority)\n        fn = OpenDataInFunction(type_, wcls)\n        reg = AppActionRegistry.instance()\n        reg.add_action(fn.to_action(), is_dynamic=True)\n        wcls.__himena_model_type__ = type_\n\n        if plugin_configs:\n            cfg_type = type(plugin_configs)\n            reg._plugin_default_configs[widget_id] = PluginConfigTuple(\n                get_display_name(wcls, sep=\" \", class_id=False),\n                plugin_configs,\n                cfg_type,\n            )\n        return wcls\n\n    return inner if widget_class is None else inner(widget_class)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.register_writer_plugin","title":"<code>register_writer_plugin(writer=None, *, priority=100)</code>","text":"<pre><code>register_writer_plugin(writer: Callable[[WidgetDataModel, Path], Any], *, priority: int = 100) -&gt; WriterPlugin\n</code></pre><pre><code>register_writer_plugin(*, priority: int = 100) -&gt; Callable[[Callable[[WidgetDataModel, Path], Any]], WriterPlugin]\n</code></pre> <p>Register a writer plugin function.</p> <p>Decorate a function to register it as a writer plugin. The function should take a <code>Path</code> as a save path and a <code>WidgetDataModel</code>.</p> <pre><code>from himena.plugins import register_writer_plugin\n\n@register_writer_plugin\ndef my_writer(path, model) -&gt; None:\n    ...  # read file and return a WidgetDataModel\n</code></pre> <p>You will need to define a matcher function to tell whether this function can write a data model to the specified path using <code>define_matcher</code> method. Unlike reader plugins, matchers should return bool.</p> <pre><code>from himena import StandardType, WidgetDataModel\n\n@my_writer.define_matcher\ndef _(path: Path, model: WidgetDataModel):\n    if path.suffix == \".txt\":\n        return True\n    return False\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>int</code> <p>Priority of choosing this writer when multiple writers are available. The default value 100 is higher than the himena builtin writers, so that your writer will prioritized over the default ones. If priority is less than 0, it will not be used unless users intentionally choose this plugin.</p> <code>100</code> Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>def register_writer_plugin(writer=None, *, priority=100):\n    \"\"\"Register a writer plugin function.\n\n    Decorate a function to register it as a writer plugin. The function should take a\n    `Path` as a save path and a `WidgetDataModel`.\n\n    ``` python\n    from himena.plugins import register_writer_plugin\n\n    @register_writer_plugin\n    def my_writer(path, model) -&gt; None:\n        ...  # read file and return a WidgetDataModel\n    ```\n\n    You will need to define a matcher function to tell whether this function can write\n    a data model to the specified path using `define_matcher` method. Unlike reader\n    plugins, matchers should return bool.\n\n    ```python\n    from himena import StandardType, WidgetDataModel\n\n    @my_writer.define_matcher\n    def _(path: Path, model: WidgetDataModel):\n        if path.suffix == \".txt\":\n            return True\n        return False\n    ```\n\n    Parameters\n    ----------\n    priority : int, default 100\n        Priority of choosing this writer when multiple writers are available. The\n        default value 100 is higher than the himena builtin writers, so that your writer\n        will prioritized over the default ones. If priority is less than 0, it will not\n        be used unless users intentionally choose this plugin.\n    \"\"\"\n\n    def _inner(func):\n        if not callable(func):\n            raise ValueError(\"Writer plugin must be callable.\")\n        ins = WriterStore().instance()\n\n        writer_plugin = WriterPlugin(func, priority=priority)\n        ins.add_writer(writer_plugin)\n        return writer_plugin\n\n    return _inner if writer is None else _inner(writer)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.validate_protocol","title":"<code>validate_protocol(f)</code>","text":"<p>Check if the method is allowed as a himena protocol.</p> Source code in <code>src\\himena\\plugins\\_checker.py</code> <pre><code>def validate_protocol(f: _T) -&gt; _T:\n    \"\"\"Check if the method is allowed as a himena protocol.\"\"\"\n    if f.__name__ not in _ALLOWED_METHODS:\n        raise ValueError(f\"Method {f} is not an allowed protocol name.\")\n    return f\n</code></pre>"},{"location":"api/plugins/#himena.plugins.widget_classes","title":"<code>widget_classes()</code>","text":"<p>Get the mapping of widget ID to widget class.</p> Source code in <code>src\\himena\\plugins\\widget_class.py</code> <pre><code>def widget_classes() -&gt; MappingProxyType[str, type]:\n    \"\"\"Get the mapping of widget ID to widget class.\"\"\"\n    from himena.qt.registry._api import _APP_TYPE_TO_QWIDGET\n\n    out = {}\n    for widget_list in _APP_TYPE_TO_QWIDGET.values():\n        for item in widget_list:\n            out[item.type] = item.widget_class\n    return MappingProxyType(out)\n</code></pre>"},{"location":"api/profile/","title":"himena.profile","text":""},{"location":"api/profile/#himena.profile.AppProfile","title":"<code>AppProfile</code>","text":"<p>Model of a profile.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the profile.</p> <code>'default'</code> <code>plugins</code> <code>list[str]</code> <p>List of plugins to load.</p> <code>['himena_builtins.qt.console', 'himena_builtins.qt.explorer', 'himena_builtins.qt.history', 'himena_builtins.qt.output', 'himena_builtins.qt.plot', 'himena_builtins.qt.widgets', 'himena_builtins.tools', 'himena_builtins.io', 'himena_builtins.new']</code> <code>theme</code> <code>str</code> <p>Theme to use.</p> <code>'light-green'</code> <code>startup_commands</code> <code>list[tuple[str, Optional[dict[str, Any]]]]</code> <p>Startup commands that will be executed when the app starts.</p> <code>&lt;dynamic&gt;</code> <code>keybinding_overrides</code> <code>list[KeyBindingOverride]</code> <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\profile.py</code> <pre><code>class AppProfile(BaseModel):\n    \"\"\"Model of a profile.\"\"\"\n\n    name: str = Field(\n        default=\"default\", description=\"Name of the profile.\", frozen=True\n    )\n    plugins: list[str] = Field(\n        default_factory=_default_plugins, description=\"List of plugins to load.\"\n    )\n    theme: str = Field(default=\"light-green\", description=\"Theme to use.\")\n    startup_commands: list[tuple[str, dict[str, Any] | None]] = Field(\n        default_factory=list,\n        description=\"Startup commands that will be executed when the app starts.\",\n    )\n    keybinding_overrides: list[KeyBindingOverride] = Field(default_factory=list)\n    plugin_configs: dict[str, dict[str, Any]] = Field(default_factory=dict)\n\n    @classmethod\n    def from_json(cls, path) -&gt; \"AppProfile\":\n        \"\"\"Construct an AppProfile from a json file.\"\"\"\n        with open(path) as f:\n            data = json.load(f)\n        return cls(**data)\n\n    @classmethod\n    def default(cls, save: bool = False) -&gt; \"AppProfile\":\n        \"\"\"Return the default profile.\"\"\"\n        prof = AppProfile()\n        if save and not (profile_dir() / f\"{prof.name}.json\").exists():\n            prof.save()\n        return prof\n\n    def save(self, path: str | Path | None = None) -&gt; None:\n        \"\"\"Save profile as a json file.\"\"\"\n        if path is None:\n            path = profile_dir() / f\"{self.name}.json\"\n        with open(path, \"w\") as f:\n            json.dump(self.model_dump(), f, indent=4)\n        return None\n\n    def with_name(self, name: str) -&gt; \"AppProfile\":\n        \"\"\"Return a new profile with a new name.\"\"\"\n        return self.model_copy(update={\"name\": name})\n\n    def with_plugins(self, plugins: list[str]) -&gt; \"AppProfile\":\n        \"\"\"Return a new profile with new plugins.\"\"\"\n        return self.model_copy(update={\"plugins\": plugins})\n\n    def with_plugin_configs(self, configs: dict[str, dict[str, Any]]) -&gt; \"AppProfile\":\n        \"\"\"Return a new profile with new plugin configs.\"\"\"\n        return self.model_copy(update={\"plugin_configs\": configs})\n\n    def with_keybinding_override(self, key: str, command_id: str) -&gt; \"AppProfile\":\n        \"\"\"Return a new profile with new keybind overrides.\"\"\"\n        _overrides = self.keybinding_overrides.copy()\n        for entry in _overrides:\n            if entry.command_id == command_id:\n                if key:\n                    entry.key = key\n                else:\n                    _overrides.remove(entry)\n                break\n        else:\n            if key:\n                _overrides.append(KeyBindingOverride(key=key, command_id=command_id))\n        return self.model_copy(update={\"keybinding_overrides\": _overrides})\n\n    def update_plugin_config(self, plugin_id: str, **kwargs) -&gt; None:\n        \"\"\"Update the config of the plugin specified by `plugin_id`\"\"\"\n        from himena.plugins.actions import AppActionRegistry\n        from himena.plugins.widget_plugins import WidgetCallbackBase\n\n        reg = AppActionRegistry.instance()\n        configs = self.plugin_configs.copy()\n        # NOTE: during development, keys of cur_config and configs[plugin_id] may\n        # differ. `cur_config` has all the keys that should exist in the current\n        # implementation.\n        cur_config = reg._plugin_default_configs[plugin_id].as_dict()\n        if plugin_id in configs:\n            # Profile already has the plugin config\n            for ckey, cval in configs[plugin_id].items():\n                if ckey in cur_config:\n                    cur_config[ckey] = cval\n        for k, v in kwargs.items():\n            if k in cur_config:\n                cur_config[k][\"value\"] = v\n        configs[plugin_id] = cur_config\n        self.with_plugin_configs(configs).save()\n\n        # update existing dock widgets with the new config\n        params = {}\n        for key, opt in cur_config.items():\n            params[key] = opt[\"value\"]\n        if cb := WidgetCallbackBase.instance_for_command_id(plugin_id):\n            for dock in cb._all_widgets:\n                # the internal widget should always has the method \"update_configs\"\n                dock.update_configs(params)\n\n    @field_validator(\"name\")\n    def _validate_name(cls, value):\n        # check if value is a valid file name\n        if not all(c in ALLOWED_LETTERS for c in value):\n            raise ValueError(f\"Invalid profile name: {value}\")\n        return value\n</code></pre>"},{"location":"api/profile/#himena.profile.AppProfile.default","title":"<code>default(save=False)</code>  <code>classmethod</code>","text":"<p>Return the default profile.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>@classmethod\ndef default(cls, save: bool = False) -&gt; \"AppProfile\":\n    \"\"\"Return the default profile.\"\"\"\n    prof = AppProfile()\n    if save and not (profile_dir() / f\"{prof.name}.json\").exists():\n        prof.save()\n    return prof\n</code></pre>"},{"location":"api/profile/#himena.profile.AppProfile.from_json","title":"<code>from_json(path)</code>  <code>classmethod</code>","text":"<p>Construct an AppProfile from a json file.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>@classmethod\ndef from_json(cls, path) -&gt; \"AppProfile\":\n    \"\"\"Construct an AppProfile from a json file.\"\"\"\n    with open(path) as f:\n        data = json.load(f)\n    return cls(**data)\n</code></pre>"},{"location":"api/profile/#himena.profile.AppProfile.save","title":"<code>save(path=None)</code>","text":"<p>Save profile as a json file.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def save(self, path: str | Path | None = None) -&gt; None:\n    \"\"\"Save profile as a json file.\"\"\"\n    if path is None:\n        path = profile_dir() / f\"{self.name}.json\"\n    with open(path, \"w\") as f:\n        json.dump(self.model_dump(), f, indent=4)\n    return None\n</code></pre>"},{"location":"api/profile/#himena.profile.AppProfile.update_plugin_config","title":"<code>update_plugin_config(plugin_id, **kwargs)</code>","text":"<p>Update the config of the plugin specified by <code>plugin_id</code></p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def update_plugin_config(self, plugin_id: str, **kwargs) -&gt; None:\n    \"\"\"Update the config of the plugin specified by `plugin_id`\"\"\"\n    from himena.plugins.actions import AppActionRegistry\n    from himena.plugins.widget_plugins import WidgetCallbackBase\n\n    reg = AppActionRegistry.instance()\n    configs = self.plugin_configs.copy()\n    # NOTE: during development, keys of cur_config and configs[plugin_id] may\n    # differ. `cur_config` has all the keys that should exist in the current\n    # implementation.\n    cur_config = reg._plugin_default_configs[plugin_id].as_dict()\n    if plugin_id in configs:\n        # Profile already has the plugin config\n        for ckey, cval in configs[plugin_id].items():\n            if ckey in cur_config:\n                cur_config[ckey] = cval\n    for k, v in kwargs.items():\n        if k in cur_config:\n            cur_config[k][\"value\"] = v\n    configs[plugin_id] = cur_config\n    self.with_plugin_configs(configs).save()\n\n    # update existing dock widgets with the new config\n    params = {}\n    for key, opt in cur_config.items():\n        params[key] = opt[\"value\"]\n    if cb := WidgetCallbackBase.instance_for_command_id(plugin_id):\n        for dock in cb._all_widgets:\n            # the internal widget should always has the method \"update_configs\"\n            dock.update_configs(params)\n</code></pre>"},{"location":"api/profile/#himena.profile.AppProfile.with_keybinding_override","title":"<code>with_keybinding_override(key, command_id)</code>","text":"<p>Return a new profile with new keybind overrides.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def with_keybinding_override(self, key: str, command_id: str) -&gt; \"AppProfile\":\n    \"\"\"Return a new profile with new keybind overrides.\"\"\"\n    _overrides = self.keybinding_overrides.copy()\n    for entry in _overrides:\n        if entry.command_id == command_id:\n            if key:\n                entry.key = key\n            else:\n                _overrides.remove(entry)\n            break\n    else:\n        if key:\n            _overrides.append(KeyBindingOverride(key=key, command_id=command_id))\n    return self.model_copy(update={\"keybinding_overrides\": _overrides})\n</code></pre>"},{"location":"api/profile/#himena.profile.AppProfile.with_name","title":"<code>with_name(name)</code>","text":"<p>Return a new profile with a new name.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def with_name(self, name: str) -&gt; \"AppProfile\":\n    \"\"\"Return a new profile with a new name.\"\"\"\n    return self.model_copy(update={\"name\": name})\n</code></pre>"},{"location":"api/profile/#himena.profile.AppProfile.with_plugin_configs","title":"<code>with_plugin_configs(configs)</code>","text":"<p>Return a new profile with new plugin configs.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def with_plugin_configs(self, configs: dict[str, dict[str, Any]]) -&gt; \"AppProfile\":\n    \"\"\"Return a new profile with new plugin configs.\"\"\"\n    return self.model_copy(update={\"plugin_configs\": configs})\n</code></pre>"},{"location":"api/profile/#himena.profile.AppProfile.with_plugins","title":"<code>with_plugins(plugins)</code>","text":"<p>Return a new profile with new plugins.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def with_plugins(self, plugins: list[str]) -&gt; \"AppProfile\":\n    \"\"\"Return a new profile with new plugins.\"\"\"\n    return self.model_copy(update={\"plugins\": plugins})\n</code></pre>"},{"location":"api/profile/#himena.profile.KeyBindingOverride","title":"<code>KeyBindingOverride</code>","text":"<p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> required <code>command_id</code> <code>str</code> required Source code in <code>src\\himena\\profile.py</code> <pre><code>class KeyBindingOverride(BaseModel):\n    key: str\n    command_id: str\n</code></pre>"},{"location":"api/profile/#himena.profile._default_plugins","title":"<code>_default_plugins()</code>","text":"<p>Factory function for the default plugin list.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def _default_plugins() -&gt; list[str]:\n    \"\"\"Factory function for the default plugin list.\"\"\"\n    return [\n        \"himena_builtins.qt.console\",\n        \"himena_builtins.qt.explorer\",\n        \"himena_builtins.qt.history\",\n        \"himena_builtins.qt.output\",\n        \"himena_builtins.qt.plot\",\n        \"himena_builtins.qt.widgets\",\n        \"himena_builtins.tools\",\n        \"himena_builtins.io\",\n        \"himena_builtins.new\",\n    ]\n</code></pre>"},{"location":"api/profile/#himena.profile.data_dir","title":"<code>data_dir()</code>","text":"<p>Get the user data directory.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def data_dir() -&gt; Path:\n    \"\"\"Get the user data directory.\"\"\"\n    if not USER_DATA_DIR.exists():\n        USER_DATA_DIR.mkdir(parents=True)\n    return USER_DATA_DIR\n</code></pre>"},{"location":"api/profile/#himena.profile.new_app_profile","title":"<code>new_app_profile(name)</code>","text":"<p>Create a new profile.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def new_app_profile(name: str) -&gt; None:\n    \"\"\"Create a new profile.\"\"\"\n    path = profile_dir() / f\"{name}.json\"\n    if path.exists():\n        raise ValueError(f\"Profile {name!r} already exists.\")\n    profile = AppProfile.default().with_name(name)\n    return profile.save(path)\n</code></pre>"},{"location":"api/profile/#himena.profile.patch_user_data_dir","title":"<code>patch_user_data_dir(path)</code>","text":"<p>Change the user data directory to avoid pytest updates the local state.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>@contextmanager\ndef patch_user_data_dir(path: str | Path):\n    \"\"\"Change the user data directory to avoid pytest updates the local state.\"\"\"\n    global USER_DATA_DIR\n    old = USER_DATA_DIR\n    USER_DATA_DIR = Path(path)\n    try:\n        yield\n    finally:\n        USER_DATA_DIR = old\n</code></pre>"},{"location":"api/profile/#himena.profile.remove_app_profile","title":"<code>remove_app_profile(name)</code>","text":"<p>Remove an existing profile.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def remove_app_profile(name: str) -&gt; None:\n    \"\"\"Remove an existing profile.\"\"\"\n    path = profile_dir() / f\"{name}.json\"\n    return path.unlink()\n</code></pre>"},{"location":"api/types/","title":"himena.types","text":""},{"location":"api/types/#himena.types.Parametric","title":"<code>Parametric = NewType('Parametric', Any)</code>  <code>module-attribute</code>","text":"<p>Callback for a parametric function.</p> <p>This type can be interpreted by the injection store processor. For example, in the following code, <code>my_plugin_function</code> will be converted into a parametric widget with inputs <code>a</code> and <code>b</code>..</p> <pre><code>from himena.plugin import register_function\n@register_function(...)\ndef my_plugin_function(...) -&gt; Parametric:\n    def callback_func(a: int, b: str) -&gt; WidgetDataModel:\n        ...\n    return my_plugin_function\n</code></pre>"},{"location":"api/types/#himena.types.WidgetConstructor","title":"<code>WidgetConstructor = NewType('WidgetConstructor', object)</code>  <code>module-attribute</code>","text":"<p>This type is used for the return annotation.</p> <pre><code>from himena.plugin import register_function\n@register_function(...)\ndef my_plugin_function() -&gt; WidgetConstructor:\n    return MyWidget\n</code></pre>"},{"location":"api/types/#himena.types.WidgetType","title":"<code>WidgetType = NewType('WidgetType', object)</code>  <code>module-attribute</code>","text":"<p>This type is used for the return annotation.</p> <pre><code>from himena.plugin import register_function\n@register_function(...)\ndef my_plugin_function() -&gt; WidgetType:\n    return MyWidget()\n</code></pre>"},{"location":"api/types/#himena.types.BackendInstructions","title":"<code>BackendInstructions</code>","text":"<p>Instructions for the backend that are only relevant to user interface.</p> <p>Parameters:</p> Name Type Description Default <code>animate</code> <code>bool</code> <p>Whether to animate</p> <code>True</code> <code>confirm</code> <code>bool</code> <p>Whether to show a confirmation dialog</p> <code>True</code> <code>choose_one_dialog_response</code> <code>Callable[list, Any] | None</code> <p>If provided, choose-one dialog will be skipped and this function will be called to get the response.</p> <code>None</code> <code>file_dialog_response</code> <code>Callable[list, Any] | None</code> <p>If provided, file dialog will be skipped and this function will be called to get the response.</p> <code>None</code> <code>gui_execution</code> <code>bool</code> <code>True</code> <code>process_model_output</code> <code>bool</code> <code>True</code> <code>unwrap_future</code> <code>bool</code> <code>False</code> Source code in <code>src\\himena\\types.py</code> <pre><code>class BackendInstructions(BaseModel):\n    \"\"\"Instructions for the backend that are only relevant to user interface.\"\"\"\n\n    model_config = PYDANTIC_CONFIG_STRICT\n\n    animate: bool = Field(\n        default=True,\n        description=\"Whether to animate\",\n        frozen=True,\n    )\n    confirm: bool = Field(\n        default=True,\n        description=\"Whether to show a confirmation dialog\",\n        frozen=True,\n    )\n    choose_one_dialog_response: Callable[[], Any] | None = Field(\n        default=None,\n        description=\"If provided, choose-one dialog will be skipped and this function \"\n        \"will be called to get the response.\",\n        frozen=True,\n    )\n    file_dialog_response: Callable[[], Any] | None = Field(\n        default=None,\n        description=\"If provided, file dialog will be skipped and this function will \"\n        \"be called to get the response.\",\n        frozen=True,\n    )\n    gui_execution: bool = Field(default=True)\n    process_model_output: bool = Field(default=True)\n    unwrap_future: bool = Field(default=False)\n\n    def updated(self, **kwargs) -&gt; \"BackendInstructions\":\n        return self.model_copy(update=kwargs)\n</code></pre>"},{"location":"api/types/#himena.types.ClipboardDataModel","title":"<code>ClipboardDataModel</code>","text":"<p>Data model for a clipboard data.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>Text in the clipboard if exists.</p> <code>None</code> <code>html</code> <code>str | None</code> <p>HTML in the clipboard if exists.</p> <code>None</code> <code>image</code> <code>Any | None</code> <p>Image in the clipboard if exists.</p> <code>None</code> <code>files</code> <code>list[Path]</code> <p>List of file paths in the clipboard if exists.</p> <code>&lt;dynamic&gt;</code> <code>internal_data</code> <code>Any | None</code> <p>Application specific data in the clipboard if exists. This data cannot be used across application, but is useful to send Python object to other widgets.</p> <code>None</code> Source code in <code>src\\himena\\types.py</code> <pre><code>class ClipboardDataModel(BaseModel):\n    \"\"\"Data model for a clipboard data.\"\"\"\n\n    model_config = PYDANTIC_CONFIG_STRICT\n\n    text: str | None = Field(\n        default=None,\n        description=\"Text in the clipboard if exists.\",\n    )\n    html: str | None = Field(\n        default=None,\n        description=\"HTML in the clipboard if exists.\",\n    )\n    image: Any | None = Field(\n        default=None,\n        description=\"Image in the clipboard if exists.\",\n    )\n    files: list[Path] = Field(\n        default_factory=list,\n        description=\"List of file paths in the clipboard if exists.\",\n    )\n    internal_data: Any | None = Field(\n        default=None,\n        description=\"Application specific data in the clipboard if exists. This data \"\n        \"cannot be used across application, but is useful to send Python object to \"\n        \"other widgets.\",\n    )\n\n    def with_internal_data(self, internal_data) -&gt; \"ClipboardDataModel\":\n        return self.model_copy(update={\"internal_data\": internal_data})\n</code></pre>"},{"location":"api/types/#himena.types.DockArea","title":"<code>DockArea</code>","text":"<p>Area of the dock widget.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>class DockArea(StrEnum):\n    \"\"\"Area of the dock widget.\"\"\"\n\n    TOP = \"top\"\n    BOTTOM = \"bottom\"\n    LEFT = \"left\"\n    RIGHT = \"right\"\n</code></pre>"},{"location":"api/types/#himena.types.DragDataModel","title":"<code>DragDataModel</code>","text":"<p>Parameters:</p> Name Type Description Default <code>getter</code> <code>Callable[list, WidgetDataModel] | WidgetDataModel</code> <p>Getter function to get the data model.</p> required <code>type</code> <code>str | None</code> <p>Type of the internal data.</p> <code>None</code> Source code in <code>src\\himena\\types.py</code> <pre><code>class DragDataModel(BaseModel):\n    model_config = PYDANTIC_CONFIG_STRICT\n    getter: Callable[[], WidgetDataModel] | WidgetDataModel = Field(\n        ..., description=\"Getter function to get the data model.\"\n    )\n    type: str | None = Field(None, description=\"Type of the internal data.\")\n\n    def inferred_type(self) -&gt; str:\n        if self.type is not None:\n            return self.type\n        if callable(self.getter):\n            model = self.getter()\n        else:\n            model = self.getter\n        return model.type\n\n    def data_model(self) -&gt; WidgetDataModel:\n        if isinstance(self.getter, WidgetDataModel):\n            model = self.getter\n        else:\n            model = self.getter()\n        return model\n\n    def widget_accepts_me(self, widget: Any) -&gt; bool:\n        \"\"\"Return true if the widget accepts this data model to be dropped.\"\"\"\n        if hasattr(widget, \"allowed_drop_types\"):\n            types = widget.allowed_drop_types()\n            if self.type is None:\n                return True  # not specified. Just allow it.\n            if self.type in types:\n                return True\n        elif hasattr(widget, \"dropped_callback\"):\n            return True\n        return False\n</code></pre>"},{"location":"api/types/#himena.types.DragDataModel.widget_accepts_me","title":"<code>widget_accepts_me(widget)</code>","text":"<p>Return true if the widget accepts this data model to be dropped.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def widget_accepts_me(self, widget: Any) -&gt; bool:\n    \"\"\"Return true if the widget accepts this data model to be dropped.\"\"\"\n    if hasattr(widget, \"allowed_drop_types\"):\n        types = widget.allowed_drop_types()\n        if self.type is None:\n            return True  # not specified. Just allow it.\n        if self.type in types:\n            return True\n    elif hasattr(widget, \"dropped_callback\"):\n        return True\n    return False\n</code></pre>"},{"location":"api/types/#himena.types.DropResult","title":"<code>DropResult</code>","text":"<p>Model that can be returned by <code>dropped_callback</code> protocol.</p> <p>Parameters:</p> Name Type Description Default <code>delete_input</code> <code>bool</code> <code>False</code> <code>outputs</code> <code>WidgetDataModel | list[WidgetDataModel] | None</code> <code>None</code> <p>Attributes:</p> Name Type Description <code>delete_input</code> <code>bool</code> <p>Whether to delete the input data if drop succeeded.</p> <code>outputs</code> <code>WidgetDataModel | list[WidgetDataModel] | None</code> <p>If given, the output data will be added to the GUI.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>class DropResult(BaseModel):\n    \"\"\"Model that can be returned by `dropped_callback` protocol.\n\n    Attributes\n    ----------\n    delete_input : bool\n        Whether to delete the input data if drop succeeded.\n    outputs : WidgetDataModel | list[WidgetDataModel] | None\n        If given, the output data will be added to the GUI.\n    \"\"\"\n\n    delete_input: bool = False\n    outputs: WidgetDataModel | list[WidgetDataModel] | None = Field(None)\n</code></pre>"},{"location":"api/types/#himena.types.FutureInfo","title":"<code>FutureInfo</code>  <code>dataclass</code>","text":"<p>FutureInfo(type_hint: Any, track: himena.types.ModelTrack | None = None, kwargs: dict[str, typing.Any] = , top_left: tuple[int, int] | None = None, size: Optional[himena.types.Size[int]] = None) <p>Parameters:</p> Name Type Description Default <code>type_hint</code> <code>Any</code> required <code>track</code> <code>ModelTrack | None</code> <code>None</code> <code>top_left</code> <code>tuple[int, int] | None</code> <code>None</code> <code>size</code> <code>Size[int] | None</code> <code>None</code> Source code in <code>src\\himena\\types.py</code> <pre><code>@dataclass(frozen=True)\nclass FutureInfo(_HasDynamicAttribute):\n    _ATTR_NAME: ClassVar[str] = \"__himena_future_info__\"\n\n    type_hint: Any\n    track: ModelTrack | None = None\n    kwargs: dict[str, Any] = field(default_factory=dict)\n    top_left: tuple[int, int] | None = None\n    size: Size[int] | None = None\n\n    def resolve_type_hint(self, ns: dict[str, Any]) -&gt; \"FutureInfo\":\n        if isinstance(self.type_hint, str):\n            typ = ns.get(self.type_hint)\n            if typ is None:\n                raise ValueError(f\"Could not resolve the type hint: {self.type_hint}\")\n            type_hint = typ\n        else:\n            type_hint = self.type_hint\n        return FutureInfo(\n            type_hint=type_hint,\n            track=self.track,\n            kwargs=self.kwargs,\n            top_left=self.top_left,\n            size=self.size,\n        )\n</code></pre>"},{"location":"api/types/#himena.types.GenericModel","title":"<code>GenericModel</code>","text":"Source code in <code>src\\himena\\types.py</code> <pre><code>class GenericModel(BaseModel):\n    def __class_getitem__(cls, item):\n        return cls\n</code></pre>"},{"location":"api/types/#himena.types.GuiConfiguration","title":"<code>GuiConfiguration</code>  <code>dataclass</code>","text":"<p>Configuration for parametric widget (interpreted by the injection processor)</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str | None</code> <code>None</code> <code>preview</code> <code>bool</code> <code>False</code> <code>auto_close</code> <code>bool</code> <code>True</code> <code>show_parameter_labels</code> <code>bool</code> <code>True</code> <code>run_async</code> <code>bool</code> <code>False</code> <code>result_as</code> <code>Literal[str, str, str]</code> <code>'window'</code> Source code in <code>src\\himena\\types.py</code> <pre><code>@dataclass\nclass GuiConfiguration(_HasDynamicAttribute):\n    \"\"\"Configuration for parametric widget (interpreted by the injection processor)\"\"\"\n\n    _ATTR_NAME: ClassVar[str] = \"__himena_gui_config__\"\n\n    title: str | None = None\n    preview: bool = False\n    auto_close: bool = True\n    show_parameter_labels: bool = True\n    run_async: bool = False\n    result_as: Literal[\"window\", \"below\", \"right\"] = \"window\"\n\n    def asdict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the configuration as a dictionary.\"\"\"\n        return asdict(self)\n</code></pre>"},{"location":"api/types/#himena.types.GuiConfiguration.asdict","title":"<code>asdict()</code>","text":"<p>Return the configuration as a dictionary.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def asdict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the configuration as a dictionary.\"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"api/types/#himena.types.Margins","title":"<code>Margins</code>  <code>dataclass</code>","text":"<p>Margins(left: ~_V, top: ~_V, right: ~_V, bottom: ~_V)</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>TypeVar</code> required <code>top</code> <code>TypeVar</code> required <code>right</code> <code>TypeVar</code> required <code>bottom</code> <code>TypeVar</code> required Source code in <code>src\\himena\\types.py</code> <pre><code>@dataclass(frozen=True)\nclass Margins(Generic[_V]):\n    left: _V\n    top: _V\n    right: _V\n    bottom: _V\n\n    def __iter__(self):\n        \"\"\"Iterate over the field to make this class tuple-like.\"\"\"\n        return iter((self.left, self.top, self.right, self.bottom))\n\n    @classmethod\n    def from_rects(cls, inner: Rect[_V], outer: Rect[_V]) -&gt; \"Margins[_V]\":\n        \"\"\"Calculate the margins from the inner and outer rectangles.\"\"\"\n        return cls(\n            inner.left - outer.left,\n            inner.top - outer.top,\n            outer.right - inner.right,\n            outer.bottom - inner.bottom,\n        )\n</code></pre>"},{"location":"api/types/#himena.types.Margins.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the field to make this class tuple-like.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over the field to make this class tuple-like.\"\"\"\n    return iter((self.left, self.top, self.right, self.bottom))\n</code></pre>"},{"location":"api/types/#himena.types.Margins.from_rects","title":"<code>from_rects(inner, outer)</code>  <code>classmethod</code>","text":"<p>Calculate the margins from the inner and outer rectangles.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>@classmethod\ndef from_rects(cls, inner: Rect[_V], outer: Rect[_V]) -&gt; \"Margins[_V]\":\n    \"\"\"Calculate the margins from the inner and outer rectangles.\"\"\"\n    return cls(\n        inner.left - outer.left,\n        inner.top - outer.top,\n        outer.right - inner.right,\n        outer.bottom - inner.bottom,\n    )\n</code></pre>"},{"location":"api/types/#himena.types.ModelTrack","title":"<code>ModelTrack</code>  <code>dataclass</code>","text":"<p>Model to track how model is created.</p> <p>Parameters:</p> Name Type Description Default <code>command_id</code> <code>str</code> required <code>contexts</code> <code>list</code> <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p> <code>&lt;dynamic&gt;</code> <code>workflow</code> <code>Workflow</code> <p>Container of WorkflowStep instances.</p> <p>The data structure of a workflow is a directed acyclic graph. Each node is a WorkflowStep instance, and the edges are defined inside each CommandExecution instance. Each node is tagged with a unique ID named <code>id</code>, which is used as a mathematical identifier for the node.</p> <code>&lt;dynamic&gt;</code> <code>time_start</code> <code>float</code> <code>0.0</code> Source code in <code>src\\himena\\types.py</code> <pre><code>@dataclass(frozen=True)\nclass ModelTrack(_HasDynamicAttribute):\n    \"\"\"Model to track how model is created.\"\"\"\n\n    _ATTR_NAME: ClassVar[str] = \"__himena_model_track__\"\n\n    command_id: str\n    contexts: list = field(default_factory=list)\n    workflow: Workflow = field(default_factory=Workflow)\n    time_start: float = field(default=0.0)\n\n    def to_workflow(self, parameters: dict[str, Any]) -&gt; Workflow:\n        \"\"\"Construct a workflow based on the given parameters.\"\"\"\n        params = []\n        more_workflows: list[Workflow] = []\n        for k, v in parameters.items():\n            if k == \"is_previewing\":\n                continue\n            param, wf = parse_parameter(k, v)\n            params.append(param)\n            more_workflows.append(wf)\n        workflow = Workflow.concat([self.workflow] + more_workflows)\n        return workflow.with_step(\n            CommandExecution(\n                command_id=self.command_id,\n                contexts=self.contexts,\n                parameters=params,\n                execution_time=timeit.default_timer() - self.time_start,\n            )\n        )\n</code></pre>"},{"location":"api/types/#himena.types.ModelTrack.to_workflow","title":"<code>to_workflow(parameters)</code>","text":"<p>Construct a workflow based on the given parameters.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def to_workflow(self, parameters: dict[str, Any]) -&gt; Workflow:\n    \"\"\"Construct a workflow based on the given parameters.\"\"\"\n    params = []\n    more_workflows: list[Workflow] = []\n    for k, v in parameters.items():\n        if k == \"is_previewing\":\n            continue\n        param, wf = parse_parameter(k, v)\n        params.append(param)\n        more_workflows.append(wf)\n    workflow = Workflow.concat([self.workflow] + more_workflows)\n    return workflow.with_step(\n        CommandExecution(\n            command_id=self.command_id,\n            contexts=self.contexts,\n            parameters=params,\n            execution_time=timeit.default_timer() - self.time_start,\n        )\n    )\n</code></pre>"},{"location":"api/types/#himena.types.NewWidgetBehavior","title":"<code>NewWidgetBehavior</code>","text":"<p>Behavior of adding a widget.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>class NewWidgetBehavior(StrEnum):\n    \"\"\"Behavior of adding a widget.\"\"\"\n\n    TAB = \"tab\"\n    WINDOW = \"window\"\n</code></pre>"},{"location":"api/types/#himena.types.ParametricWidgetProtocol","title":"<code>ParametricWidgetProtocol</code>","text":"<p>Protocol used for return annotation of a parametric widget.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>class ParametricWidgetProtocol:\n    \"\"\"Protocol used for return annotation of a parametric widget.\"\"\"\n\n    def __new__(cls, *args, **kwargs) -&gt; None:\n        if cls is ParametricWidgetProtocol:\n            raise TypeError(\"ParametricWidgetProtocol cannot be instantiated.\")\n        return super().__new__(cls)\n\n    def get_output(self, *args, **kwargs) -&gt; Any:\n        raise NotImplementedError\n</code></pre>"},{"location":"api/types/#himena.types.Rect","title":"<code>Rect</code>  <code>dataclass</code>","text":"<p>Rectangle use for any place.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>TypeVar</code> required <code>top</code> <code>TypeVar</code> required <code>width</code> <code>TypeVar</code> required <code>height</code> <code>TypeVar</code> required Source code in <code>src\\himena\\types.py</code> <pre><code>@dataclass(frozen=True)\nclass Rect(Generic[_V]):\n    \"\"\"Rectangle use for any place.\"\"\"\n\n    left: _V\n    top: _V\n    width: _V\n    height: _V\n\n    @property\n    def right(self):\n        return self.left + self.width\n\n    @property\n    def bottom(self):\n        return self.top + self.height\n\n    def with_left(self, left: _V) -&gt; \"Rect[_V]\":\n        return Rect(left, self.top, self.width, self.height)\n\n    def with_top(self, top: _V) -&gt; \"Rect[_V]\":\n        return Rect(self.left, top, self.width, self.height)\n\n    def with_width(self, width: _V) -&gt; \"Rect[_V]\":\n        return Rect(self.left, self.top, width, self.height)\n\n    def with_height(self, height: _V) -&gt; \"Rect[_V]\":\n        return Rect(self.left, self.top, self.width, height)\n\n    def with_right(self, right: _V) -&gt; \"Rect[_V]\":\n        return Rect(right - self.width, self.top, self.width, self.height)\n\n    def with_bottom(self, bottom: _V) -&gt; \"Rect[_V]\":\n        return Rect(self.left, bottom - self.height, self.width, self.height)\n\n    def __iter__(self):\n        \"\"\"Iterate over the field to make this class tuple-like.\"\"\"\n        return iter((self.left, self.top, self.width, self.height))\n\n    def size(self) -&gt; Size[_V]:\n        return Size(self.width, self.height)\n\n    def adjust_to_int(\n        self,\n        how: Literal[\"inner\", \"outer\"] = \"inner\",\n    ) -&gt; \"Rect[int]\":\n        right = self.right\n        bottom = self.bottom\n        if how == \"inner\":\n            left = int(math.ceil(self.left))\n            top = int(math.ceil(self.top))\n            right = int(math.floor(right))\n            bottom = int(math.floor(bottom))\n        else:\n            left = int(math.floor(self.left))\n            top = int(math.floor(self.top))\n            right = int(math.ceil(right))\n            bottom = int(math.ceil(bottom))\n        return Rect(left, top, right - left, bottom - top)\n\n    def limit_to(self, xmax: _T, ymax: _T) -&gt; \"Rect[_T]\":\n        \"\"\"Limit the size of the Rect to the given maximum size.\"\"\"\n        left = max(self.left, 0)\n        top = max(self.top, 0)\n        right = min(self.right, xmax)\n        bottom = min(self.bottom, ymax)\n        return Rect(left, top, right - left, bottom - top)\n\n    def move_top_left(self, left: _V, top: _V) -&gt; \"Rect[_V]\":\n        return Rect(left, top, self.width, self.height)\n\n    def move_top_right(self, right: _V, top: _V) -&gt; \"Rect[_V]\":\n        return Rect(right - self.width, top, self.width, self.height)\n\n    def move_bottom_left(self, left: _V, bottom: _V) -&gt; \"Rect[_V]\":\n        return Rect(left, bottom - self.height, self.width, self.height)\n\n    def move_bottom_right(self, right: _V, bottom: _V) -&gt; \"Rect[_V]\":\n        return Rect(right - self.width, bottom - self.height, self.width, self.height)\n</code></pre>"},{"location":"api/types/#himena.types.Rect.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the field to make this class tuple-like.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over the field to make this class tuple-like.\"\"\"\n    return iter((self.left, self.top, self.width, self.height))\n</code></pre>"},{"location":"api/types/#himena.types.Rect.limit_to","title":"<code>limit_to(xmax, ymax)</code>","text":"<p>Limit the size of the Rect to the given maximum size.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def limit_to(self, xmax: _T, ymax: _T) -&gt; \"Rect[_T]\":\n    \"\"\"Limit the size of the Rect to the given maximum size.\"\"\"\n    left = max(self.left, 0)\n    top = max(self.top, 0)\n    right = min(self.right, xmax)\n    bottom = min(self.bottom, ymax)\n    return Rect(left, top, right - left, bottom - top)\n</code></pre>"},{"location":"api/types/#himena.types.Size","title":"<code>Size</code>  <code>dataclass</code>","text":"<p>Size use for any place.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>TypeVar</code> required <code>height</code> <code>TypeVar</code> required Source code in <code>src\\himena\\types.py</code> <pre><code>@dataclass(frozen=True)\nclass Size(Generic[_V]):\n    \"\"\"Size use for any place.\"\"\"\n\n    width: _V\n    height: _V\n\n    def __iter__(self):\n        \"\"\"Iterate over the field to make this class tuple-like.\"\"\"\n        return iter((self.width, self.height))\n\n    def __getitem__(self, index: int):\n        if index == 0:\n            return self.width\n        elif index == 1:\n            return self.height\n        raise IndexError(f\"Index {index!r} out of range.\")\n\n    def with_width(self, width: _V) -&gt; \"Size[_V]\":\n        return Size(width, self.height)\n\n    def with_height(self, height: _V) -&gt; \"Size[_V]\":\n        return Size(self.width, height)\n</code></pre>"},{"location":"api/types/#himena.types.Size.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the field to make this class tuple-like.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over the field to make this class tuple-like.\"\"\"\n    return iter((self.width, self.height))\n</code></pre>"},{"location":"api/types/#himena.types.WidgetClassTuple","title":"<code>WidgetClassTuple</code>","text":"<p>Class for storing registered widget class.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <code>None</code> <code>widget_class</code> <code>ForwardRef(type | Callable)</code> <code>None</code> <code>priority</code> <code>int</code> <code>100</code> <code>widget_id</code> <code>str | None</code> <code>None</code> Source code in <code>src\\himena\\types.py</code> <pre><code>class WidgetClassTuple(NamedTuple):\n    \"\"\"Class for storing registered widget class.\"\"\"\n\n    type: str\n    widget_class: \"type | Callable\"  # factory function\n    priority: int = 100\n    widget_id: str | None = None\n</code></pre>"},{"location":"api/types/#himena.types.WidgetDataModel","title":"<code>WidgetDataModel</code>","text":"<p>A data model that represents a widget containing an internal data.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>TypeVar</code> <p>Internal value.</p> required <code>type</code> <code>str</code> <p>Type of the internal data.</p> required <code>title</code> <code>str | None</code> <p>Default title for the widget.</p> <code>None</code> <code>extension_default</code> <code>str | None</code> <p>Default file extension for saving.</p> <code>None</code> <code>extensions</code> <code>list[str]</code> <p>List of allowed file extensions.</p> <code>&lt;dynamic&gt;</code> <code>metadata</code> <code>object | None</code> <p>Metadata that may be used for storing additional information of the internal data or describing the state of the widget.</p> <code>None</code> <code>workflow</code> <code>Workflow</code> <p>Container of WorkflowStep instances.</p> <p>The data structure of a workflow is a directed acyclic graph. Each node is a WorkflowStep instance, and the edges are defined inside each CommandExecution instance. Each node is tagged with a unique ID named <code>id</code>, which is used as a mathematical identifier for the node.</p> <code>&lt;dynamic&gt;</code> <code>force_open_with</code> <code>str | None</code> <p>Force open with a specific plugin if given.</p> <code>None</code> <code>save_behavior_override</code> <code>SaveBehavior | None</code> <p>Override the default save behavior.</p> <code>None</code> <code>editable</code> <code>bool</code> <p>Whether the widget is editable.</p> <code>True</code> <code>window_rect_override</code> <code>Callable[list, WindowRect] | None</code> <code>None</code> <p>Attributes:</p> Name Type Description <code>value</code> <code>Any</code> <p>Internal value.</p> <code>type</code> <code>(str, optional)</code> <p>Type of the internal data. Type hierarchy is separated by dots. For example, \"text.plain\" is a subtype of \"text\".</p> <code>title</code> <code>(str, optional)</code> <p>Title for the widget. If not given, the title will be generated from the source path when this model is added to the GUI.</p> <code>extension_default</code> <code>(str, optional)</code> <p>Default file extension for saving. This is used when the user saves the data without specifying the file extension.</p> <code>extensions</code> <code>(list[str], optional)</code> <p>List of allowed file extensions to save this data.</p> <code>metadata</code> <code>(Any, optional)</code> <p>Metadata that may be used for storing additional information of the internal data or describing the state of the widget.</p> <code>workflow</code> <code>(WorkflowList, optional)</code> <p>History of how this data is created.</p> <code>force_open_with</code> <code>(str, optional)</code> <p>Force open with a specific plugin if given.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>class WidgetDataModel(GenericModel[_T]):\n    \"\"\"\n    A data model that represents a widget containing an internal data.\n\n    Attributes\n    ----------\n    value : Any\n        Internal value.\n    type : str, optional\n        Type of the internal data. Type hierarchy is separated by dots. For example,\n        \"text.plain\" is a subtype of \"text\".\n    title : str, optional\n        Title for the widget. If not given, the title will be generated from the source\n        path when this model is added to the GUI.\n    extension_default : str, optional\n        Default file extension for saving. This is used when the user saves the data\n        without specifying the file extension.\n    extensions : list[str], optional\n        List of allowed file extensions to save this data.\n    metadata : Any, optional\n        Metadata that may be used for storing additional information of the internal\n        data or describing the state of the widget.\n    workflow : WorkflowList, optional\n        History of how this data is created.\n    force_open_with : str, optional\n        Force open with a specific plugin if given.\n    \"\"\"\n\n    model_config = PYDANTIC_CONFIG_STRICT\n\n    value: _T = Field(..., description=\"Internal value.\")\n    type: str = Field(..., description=\"Type of the internal data.\")\n    title: str | None = Field(\n        default=None,\n        description=\"Default title for the widget.\",\n    )\n    extension_default: str | None = Field(\n        default=None,\n        description=\"Default file extension for saving.\",\n    )\n    extensions: list[str] = Field(\n        default_factory=list,\n        description=\"List of allowed file extensions.\",\n    )\n    metadata: object | None = Field(\n        default=None,\n        description=\"Metadata that may be used for storing additional information of \"\n        \"the internal data or describing the state of the widget.\",\n    )  # fmt: skip\n    workflow: Workflow = Field(default_factory=Workflow)\n    force_open_with: str | None = Field(\n        default=None,\n        description=\"Force open with a specific plugin if given.\",\n    )\n    save_behavior_override: SaveBehavior | None = Field(\n        default=None,\n        description=\"Override the default save behavior.\",\n    )\n    editable: bool = Field(True, description=\"Whether the widget is editable.\")\n    window_rect_override: Callable[[\"Size\"], \"WindowRect\"] | None = Field(None)\n\n    def with_value(\n        self,\n        value: _U,\n        type: str | None = None,\n        *,\n        title: str | None = None,\n        metadata: object | None = _void,\n        save_behavior_override: SaveBehavior | _Void | None = _void,\n    ) -&gt; \"WidgetDataModel[_U]\":\n        \"\"\"Return a model with the new value.\"\"\"\n        update = {\"value\": value}\n        if type is not None:\n            update[\"type\"] = type\n        if metadata is not _void:\n            update[\"metadata\"] = metadata\n        if title is not None:\n            update[\"title\"] = title\n        if save_behavior_override is not _void:\n            update[\"save_behavior_override\"] = save_behavior_override\n        update.update(\n            workflow=Workflow(),\n            force_open_with=None,\n        )  # these parameters must be reset\n        return self.model_copy(update=update)\n\n    def astype(self, new_type: str):\n        update = {\"type\": new_type}\n        return self.model_copy(update=update)\n\n    def _with_source(\n        self,\n        source: str | Path | list[str | Path],\n        plugin: \"PluginInfo | None\" = None,\n    ) -&gt; \"WidgetDataModel[_T]\":\n        \"\"\"Return a new instance with the source path.\"\"\"\n        if plugin is None:\n            plugin_name = None\n        else:\n            plugin_name = plugin.to_str()\n        if isinstance(source, list):\n            path = [Path(s).resolve() for s in source]\n        else:\n            path = Path(source).resolve()\n        wf = LocalReaderMethod(\n            path=path, plugin=plugin_name, output_model_type=self.type\n        ).construct_workflow()\n        to_update = {\"workflow\": wf}\n        if self.title is None:\n            if isinstance(path, list):\n                to_update.update({\"title\": \"File group\"})\n            else:\n                to_update.update({\"title\": path.name})\n        return self.model_copy(update=to_update)\n\n    def with_open_plugin(\n        self,\n        open_with: str,\n        *,\n        workflow: Workflow | _Void | None = _void,\n        save_behavior_override: SaveBehavior | _Void | None = _void,\n    ) -&gt; \"WidgetDataModel[_T]\":\n        update = {\"force_open_with\": open_with}\n        if workflow is not _void:\n            update[\"workflow\"] = workflow\n        if save_behavior_override is not _void:\n            update[\"save_behavior_override\"] = save_behavior_override\n        return self.model_copy(update=update)\n\n    def with_metadata(\n        self,\n        metadata: Any,\n    ) -&gt; \"WidgetDataModel[_T]\":\n        \"\"\"Return a new instance with the given metadata.\"\"\"\n        update = {\"metadata\": metadata}\n        return self.model_copy(update=update)\n\n    def write_to_directory(\n        self,\n        directory: str | Path,\n        *,\n        plugin: str | None = None,\n    ) -&gt; Path:\n        from himena import _providers\n\n        ins = _providers.WriterStore.instance()\n        title = self.title or \"Untitled\"\n        path = Path(directory) / title\n        if path.suffix == \"\":\n            if ext := self.extension_default:\n                path = path.with_suffix(ext)\n            elif exts := self.extensions:\n                path = path.with_suffix(exts[0])\n            else:\n                raise ValueError(\"Could not determine the file extension.\")\n        ins.run(self, path, min_priority=0, plugin=plugin)\n        return path\n\n    @property\n    def source(self) -&gt; Path | list[Path] | None:\n        \"\"\"The direct source path of the data.\"\"\"\n        if isinstance(step := self.workflow.last(), LocalReaderMethod):\n            return step.path\n        return None\n\n    def is_subtype_of(self, supertype: str) -&gt; bool:\n        \"\"\"Check if the type is a subtype of the given type.\"\"\"\n        return is_subtype(self.type, supertype)\n\n    def with_title_numbering(self, copy: bool = False) -&gt; \"WidgetDataModel[_T]\":\n        \"\"\"Add [n] suffix to the title.\"\"\"\n        title = self.title\n        if title is None:\n            title = \"Untitled\"\n        if \".\" in title:\n            stem, ext = title.rsplit(\".\", 1)\n            ext = f\".{ext}\"\n        else:\n            stem = title\n            ext = \"\"\n        if (\n            (last_part := stem.rsplit(\" \", 1)[-1]).startswith(\"[\")\n            and last_part.endswith(\"]\")\n            and last_part[1:-1].isdigit()\n        ):\n            nth = int(last_part[1:-1])\n            stem = stem.rsplit(\" \", 1)[0] + f\" [{nth + 1}]\"\n        else:\n            stem = stem + \" [1]\"\n        new_title = stem + ext\n        if copy:\n            return self.model_copy(update={\"title\": new_title})\n        else:\n            self.title = new_title\n            return self\n\n    @field_validator(\"extension_default\", mode=\"after\")\n    def _validate_extension_default(cls, v: str, values):\n        if v is None:\n            return None\n        if not v.startswith(\".\"):\n            return f\".{v}\"\n        return v\n\n    @field_validator(\"extensions\", mode=\"before\")\n    def _validate_extensions(cls, v):\n        if isinstance(v, str):\n            v = [v]\n        if not all(isinstance(ext, str) for ext in v):\n            raise TypeError(f\"Invalid type for `extensions`: {type(v)}\")\n        return [s if s.startswith(\".\") else f\".{s}\" for s in v]\n\n    def __repr__(self):\n        value_repr = f\"&lt;{type(self.value).__name__}&gt;\"\n        if isinstance(source := self.source, Path):\n            source_repr = source.as_posix()\n        elif isinstance(source, list):\n            if len(source) &gt; 0:\n                source_repr = f\"[{source[0].as_posix()}, ...]\"\n            else:\n                source_repr = \"[]\"\n        else:\n            source_repr = None\n        return (\n            f\"{self.__class__.__name__}(value={value_repr}, source={source_repr}, \"\n            f\"type={self.type!r}, title={self.title!r})\"\n        )\n</code></pre>"},{"location":"api/types/#himena.types.WidgetDataModel.source","title":"<code>source</code>  <code>property</code>","text":"<p>The direct source path of the data.</p>"},{"location":"api/types/#himena.types.WidgetDataModel._with_source","title":"<code>_with_source(source, plugin=None)</code>","text":"<p>Return a new instance with the source path.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def _with_source(\n    self,\n    source: str | Path | list[str | Path],\n    plugin: \"PluginInfo | None\" = None,\n) -&gt; \"WidgetDataModel[_T]\":\n    \"\"\"Return a new instance with the source path.\"\"\"\n    if plugin is None:\n        plugin_name = None\n    else:\n        plugin_name = plugin.to_str()\n    if isinstance(source, list):\n        path = [Path(s).resolve() for s in source]\n    else:\n        path = Path(source).resolve()\n    wf = LocalReaderMethod(\n        path=path, plugin=plugin_name, output_model_type=self.type\n    ).construct_workflow()\n    to_update = {\"workflow\": wf}\n    if self.title is None:\n        if isinstance(path, list):\n            to_update.update({\"title\": \"File group\"})\n        else:\n            to_update.update({\"title\": path.name})\n    return self.model_copy(update=to_update)\n</code></pre>"},{"location":"api/types/#himena.types.WidgetDataModel.is_subtype_of","title":"<code>is_subtype_of(supertype)</code>","text":"<p>Check if the type is a subtype of the given type.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def is_subtype_of(self, supertype: str) -&gt; bool:\n    \"\"\"Check if the type is a subtype of the given type.\"\"\"\n    return is_subtype(self.type, supertype)\n</code></pre>"},{"location":"api/types/#himena.types.WidgetDataModel.with_metadata","title":"<code>with_metadata(metadata)</code>","text":"<p>Return a new instance with the given metadata.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def with_metadata(\n    self,\n    metadata: Any,\n) -&gt; \"WidgetDataModel[_T]\":\n    \"\"\"Return a new instance with the given metadata.\"\"\"\n    update = {\"metadata\": metadata}\n    return self.model_copy(update=update)\n</code></pre>"},{"location":"api/types/#himena.types.WidgetDataModel.with_title_numbering","title":"<code>with_title_numbering(copy=False)</code>","text":"<p>Add [n] suffix to the title.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def with_title_numbering(self, copy: bool = False) -&gt; \"WidgetDataModel[_T]\":\n    \"\"\"Add [n] suffix to the title.\"\"\"\n    title = self.title\n    if title is None:\n        title = \"Untitled\"\n    if \".\" in title:\n        stem, ext = title.rsplit(\".\", 1)\n        ext = f\".{ext}\"\n    else:\n        stem = title\n        ext = \"\"\n    if (\n        (last_part := stem.rsplit(\" \", 1)[-1]).startswith(\"[\")\n        and last_part.endswith(\"]\")\n        and last_part[1:-1].isdigit()\n    ):\n        nth = int(last_part[1:-1])\n        stem = stem.rsplit(\" \", 1)[0] + f\" [{nth + 1}]\"\n    else:\n        stem = stem + \" [1]\"\n    new_title = stem + ext\n    if copy:\n        return self.model_copy(update={\"title\": new_title})\n    else:\n        self.title = new_title\n        return self\n</code></pre>"},{"location":"api/types/#himena.types.WidgetDataModel.with_value","title":"<code>with_value(value, type=None, *, title=None, metadata=_void, save_behavior_override=_void)</code>","text":"<p>Return a model with the new value.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def with_value(\n    self,\n    value: _U,\n    type: str | None = None,\n    *,\n    title: str | None = None,\n    metadata: object | None = _void,\n    save_behavior_override: SaveBehavior | _Void | None = _void,\n) -&gt; \"WidgetDataModel[_U]\":\n    \"\"\"Return a model with the new value.\"\"\"\n    update = {\"value\": value}\n    if type is not None:\n        update[\"type\"] = type\n    if metadata is not _void:\n        update[\"metadata\"] = metadata\n    if title is not None:\n        update[\"title\"] = title\n    if save_behavior_override is not _void:\n        update[\"save_behavior_override\"] = save_behavior_override\n    update.update(\n        workflow=Workflow(),\n        force_open_with=None,\n    )  # these parameters must be reset\n    return self.model_copy(update=update)\n</code></pre>"},{"location":"api/types/#himena.types.WindowRect","title":"<code>WindowRect</code>  <code>dataclass</code>","text":"<p>Rectangle of a window.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>TypeVar</code> required <code>top</code> <code>TypeVar</code> required <code>width</code> <code>TypeVar</code> required <code>height</code> <code>TypeVar</code> required Source code in <code>src\\himena\\types.py</code> <pre><code>@dataclass(frozen=True)\nclass WindowRect(Rect[int]):\n    \"\"\"Rectangle of a window.\"\"\"\n\n    @classmethod\n    def from_tuple(cls, left, top, width, height) -&gt; \"WindowRect\":\n        return cls(int(left), int(top), int(width), int(height))\n\n    def align_left(self, area_size: Size[int]) -&gt; \"WindowRect\":\n        return WindowRect(0, self.top, self.width, self.height)\n\n    def align_right(self, area_size: Size[int]) -&gt; \"WindowRect\":\n        w0, _ = area_size\n        return WindowRect(w0 - self.width, self.top, self.width, self.height)\n\n    def align_top(self, area_size: Size[int]) -&gt; \"WindowRect\":\n        return WindowRect(self.left, 0, self.width, self.height)\n\n    def align_bottom(self, area_size: Size[int]) -&gt; \"WindowRect\":\n        _, h0 = area_size\n        return WindowRect(self.left, h0 - self.height, self.width, self.height)\n\n    def align_center(self, area_size: Size[int]) -&gt; \"WindowRect\":\n        w0, h0 = area_size\n        return WindowRect(\n            (w0 - self.width) / 2,\n            (h0 - self.height) / 2,\n            self.width,\n            self.height,\n        )\n\n    def resize_relative(self, wratio: float, hratio: float) -&gt; \"WindowRect\":\n        if wratio &lt;= 0 or hratio &lt;= 0:\n            raise ValueError(\"Ratios must be positive.\")\n        return WindowRect(\n            self.left,\n            self.top,\n            round(self.width * wratio),\n            round(self.height * hratio),\n        )\n</code></pre>"},{"location":"api/types/#himena.types.WindowState","title":"<code>WindowState</code>","text":"<p>State of the sub window.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>class WindowState(StrEnum):\n    \"\"\"State of the sub window.\"\"\"\n\n    MIN = \"min\"\n    MAX = \"max\"\n    NORMAL = \"normal\"\n    FULL = \"full\"\n</code></pre>"},{"location":"api/widgets/","title":"himena.widgets","text":""},{"location":"api/widgets/#himena.widgets.BackendMainWindow","title":"<code>BackendMainWindow</code>","text":"Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>class BackendMainWindow(Generic[_W]):  # pragma: no cover\n    _himena_main_window: MainWindow[_W]\n\n    def __init_subclass__(cls) -&gt; None:\n        for name in dir(BackendMainWindow):\n            if not hasattr(cls, name):\n                raise NotImplementedError(f\"Method {name} is not implemented.\")\n\n    def _update_widget_theme(self, theme: Theme):\n        \"\"\"Update the theme of the main window.\"\"\"\n\n    def _main_window_rect(self) -&gt; WindowRect:\n        \"\"\"Get the rect of the main window.\"\"\"\n\n    def _set_main_window_rect(self, rect: WindowRect) -&gt; None:\n        \"\"\"Set the rect of the main window.\"\"\"\n\n    def _current_tab_index(self) -&gt; int | None:\n        \"\"\"Get the current tab index.\n\n        If there is no tab, return None.\n        \"\"\"\n\n    def _set_current_tab_index(self, i_tab: int) -&gt; None:\n        \"\"\"Update the current tab index.\"\"\"\n\n    def _tab_hash(self, i_tab: int) -&gt; Hashable:\n        \"\"\"Get a hashable value of the tab at the index.\"\"\"\n\n    def _tab_hash_for_window(self, widget: _W) -&gt; Hashable:\n        \"\"\"Get a hashable value of the tab containing the window.\"\"\"\n\n    def _num_tabs(self) -&gt; int:\n        \"\"\"Get the number of tabs.\"\"\"\n\n    def _current_sub_window_index(self, i_tab: int) -&gt; int | None:\n        \"\"\"Get the current sub window index in the given tab.\n\n        If there is no sub window, or the tab area itself is selected, return None.\n        \"\"\"\n\n    def _set_current_sub_window_index(self, i_tab: int, i_window: int | None) -&gt; None:\n        \"\"\"Update the current sub window index in the given tab.\n\n        if `i_window` is None, the tab area itself will be selected (all the windows\n        will be deselected). `i_window` is asserted to be non-negative.\n        \"\"\"\n\n    def _set_control_widget(self, widget: _W, control: _W | None) -&gt; None:\n        \"\"\"Set the control widget for the given sub window widget.\n\n        A control widget appears on the top-right corner of the toolbar, which will be\n        used to display the state of the widget, edit the widget efficiently, etc. For\n        example, a font size spinbox for a text editor widget.\n        \"\"\"\n\n    def _update_control_widget(self, current: _W | None) -&gt; None:\n        \"\"\"Switch the control widget to another one in the existing ones.\n\n        If None is given, the control widget will be just hidden.\n        \"\"\"\n\n    def _remove_control_widget(self, widget: _W) -&gt; None:\n        \"\"\"Remove the control widget for the given sub window widget from the stack.\"\"\"\n\n    def _window_state(self, widget: _W) -&gt; WindowState:\n        \"\"\"The state (min, normal, etc.) of the window.\"\"\"\n\n    def _set_window_state(\n        self,\n        widget: _W,\n        state: WindowState,\n        inst: BackendInstructions,\n    ) -&gt; None:\n        \"\"\"Update the state of the window.\n\n        The BackendInstructions indicates the animation or other effects to be applied.\n        \"\"\"\n\n    def _tab_title(self, i_tab: int) -&gt; str:\n        \"\"\"Get the title of the tab at the index.\"\"\"\n\n    def _set_tab_title(self, i_tab: int, title: str) -&gt; None:\n        \"\"\"Update the title of the tab at the index.\"\"\"\n\n    def _window_title(self, widget: _W) -&gt; str:\n        \"\"\"Get the title of the window.\"\"\"\n\n    def _set_window_title(self, widget: _W, title: str) -&gt; None:\n        \"\"\"Update the title of the window.\"\"\"\n\n    def _window_rect(self, widget: _W) -&gt; WindowRect:\n        \"\"\"Get the rectangle relative to the tab area of the window.\"\"\"\n\n    def _set_window_rect(\n        self,\n        widget: _W,\n        rect: WindowRect,\n        inst: BackendInstructions,\n    ) -&gt; None:\n        \"\"\"Update the rectangle of the window.\n\n        The BackendInstructions indicates the animation or other effects to be applied.\n        \"\"\"\n\n    def _area_size(self) -&gt; tuple[int, int]:\n        \"\"\"Get the size of the tab area.\"\"\"\n\n    @overload\n    def _open_file_dialog(\n        self,\n        mode: Literal[\"r\", \"d\", \"w\"] = \"r\",\n        extension_default: str | None = None,\n        allowed_extensions: list[str] | None = None,\n        caption: str | None = None,\n        start_path: Path | None = None,\n    ) -&gt; Path | None: ...\n    @overload\n    def _open_file_dialog(\n        self,\n        mode: Literal[\"rm\"],\n        extension_default: str | None = None,\n        allowed_extensions: list[str] | None = None,\n        caption: str | None = None,\n        start_path: Path | None = None,\n    ) -&gt; list[Path] | None: ...\n\n    def _open_file_dialog(\n        self,\n        mode,\n        extension_default=None,\n        allowed_extensions=None,\n        caption=None,\n        start_path=None,\n    ):\n        \"\"\"Open a file dialog.\"\"\"\n\n    def _request_choice_dialog(\n        self,\n        title: str,\n        message: str,\n        choices: list[tuple[str, _T]],\n        how: Literal[\"buttons\", \"radiobuttons\"] = \"buttons\",\n    ) -&gt; _T | None:\n        \"\"\"Request a choice dialog and return the clicked text.\"\"\"\n\n    def _show_command_palette(self, kind: str) -&gt; None:\n        \"\"\"Show the command palette widget of the given kind.\"\"\"\n\n    def _exit_main_window(self, confirm: bool = False) -&gt; None:\n        \"\"\"Close the main window (confirm if needed).\"\"\"\n\n    def _get_widget_list(self, i_tab: int) -&gt; list[tuple[str, _W]]:\n        \"\"\"Get the list of widgets in the tab.\"\"\"\n\n    def _del_widget_at(self, i_tab: int, i_window: int) -&gt; None:\n        \"\"\"Delete the `i_window`-th window in the `i_tab`-th tab.\"\"\"\n\n    def _get_tab_name_list(self) -&gt; list[str]:\n        \"\"\"Get the list of tab names.\"\"\"\n\n    def _del_tab_at(self, i_tab: int) -&gt; None:\n        \"\"\"Delete the `i_tab`-th tab.\n\n        Backend does not need to close the subwindows one by one (will be done on the\n        wrapper side).\n        \"\"\"\n\n    def _rename_window_at(self, i_tab: int, i_window: int) -&gt; None:\n        \"\"\"Start renaming the `i_window`-th window in the `i_tab`-th tab.\"\"\"\n\n    def add_widget(self, widget: _W, i_tab: int, title: str) -&gt; _W:\n        \"\"\"Add a sub window containing the widget to the tab at the index.\n\n        Return the backend widget.\n        \"\"\"\n\n    def set_widget_as_preview(self, widget: _W):\n        \"\"\"Set the widget state as the preview mode.\"\"\"\n\n    def add_tab(self, title: str) -&gt; None:\n        \"\"\"Add a empty tab with the title.\"\"\"\n\n    def add_dock_widget(\n        self,\n        widget: _W,\n        title: str | None,\n        area: DockAreaString | DockArea | None = DockArea.RIGHT,\n        allowed_areas: list[DockAreaString | DockArea] | None = None,\n    ) -&gt; _W:\n        \"\"\"Add a dock widget containing the widget to the main window.\n\n        Return the backend dock widget.\n        \"\"\"\n\n    ### dock widgets ###\n    def _dock_widget_visible(self, widget: _W) -&gt; bool:\n        \"\"\"Whether the dock widget is visible.\"\"\"\n\n    def _set_dock_widget_visible(self, widget: _W, visible: bool) -&gt; None:\n        \"\"\"Update the visibility of the dock widget.\"\"\"\n\n    def _dock_widget_title(self, widget: _W) -&gt; str:\n        \"\"\"Get the title of the dock widget.\"\"\"\n\n    def _set_dock_widget_title(self, widget: _W, title: str) -&gt; None:\n        \"\"\"Update the title of the dock widget.\"\"\"\n\n    def _del_dock_widget(self, widget: _W) -&gt; None:\n        \"\"\"Delete the dock widget.\"\"\"\n\n    ### others ###\n    def show(self, run: bool = False) -&gt; None:\n        \"\"\"Show the main window and run the app immediately if `run` is True\"\"\"\n\n    def _list_widget_class(\n        self,\n        type: str,\n    ) -&gt; tuple[list[WidgetClassTuple], type[_W]]:\n        \"\"\"List the available widget classes of the given type.\n\n        The method will return (list of (widget model type, widget_class, priority),\n        fallback class)\n        \"\"\"\n\n    def _connect_main_window_signals(self, main_window: MainWindow[_W]):\n        \"\"\"Connect the signal of the backend main window to the callbacks.\"\"\"\n\n    def _connect_window_events(\n        self,\n        wrapper: SubWindow[_W],\n        backend: _W,\n    ):\n        \"\"\"Connect the events between the wrapper sub window and the backend widget.\"\"\"\n\n    def _update_context(self) -&gt; None:\n        \"\"\"Update the application context.\"\"\"\n\n    def _clipboard_data(self) -&gt; ClipboardDataModel | None:\n        \"\"\"Get the clipboard data.\"\"\"\n\n    def _set_clipboard_data(self, data: ClipboardDataModel) -&gt; None:\n        \"\"\"Set the clipboard data.\"\"\"\n\n    def _screenshot(self, target: str) -&gt; NDArray[np.uint8]:\n        \"\"\"Take a screenshot of the target area.\"\"\"\n\n    def _process_parametric_widget(self, widget: _W) -&gt; _W:\n        \"\"\"Process a parametric widget so that it can be added to the main window.\n\n        The incoming widget must implements the `get_params` method, which gives the\n        dictionary of parameters.\n        \"\"\"\n\n    def _connect_parametric_widget_events(\n        self,\n        wrapper: ParametricWindow[_W],\n        widget: _W,\n    ) -&gt; None:\n        \"\"\"Connect the events between the wrapper parametric window and the backend.\"\"\"\n\n    def _signature_to_widget(\n        self,\n        sig: inspect.Signature,\n        show_parameter_labels: bool = True,\n        preview: bool = False,\n    ) -&gt; _W:\n        \"\"\"Convert a function signature to a widget that can run it.\"\"\"\n\n    def _add_widget_to_parametric_window(\n        self,\n        wrapper: ParametricWindow[_W],\n        widget: _W,\n        result_as: Literal[\"below\", \"right\"],\n    ) -&gt; None:\n        \"\"\"Add a widget to the parametric window.\"\"\"\n\n    def _remove_widget_from_parametric_window(\n        self,\n        wrapper: ParametricWindow[_W],\n    ) -&gt; None:\n        \"\"\"Remove a widget from the parametric window.\"\"\"\n\n    def _move_focus_to(self, widget: _W) -&gt; None:\n        \"\"\"Move the focus to the widget.\"\"\"\n\n    def _set_status_tip(self, tip: str, duration: float) -&gt; None:\n        \"\"\"Set the status tip of the main window for a duration (sec).\"\"\"\n\n    def _show_notification(self, text: str, duration: float) -&gt; None:\n        \"\"\"Show notification for a duration (sec).\"\"\"\n\n    def _rebuild_for_runtime(self, new_menus: list[str]) -&gt; None:\n        \"\"\"Register the actions at runtime.\"\"\"\n\n    def _process_future_done_callback(\n        self,\n        cb: Callable[[Future], None],\n        cb_errored: Callable[[Exception], None],\n        **kwargs,\n    ) -&gt; Callable[[Future], None]:\n        \"\"\"Wrap the callback of the future done event so that it can be run in the main\n        thread.\"\"\"\n\n    def _set_parametric_widget_busy(self, wrapper: ParametricWindow[_W], busy: bool):\n        \"\"\"Set the parametric widget busy status (disable call button etc).\"\"\"\n\n    def _add_job_progress(self, future: Future, desc: str, total: int = 0) -&gt; None:\n        \"\"\"Add a job to the job stack.\"\"\"\n\n    def _add_whats_this(self, text: str, style: Literal[\"plain\", \"markdown\", \"html\"]):\n        \"\"\"Add a what's this text to the main window.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._add_job_progress","title":"<code>_add_job_progress(future, desc, total=0)</code>","text":"<p>Add a job to the job stack.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _add_job_progress(self, future: Future, desc: str, total: int = 0) -&gt; None:\n    \"\"\"Add a job to the job stack.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._add_whats_this","title":"<code>_add_whats_this(text, style)</code>","text":"<p>Add a what's this text to the main window.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _add_whats_this(self, text: str, style: Literal[\"plain\", \"markdown\", \"html\"]):\n    \"\"\"Add a what's this text to the main window.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._add_widget_to_parametric_window","title":"<code>_add_widget_to_parametric_window(wrapper, widget, result_as)</code>","text":"<p>Add a widget to the parametric window.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _add_widget_to_parametric_window(\n    self,\n    wrapper: ParametricWindow[_W],\n    widget: _W,\n    result_as: Literal[\"below\", \"right\"],\n) -&gt; None:\n    \"\"\"Add a widget to the parametric window.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._area_size","title":"<code>_area_size()</code>","text":"<p>Get the size of the tab area.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _area_size(self) -&gt; tuple[int, int]:\n    \"\"\"Get the size of the tab area.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._clipboard_data","title":"<code>_clipboard_data()</code>","text":"<p>Get the clipboard data.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _clipboard_data(self) -&gt; ClipboardDataModel | None:\n    \"\"\"Get the clipboard data.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._connect_main_window_signals","title":"<code>_connect_main_window_signals(main_window)</code>","text":"<p>Connect the signal of the backend main window to the callbacks.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _connect_main_window_signals(self, main_window: MainWindow[_W]):\n    \"\"\"Connect the signal of the backend main window to the callbacks.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._connect_parametric_widget_events","title":"<code>_connect_parametric_widget_events(wrapper, widget)</code>","text":"<p>Connect the events between the wrapper parametric window and the backend.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _connect_parametric_widget_events(\n    self,\n    wrapper: ParametricWindow[_W],\n    widget: _W,\n) -&gt; None:\n    \"\"\"Connect the events between the wrapper parametric window and the backend.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._connect_window_events","title":"<code>_connect_window_events(wrapper, backend)</code>","text":"<p>Connect the events between the wrapper sub window and the backend widget.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _connect_window_events(\n    self,\n    wrapper: SubWindow[_W],\n    backend: _W,\n):\n    \"\"\"Connect the events between the wrapper sub window and the backend widget.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._current_sub_window_index","title":"<code>_current_sub_window_index(i_tab)</code>","text":"<p>Get the current sub window index in the given tab.</p> <p>If there is no sub window, or the tab area itself is selected, return None.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _current_sub_window_index(self, i_tab: int) -&gt; int | None:\n    \"\"\"Get the current sub window index in the given tab.\n\n    If there is no sub window, or the tab area itself is selected, return None.\n    \"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._current_tab_index","title":"<code>_current_tab_index()</code>","text":"<p>Get the current tab index.</p> <p>If there is no tab, return None.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _current_tab_index(self) -&gt; int | None:\n    \"\"\"Get the current tab index.\n\n    If there is no tab, return None.\n    \"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._del_dock_widget","title":"<code>_del_dock_widget(widget)</code>","text":"<p>Delete the dock widget.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _del_dock_widget(self, widget: _W) -&gt; None:\n    \"\"\"Delete the dock widget.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._del_tab_at","title":"<code>_del_tab_at(i_tab)</code>","text":"<p>Delete the <code>i_tab</code>-th tab.</p> <p>Backend does not need to close the subwindows one by one (will be done on the wrapper side).</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _del_tab_at(self, i_tab: int) -&gt; None:\n    \"\"\"Delete the `i_tab`-th tab.\n\n    Backend does not need to close the subwindows one by one (will be done on the\n    wrapper side).\n    \"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._del_widget_at","title":"<code>_del_widget_at(i_tab, i_window)</code>","text":"<p>Delete the <code>i_window</code>-th window in the <code>i_tab</code>-th tab.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _del_widget_at(self, i_tab: int, i_window: int) -&gt; None:\n    \"\"\"Delete the `i_window`-th window in the `i_tab`-th tab.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._dock_widget_title","title":"<code>_dock_widget_title(widget)</code>","text":"<p>Get the title of the dock widget.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _dock_widget_title(self, widget: _W) -&gt; str:\n    \"\"\"Get the title of the dock widget.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._dock_widget_visible","title":"<code>_dock_widget_visible(widget)</code>","text":"<p>Whether the dock widget is visible.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _dock_widget_visible(self, widget: _W) -&gt; bool:\n    \"\"\"Whether the dock widget is visible.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._exit_main_window","title":"<code>_exit_main_window(confirm=False)</code>","text":"<p>Close the main window (confirm if needed).</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _exit_main_window(self, confirm: bool = False) -&gt; None:\n    \"\"\"Close the main window (confirm if needed).\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._get_tab_name_list","title":"<code>_get_tab_name_list()</code>","text":"<p>Get the list of tab names.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _get_tab_name_list(self) -&gt; list[str]:\n    \"\"\"Get the list of tab names.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._get_widget_list","title":"<code>_get_widget_list(i_tab)</code>","text":"<p>Get the list of widgets in the tab.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _get_widget_list(self, i_tab: int) -&gt; list[tuple[str, _W]]:\n    \"\"\"Get the list of widgets in the tab.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._list_widget_class","title":"<code>_list_widget_class(type)</code>","text":"<p>List the available widget classes of the given type.</p> <p>The method will return (list of (widget model type, widget_class, priority), fallback class)</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _list_widget_class(\n    self,\n    type: str,\n) -&gt; tuple[list[WidgetClassTuple], type[_W]]:\n    \"\"\"List the available widget classes of the given type.\n\n    The method will return (list of (widget model type, widget_class, priority),\n    fallback class)\n    \"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._main_window_rect","title":"<code>_main_window_rect()</code>","text":"<p>Get the rect of the main window.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _main_window_rect(self) -&gt; WindowRect:\n    \"\"\"Get the rect of the main window.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._move_focus_to","title":"<code>_move_focus_to(widget)</code>","text":"<p>Move the focus to the widget.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _move_focus_to(self, widget: _W) -&gt; None:\n    \"\"\"Move the focus to the widget.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._num_tabs","title":"<code>_num_tabs()</code>","text":"<p>Get the number of tabs.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _num_tabs(self) -&gt; int:\n    \"\"\"Get the number of tabs.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._open_file_dialog","title":"<code>_open_file_dialog(mode, extension_default=None, allowed_extensions=None, caption=None, start_path=None)</code>","text":"<pre><code>_open_file_dialog(mode: Literal['r', 'd', 'w'] = 'r', extension_default: str | None = None, allowed_extensions: list[str] | None = None, caption: str | None = None, start_path: Path | None = None) -&gt; Path | None\n</code></pre><pre><code>_open_file_dialog(mode: Literal['rm'], extension_default: str | None = None, allowed_extensions: list[str] | None = None, caption: str | None = None, start_path: Path | None = None) -&gt; list[Path] | None\n</code></pre> <p>Open a file dialog.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _open_file_dialog(\n    self,\n    mode,\n    extension_default=None,\n    allowed_extensions=None,\n    caption=None,\n    start_path=None,\n):\n    \"\"\"Open a file dialog.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._process_future_done_callback","title":"<code>_process_future_done_callback(cb, cb_errored, **kwargs)</code>","text":"<p>Wrap the callback of the future done event so that it can be run in the main thread.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _process_future_done_callback(\n    self,\n    cb: Callable[[Future], None],\n    cb_errored: Callable[[Exception], None],\n    **kwargs,\n) -&gt; Callable[[Future], None]:\n    \"\"\"Wrap the callback of the future done event so that it can be run in the main\n    thread.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._process_parametric_widget","title":"<code>_process_parametric_widget(widget)</code>","text":"<p>Process a parametric widget so that it can be added to the main window.</p> <p>The incoming widget must implements the <code>get_params</code> method, which gives the dictionary of parameters.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _process_parametric_widget(self, widget: _W) -&gt; _W:\n    \"\"\"Process a parametric widget so that it can be added to the main window.\n\n    The incoming widget must implements the `get_params` method, which gives the\n    dictionary of parameters.\n    \"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._rebuild_for_runtime","title":"<code>_rebuild_for_runtime(new_menus)</code>","text":"<p>Register the actions at runtime.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _rebuild_for_runtime(self, new_menus: list[str]) -&gt; None:\n    \"\"\"Register the actions at runtime.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._remove_control_widget","title":"<code>_remove_control_widget(widget)</code>","text":"<p>Remove the control widget for the given sub window widget from the stack.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _remove_control_widget(self, widget: _W) -&gt; None:\n    \"\"\"Remove the control widget for the given sub window widget from the stack.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._remove_widget_from_parametric_window","title":"<code>_remove_widget_from_parametric_window(wrapper)</code>","text":"<p>Remove a widget from the parametric window.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _remove_widget_from_parametric_window(\n    self,\n    wrapper: ParametricWindow[_W],\n) -&gt; None:\n    \"\"\"Remove a widget from the parametric window.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._rename_window_at","title":"<code>_rename_window_at(i_tab, i_window)</code>","text":"<p>Start renaming the <code>i_window</code>-th window in the <code>i_tab</code>-th tab.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _rename_window_at(self, i_tab: int, i_window: int) -&gt; None:\n    \"\"\"Start renaming the `i_window`-th window in the `i_tab`-th tab.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._request_choice_dialog","title":"<code>_request_choice_dialog(title, message, choices, how='buttons')</code>","text":"<p>Request a choice dialog and return the clicked text.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _request_choice_dialog(\n    self,\n    title: str,\n    message: str,\n    choices: list[tuple[str, _T]],\n    how: Literal[\"buttons\", \"radiobuttons\"] = \"buttons\",\n) -&gt; _T | None:\n    \"\"\"Request a choice dialog and return the clicked text.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._screenshot","title":"<code>_screenshot(target)</code>","text":"<p>Take a screenshot of the target area.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _screenshot(self, target: str) -&gt; NDArray[np.uint8]:\n    \"\"\"Take a screenshot of the target area.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._set_clipboard_data","title":"<code>_set_clipboard_data(data)</code>","text":"<p>Set the clipboard data.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _set_clipboard_data(self, data: ClipboardDataModel) -&gt; None:\n    \"\"\"Set the clipboard data.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._set_control_widget","title":"<code>_set_control_widget(widget, control)</code>","text":"<p>Set the control widget for the given sub window widget.</p> <p>A control widget appears on the top-right corner of the toolbar, which will be used to display the state of the widget, edit the widget efficiently, etc. For example, a font size spinbox for a text editor widget.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _set_control_widget(self, widget: _W, control: _W | None) -&gt; None:\n    \"\"\"Set the control widget for the given sub window widget.\n\n    A control widget appears on the top-right corner of the toolbar, which will be\n    used to display the state of the widget, edit the widget efficiently, etc. For\n    example, a font size spinbox for a text editor widget.\n    \"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._set_current_sub_window_index","title":"<code>_set_current_sub_window_index(i_tab, i_window)</code>","text":"<p>Update the current sub window index in the given tab.</p> <p>if <code>i_window</code> is None, the tab area itself will be selected (all the windows will be deselected). <code>i_window</code> is asserted to be non-negative.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _set_current_sub_window_index(self, i_tab: int, i_window: int | None) -&gt; None:\n    \"\"\"Update the current sub window index in the given tab.\n\n    if `i_window` is None, the tab area itself will be selected (all the windows\n    will be deselected). `i_window` is asserted to be non-negative.\n    \"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._set_current_tab_index","title":"<code>_set_current_tab_index(i_tab)</code>","text":"<p>Update the current tab index.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _set_current_tab_index(self, i_tab: int) -&gt; None:\n    \"\"\"Update the current tab index.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._set_dock_widget_title","title":"<code>_set_dock_widget_title(widget, title)</code>","text":"<p>Update the title of the dock widget.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _set_dock_widget_title(self, widget: _W, title: str) -&gt; None:\n    \"\"\"Update the title of the dock widget.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._set_dock_widget_visible","title":"<code>_set_dock_widget_visible(widget, visible)</code>","text":"<p>Update the visibility of the dock widget.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _set_dock_widget_visible(self, widget: _W, visible: bool) -&gt; None:\n    \"\"\"Update the visibility of the dock widget.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._set_main_window_rect","title":"<code>_set_main_window_rect(rect)</code>","text":"<p>Set the rect of the main window.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _set_main_window_rect(self, rect: WindowRect) -&gt; None:\n    \"\"\"Set the rect of the main window.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._set_parametric_widget_busy","title":"<code>_set_parametric_widget_busy(wrapper, busy)</code>","text":"<p>Set the parametric widget busy status (disable call button etc).</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _set_parametric_widget_busy(self, wrapper: ParametricWindow[_W], busy: bool):\n    \"\"\"Set the parametric widget busy status (disable call button etc).\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._set_status_tip","title":"<code>_set_status_tip(tip, duration)</code>","text":"<p>Set the status tip of the main window for a duration (sec).</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _set_status_tip(self, tip: str, duration: float) -&gt; None:\n    \"\"\"Set the status tip of the main window for a duration (sec).\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._set_tab_title","title":"<code>_set_tab_title(i_tab, title)</code>","text":"<p>Update the title of the tab at the index.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _set_tab_title(self, i_tab: int, title: str) -&gt; None:\n    \"\"\"Update the title of the tab at the index.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._set_window_rect","title":"<code>_set_window_rect(widget, rect, inst)</code>","text":"<p>Update the rectangle of the window.</p> <p>The BackendInstructions indicates the animation or other effects to be applied.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _set_window_rect(\n    self,\n    widget: _W,\n    rect: WindowRect,\n    inst: BackendInstructions,\n) -&gt; None:\n    \"\"\"Update the rectangle of the window.\n\n    The BackendInstructions indicates the animation or other effects to be applied.\n    \"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._set_window_state","title":"<code>_set_window_state(widget, state, inst)</code>","text":"<p>Update the state of the window.</p> <p>The BackendInstructions indicates the animation or other effects to be applied.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _set_window_state(\n    self,\n    widget: _W,\n    state: WindowState,\n    inst: BackendInstructions,\n) -&gt; None:\n    \"\"\"Update the state of the window.\n\n    The BackendInstructions indicates the animation or other effects to be applied.\n    \"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._set_window_title","title":"<code>_set_window_title(widget, title)</code>","text":"<p>Update the title of the window.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _set_window_title(self, widget: _W, title: str) -&gt; None:\n    \"\"\"Update the title of the window.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._show_command_palette","title":"<code>_show_command_palette(kind)</code>","text":"<p>Show the command palette widget of the given kind.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _show_command_palette(self, kind: str) -&gt; None:\n    \"\"\"Show the command palette widget of the given kind.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._show_notification","title":"<code>_show_notification(text, duration)</code>","text":"<p>Show notification for a duration (sec).</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _show_notification(self, text: str, duration: float) -&gt; None:\n    \"\"\"Show notification for a duration (sec).\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._signature_to_widget","title":"<code>_signature_to_widget(sig, show_parameter_labels=True, preview=False)</code>","text":"<p>Convert a function signature to a widget that can run it.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _signature_to_widget(\n    self,\n    sig: inspect.Signature,\n    show_parameter_labels: bool = True,\n    preview: bool = False,\n) -&gt; _W:\n    \"\"\"Convert a function signature to a widget that can run it.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._tab_hash","title":"<code>_tab_hash(i_tab)</code>","text":"<p>Get a hashable value of the tab at the index.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _tab_hash(self, i_tab: int) -&gt; Hashable:\n    \"\"\"Get a hashable value of the tab at the index.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._tab_hash_for_window","title":"<code>_tab_hash_for_window(widget)</code>","text":"<p>Get a hashable value of the tab containing the window.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _tab_hash_for_window(self, widget: _W) -&gt; Hashable:\n    \"\"\"Get a hashable value of the tab containing the window.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._tab_title","title":"<code>_tab_title(i_tab)</code>","text":"<p>Get the title of the tab at the index.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _tab_title(self, i_tab: int) -&gt; str:\n    \"\"\"Get the title of the tab at the index.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._update_context","title":"<code>_update_context()</code>","text":"<p>Update the application context.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _update_context(self) -&gt; None:\n    \"\"\"Update the application context.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._update_control_widget","title":"<code>_update_control_widget(current)</code>","text":"<p>Switch the control widget to another one in the existing ones.</p> <p>If None is given, the control widget will be just hidden.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _update_control_widget(self, current: _W | None) -&gt; None:\n    \"\"\"Switch the control widget to another one in the existing ones.\n\n    If None is given, the control widget will be just hidden.\n    \"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._update_widget_theme","title":"<code>_update_widget_theme(theme)</code>","text":"<p>Update the theme of the main window.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _update_widget_theme(self, theme: Theme):\n    \"\"\"Update the theme of the main window.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._window_rect","title":"<code>_window_rect(widget)</code>","text":"<p>Get the rectangle relative to the tab area of the window.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _window_rect(self, widget: _W) -&gt; WindowRect:\n    \"\"\"Get the rectangle relative to the tab area of the window.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._window_state","title":"<code>_window_state(widget)</code>","text":"<p>The state (min, normal, etc.) of the window.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _window_state(self, widget: _W) -&gt; WindowState:\n    \"\"\"The state (min, normal, etc.) of the window.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow._window_title","title":"<code>_window_title(widget)</code>","text":"<p>Get the title of the window.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def _window_title(self, widget: _W) -&gt; str:\n    \"\"\"Get the title of the window.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow.add_dock_widget","title":"<code>add_dock_widget(widget, title, area=DockArea.RIGHT, allowed_areas=None)</code>","text":"<p>Add a dock widget containing the widget to the main window.</p> <p>Return the backend dock widget.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def add_dock_widget(\n    self,\n    widget: _W,\n    title: str | None,\n    area: DockAreaString | DockArea | None = DockArea.RIGHT,\n    allowed_areas: list[DockAreaString | DockArea] | None = None,\n) -&gt; _W:\n    \"\"\"Add a dock widget containing the widget to the main window.\n\n    Return the backend dock widget.\n    \"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow.add_tab","title":"<code>add_tab(title)</code>","text":"<p>Add a empty tab with the title.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def add_tab(self, title: str) -&gt; None:\n    \"\"\"Add a empty tab with the title.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow.add_widget","title":"<code>add_widget(widget, i_tab, title)</code>","text":"<p>Add a sub window containing the widget to the tab at the index.</p> <p>Return the backend widget.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def add_widget(self, widget: _W, i_tab: int, title: str) -&gt; _W:\n    \"\"\"Add a sub window containing the widget to the tab at the index.\n\n    Return the backend widget.\n    \"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow.set_widget_as_preview","title":"<code>set_widget_as_preview(widget)</code>","text":"<p>Set the widget state as the preview mode.</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def set_widget_as_preview(self, widget: _W):\n    \"\"\"Set the widget state as the preview mode.\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.BackendMainWindow.show","title":"<code>show(run=False)</code>","text":"<p>Show the main window and run the app immediately if <code>run</code> is True</p> Source code in <code>src\\himena\\widgets\\_backend.py</code> <pre><code>def show(self, run: bool = False) -&gt; None:\n    \"\"\"Show the main window and run the app immediately if `run` is True\"\"\"\n</code></pre>"},{"location":"api/widgets/#himena.widgets.DockWidget","title":"<code>DockWidget</code>","text":"Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>class DockWidget(WidgetWrapper[_W]):\n    def __init__(\n        self,\n        widget: _W,\n        main_window: BackendMainWindow[_W],\n        identifier: uuid.UUID | None = None,\n    ):\n        super().__init__(widget, main_window, identifier)\n        self._has_update_configs = hasattr(widget, \"update_configs\")\n        self._parse_config_cache: Callable[[dict], Any] | None = None\n        self._command_id: str | None = None\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"{type(self).__name__}(title={self.title!r}, widget={_widget_repr(self)})\"\n        )\n\n    @property\n    def visible(self) -&gt; bool:\n        \"\"\"Visibility of the dock widget.\"\"\"\n        return self._main_window()._dock_widget_visible(self._frontend_widget())\n\n    @visible.setter\n    def visible(self, visible: bool) -&gt; bool:\n        return self._main_window()._set_dock_widget_visible(\n            self._frontend_widget(), visible\n        )\n\n    def show(self) -&gt; None:\n        \"\"\"Show the dock widget.\"\"\"\n        self.visible = True\n\n    def hide(self) -&gt; None:\n        \"\"\"Hide the dock widget.\"\"\"\n        self.visible = False\n\n    @property\n    def title(self) -&gt; str:\n        \"\"\"Title of the dock widget.\"\"\"\n        return self._main_window()._dock_widget_title(self._frontend_widget())\n\n    @title.setter\n    def title(self, title: str) -&gt; None:\n        return self._main_window()._set_dock_widget_title(\n            self._frontend_widget(), str(title)\n        )\n\n    def _parse_config(self, cfg_dict: dict[str, Any]) -&gt; Any:\n        if self._parse_config_cache is not None:\n            return self._parse_config_cache(**cfg_dict)\n        cfgs = AppActionRegistry.instance()._plugin_default_configs\n        cfg_type = cfgs[self._command_id].config_class\n        self._parse_config_cache = cfg_type\n        return cfg_type(**cfg_dict)\n\n    def update_configs(self, cfg: Any):\n        \"\"\"Update the configuration of the dock widget.\"\"\"\n        if self._has_update_configs:\n            if isinstance(cfg, dict):\n                cfg = self._parse_config(cfg)\n            self.widget.update_configs(cfg)\n        return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.DockWidget.title","title":"<code>title</code>  <code>property</code> <code>writable</code>","text":"<p>Title of the dock widget.</p>"},{"location":"api/widgets/#himena.widgets.DockWidget.visible","title":"<code>visible</code>  <code>property</code> <code>writable</code>","text":"<p>Visibility of the dock widget.</p>"},{"location":"api/widgets/#himena.widgets.DockWidget.hide","title":"<code>hide()</code>","text":"<p>Hide the dock widget.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def hide(self) -&gt; None:\n    \"\"\"Hide the dock widget.\"\"\"\n    self.visible = False\n</code></pre>"},{"location":"api/widgets/#himena.widgets.DockWidget.show","title":"<code>show()</code>","text":"<p>Show the dock widget.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Show the dock widget.\"\"\"\n    self.visible = True\n</code></pre>"},{"location":"api/widgets/#himena.widgets.DockWidget.update_configs","title":"<code>update_configs(cfg)</code>","text":"<p>Update the configuration of the dock widget.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def update_configs(self, cfg: Any):\n    \"\"\"Update the configuration of the dock widget.\"\"\"\n    if self._has_update_configs:\n        if isinstance(cfg, dict):\n            cfg = self._parse_config(cfg)\n        self.widget.update_configs(cfg)\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow","title":"<code>MainWindow</code>","text":"<p>The main window object.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>class MainWindow(Generic[_W]):\n    \"\"\"The main window object.\"\"\"\n\n    def __init__(\n        self,\n        backend: BackendMainWindow[_W],\n        app: HimenaApplication,  # must be initialized\n        theme: Theme,\n    ) -&gt; None:\n        from himena.widgets._initialize import set_current_instance\n\n        self._events = MainWindowEvents()\n        self._backend_main_window = backend\n        self._internal_clipboard_data: Any | None = None\n        self._tab_list = TabList(backend)\n        self._new_widget_behavior = NewWidgetBehavior.WINDOW\n        self._model_app = app\n        self._instructions = BackendInstructions()\n        self._history_tab = HistoryContainer[int](max_size=20)\n        self._history_command = HistoryContainer[str](max_size=200)\n        self._history_closed = HistoryContainer[tuple[Path, str | None]](max_size=10)\n        self._file_dialog_hist = FileDialogHistoryDict()\n        app.commands.executed.connect(self._on_command_execution)\n        backend._connect_main_window_signals(self)\n        self._ctx_keys = AppContext(create_context(self, max_depth=0))\n        self._tab_list.changed.connect(backend._update_context)\n        self._dock_widget_list = DockWidgetList(backend)\n        self._recent_manager = RecentFileManager.default(app)\n        self._recent_session_manager = RecentSessionManager.default(app)\n        if \".\" not in app.name:\n            # likely a mock instance\n            set_current_instance(app.name, self)\n            self._recent_manager.update_menu()\n            self._recent_session_manager.update_menu()\n        self._executor = ThreadPoolExecutor(max_workers=5)\n        self._global_lock = threading.Lock()\n        self._object_type_map = ObjectTypeMap()\n        self.theme = theme\n        register_defaults(self._object_type_map)\n\n    @property\n    def events(self) -&gt; MainWindowEvents[_W]:\n        \"\"\"Main window events.\"\"\"\n        return self._events\n\n    @property\n    def object_type_map(self) -&gt; ObjectTypeMap:\n        \"\"\"Mapping object to string that describes the type.\"\"\"\n        return self._object_type_map\n\n    @property\n    def theme(self) -&gt; Theme:\n        \"\"\"Get the current color theme of the main window.\"\"\"\n        return self._theme\n\n    @theme.setter\n    def theme(self, theme: str | Theme) -&gt; None:\n        \"\"\"Set the style of the main window.\"\"\"\n        if isinstance(theme, str):\n            theme = Theme.from_global(theme)\n        self._theme = theme\n        self._backend_main_window._update_widget_theme(theme)\n\n        # if child implements \"theme_changed_callback\", call it\n        for win in self.iter_windows():\n            _checker.call_theme_changed_callback(win.widget, theme)\n        for dock in self.dock_widgets:\n            _checker.call_theme_changed_callback(dock.widget, theme)\n        return None\n\n    @property\n    def app_profile(self) -&gt; AppProfile:\n        \"\"\"Get the current application profile object.\"\"\"\n        return load_app_profile(self._model_app.name)\n\n    def submit_async_task(\n        self,\n        func: Callable,\n        *args,\n        progress_description: str | None = None,\n        **kwargs,\n    ) -&gt; Future:\n        \"\"\"Submit a task to the thread pool.\"\"\"\n        future = self._executor.submit(func, *args, **kwargs)\n        if progress_description is None:\n            progress_description = f\"Running {func!r}\"\n        self._backend_main_window._add_job_progress(\n            future, desc=progress_description, total=0\n        )\n        self.model_app.injection_store.process(future)\n        return future\n\n    @property\n    def tabs(self) -&gt; TabList[_W]:\n        \"\"\"Tab list object.\"\"\"\n        return self._tab_list\n\n    @property\n    def dock_widgets(self) -&gt; DockWidgetList[_W]:\n        \"\"\"Dock widget list object.\"\"\"\n        return self._dock_widget_list\n\n    @property\n    def model_app(self) -&gt; HimenaApplication:\n        \"\"\"The app-model application instance.\"\"\"\n        return self._model_app\n\n    @property\n    def area_size(self) -&gt; tuple[int, int]:\n        \"\"\"(width, height) of the main window tab area.\"\"\"\n        return self._backend_main_window._area_size()\n\n    @property\n    def rect(self) -&gt; WindowRect:\n        \"\"\"Window rect (left, top, width, height) of the main window.\"\"\"\n        return self._backend_main_window._main_window_rect()\n\n    @rect.setter\n    def rect(self, value) -&gt; None:\n        rect = WindowRect.from_tuple(*value)\n        return self._backend_main_window._set_main_window_rect(rect)\n\n    @property\n    def size(self) -&gt; Size:\n        \"\"\"Size (width, height) of the main window.\"\"\"\n        return self.rect.size()\n\n    @size.setter\n    def size(self, size) -&gt; None:\n        r0 = self.rect\n        s0 = Size(*size)\n        self.rect = WindowRect(r0.left, r0.top, s0.width, s0.height)\n        return None\n\n    @property\n    def clipboard(self) -&gt; ClipboardDataModel | None:\n        \"\"\"Get the clipboard data as a ClipboardDataModel instance.\"\"\"\n        model = self._backend_main_window._clipboard_data()\n        model.internal_data = self._internal_clipboard_data\n        return model\n\n    @clipboard.setter\n    def clipboard(self, data: str | ClipboardDataModel) -&gt; None:\n        \"\"\"Set the clipboard data.\"\"\"\n        if isinstance(data, str):\n            data = ClipboardDataModel(text=data)\n        elif not isinstance(data, ClipboardDataModel):\n            raise ValueError(\"Clipboard data must be a ClipboardDataModel instance.\")\n        _LOGGER.info(\"Setting clipboard data: %r\", data)\n        self._backend_main_window._set_clipboard_data(data)\n        self._internal_clipboard_data = data.internal_data\n        return None\n\n    def set_clipboard(\n        self,\n        *,\n        text: str | None = None,\n        html: str | None = None,\n        image: Any | None = None,\n        files: list[str | Path] | None = None,\n        internal_data: Any | None = None,\n    ) -&gt; None:\n        self.clipboard = ClipboardDataModel(\n            text=text,\n            html=html,\n            image=image,\n            files=files or [],\n            internal_data=internal_data,\n        )\n        return None\n\n    def add_tab(self, title: str | None = None) -&gt; TabArea[_W]:\n        \"\"\"Add a new tab of given name.\"\"\"\n        return self.tabs.add(title)\n\n    def window_for_id(self, identifier: uuid.UUID) -&gt; SubWindow[_W] | None:\n        \"\"\"Retrieve a sub-window by its identifier.\"\"\"\n        if not isinstance(identifier, uuid.UUID):\n            raise ValueError(f\"Expected UUID, got {identifier!r}.\")\n        for win in self.iter_windows():\n            if win._identifier == identifier:\n                return win\n        return None\n\n    def _current_or_new_tab(self) -&gt; tuple[int, TabArea[_W]]:\n        if self._new_widget_behavior is NewWidgetBehavior.WINDOW:\n            if len(self.tabs) == 0:\n                self.add_tab()\n                idx = 0\n            else:\n                idx = self._backend_main_window._current_tab_index()\n            tabarea = self.tabs[idx]\n        else:\n            tabarea = self.add_tab()\n            idx = len(self.tabs) - 1\n        return idx, tabarea\n\n    def add_widget(\n        self,\n        widget: _W,\n        *,\n        title: str | None = None,\n    ) -&gt; SubWindow[_W]:\n        \"\"\"Add a widget to the sub window.\n\n        Parameters\n        ----------\n        widget : QtW.QWidget\n            Widget to add.\n        title : str, optional\n            Title of the sub-window. If not given, its name will be automatically\n            generated.\n\n        Returns\n        -------\n        SubWindow\n            The sub-window handler.\n        \"\"\"\n        _, tabarea = self._current_or_new_tab()\n        return tabarea.add_widget(widget, title=title)\n\n    def add_dock_widget(\n        self,\n        widget: _W,\n        *,\n        title: str | None = None,\n        area: DockAreaString | DockArea | None = DockArea.RIGHT,\n        allowed_areas: list[DockAreaString | DockArea] | None = None,\n        _identifier: uuid.UUID | None = None,\n    ) -&gt; DockWidget[_W]:\n        \"\"\"Add a custom widget as a dock widget of the main window.\n\n        Parameters\n        ----------\n        widget : Widget type\n            Widget instance that is allowed for the backend.\n        title : str, optional\n            Title of the dock widget.\n        area : dock area, default DockArea.RIGHT\n            String or DockArea enum that describes where the dock widget initially\n            appears.\n        allowed_areas : list of dock area, optional\n            List of allowed dock areas for the widget.\n\n        Returns\n        -------\n        DockWidget\n            The dock widget handler.\n        \"\"\"\n        dock = DockWidget(widget, self._backend_main_window, identifier=_identifier)\n        dock_native = dock._split_interface_and_frontend()[1]\n        self._backend_main_window.add_dock_widget(\n            dock_native, title=title, area=area, allowed_areas=allowed_areas\n        )\n        self._dock_widget_list._add_dock_widget(dock)\n        _checker.call_widget_added_callback(widget)\n        _checker.call_theme_changed_callback(widget, self.theme)\n        return dock\n\n    def add_object(\n        self,\n        value: Any,\n        *,\n        type: str | None = None,\n        title: str | None = None,\n        force_open_with: str | None = None,\n        metadata: Any | None = None,\n    ) -&gt; SubWindow[_W]:\n        \"\"\"Add any data as a widget data model.\n\n        Parameters\n        ----------\n        value : Any\n            Any object. Whether it can be represented as a widget is dependent on the\n            plugins that are installed.\n        type : str, optional\n            Any str that describes the type of the object. This type must be registered\n            with a proper widget class.\n        title : str, optional\n            Title of the sub-window.\n\n        Returns\n        -------\n        SubWindow\n            The sub-window handler.\n        \"\"\"\n        if type is None:\n            type = self._object_type_map.pick_type(value)\n        wd = WidgetDataModel(\n            value=value,\n            type=type,\n            title=title,\n            force_open_with=force_open_with,\n            metadata=metadata,\n            workflow=ProgrammaticMethod(output_model_type=type).construct_workflow(),\n        )\n        return self.add_data_model(wd)\n\n    def add_data_model(self, model_data: WidgetDataModel) -&gt; SubWindow[_W]:\n        \"\"\"Add a widget data model as a widget.\"\"\"\n        _, tabarea = self._current_or_new_tab()\n        return tabarea.add_data_model(model_data)\n\n    def add_function(\n        self,\n        func: Callable[..., _T],\n        *,\n        preview: bool = False,\n        title: str | None = None,\n        show_parameter_labels: bool = True,\n        auto_close: bool = True,\n        run_async: bool = False,\n        result_as: Literal[\"window\", \"below\", \"right\"] = \"window\",\n    ) -&gt; ParametricWindow[_W]:\n        \"\"\"Add a function as a parametric sub-window.\n\n        The input function must return a `WidgetDataModel` instance, which can be\n        interpreted by the application.\n\n        Parameters\n        ----------\n        func : function (...) -&gt; WidgetDataModel\n            Function that generates a model from the input parameters.\n        title : str, optional\n            Title of the sub-window.\n\n        Returns\n        -------\n        SubWindow\n            The sub-window instance that represents the output model.\n        \"\"\"\n        _, tabarea = self._current_or_new_tab()\n        return tabarea.add_function(\n            func, title=title, preview=preview, result_as=result_as,\n            show_parameter_labels=show_parameter_labels, auto_close=auto_close,\n            run_async=run_async,\n        )  # fmt: skip\n\n    def add_parametric_widget(\n        self,\n        widget: _W,\n        callback: Callable | None = None,\n        *,\n        title: str | None = None,\n        preview: bool = False,\n        auto_close: bool = True,\n        auto_size: bool = True,\n        run_async: bool = False,\n        result_as: Literal[\"window\", \"below\", \"right\"] = \"window\",\n    ) -&gt; ParametricWindow[_W]:\n        _, area = self._current_or_new_tab()\n        return area.add_parametric_widget(\n            widget, callback, title=title, preview=preview, auto_close=auto_close,\n            auto_size=auto_size, result_as=result_as, run_async=run_async,\n        )  # fmt: skip\n\n    def read_file(\n        self,\n        file_path: PathOrPaths,\n        plugin: str | None = None,\n    ) -&gt; SubWindow[_W]:\n        \"\"\"Read local file(s) and open as a new sub-window.\"\"\"\n        _, tabarea = self._current_or_new_tab()\n        return tabarea.read_file(file_path, plugin=plugin)\n\n    def read_files(self, file_paths: PathOrPaths):\n        \"\"\"Read multiple files one by one and open as new sub-windows in a same tab.\"\"\"\n        _, tabarea = self._current_or_new_tab()\n        return tabarea.read_files(file_paths)\n\n    def read_files_async(self, file_paths: PathOrPaths, plugin: str | None = None):\n        \"\"\"Read multiple files asynchronously and open as new sub-windows.\"\"\"\n        _, tabarea = self._current_or_new_tab()\n        return tabarea.read_files_async(file_paths, plugin=plugin)\n\n    def load_session(self, path: str | Path) -&gt; None:\n        \"\"\"Read a session file and update the main window based on the content.\"\"\"\n        from himena.session import update_from_zip, update_from_directory\n\n        fp = Path(path)\n        if fp.suffix == \".zip\":\n            update_from_zip(self, fp)\n        elif fp.is_dir():\n            update_from_directory(self, fp)\n        else:\n            raise ValueError(f\"Session must be a zip file or a directory, got {fp}.\")\n        # always plugin=None for reading a session file as a session\n        self._recent_session_manager.append_recent_files([(fp, None)])\n        self.set_status_tip(f\"Session loaded: {fp}\", duration=5)\n        return None\n\n    def save_session(\n        self,\n        path: str | Path,\n        *,\n        save_copies: bool = False,\n        allow_calculate: Sequence[str] = (),\n    ) -&gt; None:\n        \"\"\"Save the current session to a zip file as a stand-along file.\"\"\"\n        from himena.session import dump_zip, dump_directory\n\n        path = Path(path)\n        if path.suffix == \".zip\":\n            dump_zip(\n                self, path, save_copies=save_copies, allow_calculate=allow_calculate\n            )\n        else:\n            dump_directory(\n                self, path, save_copies=save_copies, allow_calculate=allow_calculate\n            )\n        self.set_status_tip(f\"Session saved to {path}\")\n        self._recent_session_manager.append_recent_files([(path, None)])\n        return None\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear all widgets in the main window.\"\"\"\n        self.tabs.clear()\n        self.dock_widgets.clear()\n        return None\n\n    def set_status_tip(self, text: str, duration: float = 10.0) -&gt; None:\n        \"\"\"Set the status tip of the main window.\n\n        This method can be safely called from any thread.\n\n        Parameters\n        ----------\n        text : str\n            Text to show in the status bar.\n        duration : float, default 10.0\n            Duration (seconds) to show the status tip.\n        \"\"\"\n        self._backend_main_window._set_status_tip(text, duration)\n        return None\n\n    def show_notification(self, text: str, duration: float = 5.0) -&gt; None:\n        self._backend_main_window._show_notification(text, duration)\n        return None\n\n    @overload\n    def register_function(\n        self,\n        func: None = None,\n        *,\n        menus: str | Sequence[str] = \"plugins\",\n        title: str | None = None,\n        types: str | Sequence[str] | None = None,\n        enablement: BoolOp | None = None,\n        keybindings: Sequence[KeyBindingRule] | None = None,\n        command_id: str | None = None,\n    ) -&gt; None: ...  # noqa: E501\n    @overload\n    def register_function(\n        self,\n        func: _F,\n        *,\n        menus: str | Sequence[str] = \"plugins\",\n        title: str | None = None,\n        types: str | Sequence[str] | None = None,\n        enablement: BoolOp | None = None,\n        keybindings: Sequence[KeyBindingRule] | None = None,\n        command_id: str | None = None,\n    ) -&gt; _F: ...  # noqa: E501\n\n    def register_function(\n        self,\n        func=None,\n        *,\n        menus=\"plugins\",\n        title=None,\n        types=None,\n        enablement=None,\n        keybindings=None,\n        command_id=None,\n    ):\n        \"\"\"\n        Register a function as a callback in runtime.\n\n        Example\n        -------\n        ``` python\n        @ui.register_function(menus=\"plugins\", title=\"Test functions)\n        def test_function():\n            print(\"test\")\n        ```\n\n        Parameters\n        ----------\n        func : callable, optional\n            Function to register as an action.\n        menus : str or sequence of str, default \"plugins\"\n            Menu(s) to add the action. Submenus are separated by `/`.\n        title : str, optional\n            Title of the action. Name of the function will be used if not given.\n        types: str or sequence of str, optional\n            The `type` parameter(s) allowed as the WidgetDataModel. If this parameter\n            is given, action will be grayed out if the active window does not satisfy\n            the listed types.\n        enablement: Expr, optional\n            Expression that describes when the action will be enabled. As this argument\n            is a generalized version of `types` argument, you cannot use both of them.\n        command_id : str, optional\n            Command ID. If not given, the function qualname will be used.\n        \"\"\"\n\n        def _inner(f):\n            action = _actions.make_action_for_function(\n                f,\n                menus=menus,\n                title=title,\n                types=types,\n                enablement=enablement,\n                keybindings=keybindings,\n                command_id=command_id,\n            )\n            _actions.AppActionRegistry.instance().add_action(action)\n            added_menus = _actions.AppActionRegistry.instance().install_to(\n                self.model_app, [action]\n            )\n            self._backend_main_window._rebuild_for_runtime(added_menus)\n            return f\n\n        return _inner(func) if func else _inner\n\n    def exec_action(\n        self,\n        id: str,\n        *,\n        model_context: WidgetDataModel | None = None,\n        window_context: SubWindow | None = None,\n        with_params: dict[str, Any] | None = None,\n        process_model_output: bool = True,\n    ) -&gt; Any:\n        \"\"\"Execute an action by its ID.\n\n        Parameters\n        ----------\n        id : str\n            Action ID.\n        model_context : WidgetDataModel, optional\n            If given, this model will override the application context for the type\n            `WidgetDataModel` before the execution.\n        window_context : SubWindow, optional\n            If given, this window will override the application context for the type\n            `SubWindow` before the execution.\n        with_params : dict, optional\n            Parameters to pass to the parametric action. These parameters will directly\n            be passed to the parametric window created after the action is executed.\n        process_model_output : bool, default True\n            If True, the output result will be processed by the application context. If\n            the command return a `WidgetDataModel` instance, it will be converted to a\n            sub-window.\n        \"\"\"\n        providers: list[tuple[Any, type]] = []\n        if model_context is not None:\n            providers.append((model_context, WidgetDataModel, 1000))\n        if window_context is not None:\n            if isinstance(window_context, SubWindow):\n                _window_context = window_context\n            else:\n                raise TypeError(\n                    f\"`window_context` must be SubWindow or UUID, got {window_context}\"\n                )\n            providers.append((_window_context, SubWindow, 1000))\n        # execute the command under the given context\n        with (\n            self.model_app.injection_store.register(providers=providers),\n            self._execute_in_context(\n                is_gui=with_params is None, process_model_output=process_model_output\n            ),\n        ):\n            result = self.model_app.commands.execute_command(id).result()\n            if with_params is not None:\n                if tab := self.tabs.current():\n                    param_widget = tab[-1]\n                else:  # pragma: no cover\n                    raise RuntimeError(\"Unreachable code.\")\n                if not isinstance(param_widget, ParametricWindow):\n                    if len(with_params) == 0:\n                        if isinstance(result, Future):\n                            return result.result()  # or appropriate handling\n                        return result\n                    raise ValueError(\n                        f\"Parametric widget expected but got {param_widget}.\"\n                    )\n                # run the callback with the given parameters synchronously\n                result = param_widget._callback_with_params(\n                    with_params, force_sync=True\n                )\n        return result\n\n    @overload\n    def exec_choose_one_dialog(\n        self,\n        title: str,\n        message: str,\n        choices: list[tuple[str, _T]],\n        how: Literal[\"buttons\", \"radiobuttons\"] = \"buttons\",\n    ) -&gt; _T | None: ...\n    @overload\n    def exec_choose_one_dialog(\n        self,\n        title: str,\n        message: str,\n        choices: list[str],\n        how: Literal[\"buttons\", \"radiobuttons\"] = \"buttons\",\n    ) -&gt; str | None: ...\n\n    def exec_choose_one_dialog(self, title, message, choices, how=\"buttons\"):\n        \"\"\"Execute a dialog to choose one from the given choices.\n\n        Parameters\n        ----------\n        title : str\n            Window title of the dialog.\n        message : str\n            HTML Message to show in the dialog.\n        choices : list\n            List of choices. Each choice can be a string or a tuple of (text, value).\n            This method will return the selected value.\n        how : str, default \"buttons\"\n            How to show the choices. \"buttons\" for horizontal buttons, \"radiobuttons\"\n            for vertically arranged radio buttons.\n        \"\"\"\n        if res := self._instructions.choose_one_dialog_response:\n            return res()\n        _choices_normed = []\n        for choice in choices:\n            if isinstance(choice, str):\n                _choices_normed.append((choice, choice))\n            else:\n                text, value = choice\n                _choices_normed.append((text, value))\n        return self._backend_main_window._request_choice_dialog(\n            title, message, _choices_normed, how=how\n        )\n\n    @overload\n    def exec_file_dialog(\n        self,\n        mode: Literal[\"r\", \"d\", \"w\"] = \"r\",\n        *,\n        extension_default: str | None = None,\n        allowed_extensions: list[str] | None = None,\n        caption: str | None = None,\n        start_path: str | Path | None = None,\n        group: str | None = None,\n    ) -&gt; Path | None: ...\n    @overload\n    def exec_file_dialog(\n        self,\n        mode: Literal[\"rm\"],\n        *,\n        extension_default: str | None = None,\n        allowed_extensions: list[str] | None = None,\n        caption: str | None = None,\n        start_path: str | Path | None = None,\n        group: str | None = None,\n    ) -&gt; list[Path] | None: ...\n\n    def exec_file_dialog(\n        self,\n        mode: Literal[\"r\", \"d\", \"w\", \"rm\"] = \"r\",\n        *,\n        extension_default=None,\n        allowed_extensions=None,\n        caption=None,\n        start_path=None,\n        group: str | None = None,\n    ):\n        \"\"\"Execute a file dialog to get file path(s).\"\"\"\n        if mode not in {\"r\", \"d\", \"w\", \"rm\"}:\n            raise ValueError(f\"`mode` must be 'r', 'd', 'w' or 'rm', got {mode!r}.\")\n        if res := self._instructions.file_dialog_response:\n            return res()\n        if group is None:\n            group = mode\n\n        if mode == \"w\":\n            if start_path is None:\n                _start_path = self._file_dialog_hist.get_path(group)\n            elif Path(start_path).parent != Path(\".\"):\n                _start_path = Path(start_path)\n            else:  # filename only is given\n                _start_path = self._file_dialog_hist.get_path(group, str(start_path))\n        else:\n            _start_path = Path(start_path or self._file_dialog_hist.get_path(group))\n        result = self._backend_main_window._open_file_dialog(\n            mode,\n            extension_default=extension_default,\n            allowed_extensions=allowed_extensions,\n            caption=caption,\n            start_path=_start_path,\n        )\n        if result is None:\n            return None\n        if mode in [\"r\", \"w\", \"d\"]:\n            self._file_dialog_hist.update(group, result.parent)\n        elif result:\n            self._file_dialog_hist.update(group, result[0].parent)\n        return result\n\n    def show(self, run: bool = False) -&gt; None:\n        \"\"\"\n        Show the main window.\n\n        Parameters\n        ----------\n        run : bool, default False\n            If True, run the application event loop.\n        \"\"\"\n        self._backend_main_window.show(run)\n        return None\n\n    def close(self) -&gt; None:\n        \"\"\"Close the main window.\"\"\"\n        self._backend_main_window._exit_main_window(confirm=False)\n        remove_instance(self.model_app.name, self)\n        return None\n\n    @property\n    def current_window(self) -&gt; SubWindow[_W] | None:\n        \"\"\"Get the current sub-window.\"\"\"\n        idx_tab = self._backend_main_window._current_tab_index()\n        if idx_tab is None:\n            return None\n        idx_win = self._backend_main_window._current_sub_window_index(idx_tab)\n        if idx_win is None:\n            return None\n        return self.tabs[idx_tab][idx_win]\n\n    @current_window.setter\n    def current_window(self, win: SubWindow[_W] | None) -&gt; None:\n        \"\"\"Set the current sub-window.\"\"\"\n        _main = self._backend_main_window\n        if win is None:\n            _main._set_current_tab_index(None)\n            i_tab = _main._current_tab_index()\n            if i_tab is not None:\n                _main._set_current_sub_window_index(i_tab, None)\n        else:\n            for i_tab, tab in self.tabs.enumerate():\n                for i_win, sub in tab.enumerate():\n                    if sub is win:\n                        _main._set_current_tab_index(i_tab)\n                        _main._set_current_sub_window_index(i_tab, i_win)\n                        return None\n        return None\n\n    @property\n    def current_model(self) -&gt; WidgetDataModel | None:\n        \"\"\"Get the current model of the active sub-window.\"\"\"\n        if sub := self.current_window:\n            return sub.to_model()\n        return None\n\n    def iter_windows(self) -&gt; Iterator[SubWindow[_W]]:\n        \"\"\"Iterate over all the sub-windows in this main window.\"\"\"\n        for tab in self.tabs:\n            yield from tab\n\n    def _provide_file_output(self) -&gt; tuple[WidgetDataModel, SubWindow[_W]]:\n        if sub := self.current_window:\n            model = sub.to_model()\n            return model, sub\n        else:\n            raise ValueError(\"No active window.\")\n\n    def _tab_activated(self, i: int):\n        if i &lt; 0:\n            return None\n        tab = self.tabs.get(i)\n        if tab is not None:\n            self.events.tab_activated.emit(tab)\n            self._main_window_resized(self.area_size)  # update layout and anchor\n        if self._history_tab.get_from_last(1) != i:\n            self._history_tab.add(i)\n        return None\n\n    def move_window(self, sub: SubWindow[_W], target_index: int) -&gt; None:\n        \"\"\"Move the sub-window to the target tab index.\"\"\"\n        i_tab = i_win = None\n        for _i_tab, tab in self.tabs.enumerate():\n            for _i_win, win in tab.enumerate():\n                if win is sub:\n                    i_tab = _i_tab\n                    i_win = _i_win\n                    break\n\n        if i_tab is None or i_win is None or target_index == i_tab:\n            return None\n        title = self.tabs[i_tab][i_win].title\n        old_rect = self.tabs[i_tab][i_win].rect\n        win, widget = self.tabs[i_tab]._pop_no_emit(i_win)\n        if target_index &lt; 0:\n            self.add_tab()\n        self.tabs[target_index].append(win, title)\n        win.rect = old_rect\n        if layout := win._parent_layout_ref():\n            layout.remove(win)\n        self.tabs.current_index = i_tab\n        return None\n\n    def _window_activated(self):\n        back = self._backend_main_window\n        back._update_context()\n        i_tab = back._current_tab_index()\n        if i_tab is None:\n            return back._update_control_widget(None)\n        tab = self.tabs.get(i_tab)\n        if tab is None or len(tab) == 0:\n            return back._update_control_widget(None)\n        i_win = back._current_sub_window_index(i_tab)\n        if i_win is None or len(tab) &lt;= i_win:\n            return back._update_control_widget(None)\n        win = tab[i_win]\n        back._update_control_widget(win.widget)\n        _checker.call_widget_activated_callback(win.widget)\n        self.events.window_activated.emit(win)\n        return None\n\n    def _main_window_resized(self, size: Size):\n        if tab := self.tabs.current():\n            for layout in tab.layouts:\n                layout.anchor = layout.anchor.update_for_window_rect(size, layout.rect)\n                layout._reanchor(size)\n            for win in tab:\n                win.anchor = win.anchor.update_for_window_rect(size, win.rect)\n                win._reanchor(size)\n\n    @contextmanager\n    def _execute_in_context(\n        self,\n        is_gui: bool = False,\n        process_model_output: bool = True,\n        unwrap_future: bool = True,\n    ):\n        with self._global_lock:\n            old_inst = self._instructions.model_copy()\n            self._instructions = self._instructions.updated(\n                gui_execution=is_gui,\n                process_model_output=process_model_output,\n                unwrap_future=unwrap_future,\n            )\n            try:\n                yield None\n            finally:\n                self._instructions = old_inst\n\n    def _iter_widget_class(self, model: WidgetDataModel) -&gt; Iterator[type[_W]]:\n        \"\"\"Pick the most suitable widget class for the given model.\"\"\"\n        if model.force_open_with:\n            yield import_object(model.force_open_with)\n            return\n        widget_classes, fallback_class = self._backend_main_window._list_widget_class(\n            model.type\n        )\n        if not widget_classes:\n            warnings.warn(\n                f\"No widget class is registered for model type {model.type!r}.\",\n                RuntimeWarning,\n                stacklevel=2,\n            )\n            yield fallback_class\n            return\n        complete_match = [\n            (tup.priority, tup.widget_class)\n            for tup in widget_classes\n            if tup.type == model.type and tup.priority &gt;= 0\n        ]\n        if complete_match:\n            yield from _iter_sorted(complete_match)\n        subtype_match = [\n            ((tup.type.count(\".\"), tup.priority), tup.widget_class)\n            for tup in widget_classes\n            if tup.priority &gt;= 0\n        ]\n        yield from _iter_sorted(subtype_match)\n\n    def _pick_widget(self, model: WidgetDataModel) -&gt; _W:\n        \"\"\"Pick the most suitable widget for the given model.\"\"\"\n        exceptions: list[tuple[Any, Exception]] = []\n        for factory in self._iter_widget_class(model):\n            try:\n                try:\n                    widget = factory(self)\n                except TypeError:\n                    widget = factory()\n                widget_id = get_widget_class_id(type(widget))\n                reg = _actions.AppActionRegistry.instance()\n                if self.model_app.name != \".\" and (\n                    plugin_configs := self.app_profile.plugin_configs.get(widget_id)\n                ):\n                    params = {}\n                    for k, v in plugin_configs.items():\n                        params[k] = v[\"value\"]\n                    cfgs = reg._plugin_default_configs\n                    cfg_type = cfgs[widget_id].config_class\n                    # widget should always have `update_configs` in this case\n                    widget.update_configs(cfg_type(**params))\n                widget.update_model(model)\n            except Exception as e:\n                exceptions.append((factory, e))\n            else:\n                break\n        else:\n            raise ValueError(\n                f\"Failed to create a widget for {model}. Errors:\\n\"\n                f\"{_format_exceptions(exceptions)}\"\n            ) from exceptions[-1][1]\n        if exceptions:\n            raise exceptions[-1][1]\n\n        return widget\n\n    def _on_command_execution(self, id: str, result: Future):\n        if exc := result.exception():\n            _LOGGER.exception(\"Command %r failed: %r\", id, exc)\n            return\n        if action := self.model_app._registered_actions.get(id):\n            if getattr(action.callback, NO_RECORDING_FIELD, False):\n                return None\n            self._history_command.add(id)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.app_profile","title":"<code>app_profile</code>  <code>property</code>","text":"<p>Get the current application profile object.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.area_size","title":"<code>area_size</code>  <code>property</code>","text":"<p>(width, height) of the main window tab area.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.clipboard","title":"<code>clipboard</code>  <code>property</code> <code>writable</code>","text":"<p>Get the clipboard data as a ClipboardDataModel instance.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.current_model","title":"<code>current_model</code>  <code>property</code>","text":"<p>Get the current model of the active sub-window.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.current_window","title":"<code>current_window</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current sub-window.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.dock_widgets","title":"<code>dock_widgets</code>  <code>property</code>","text":"<p>Dock widget list object.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.events","title":"<code>events</code>  <code>property</code>","text":"<p>Main window events.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.model_app","title":"<code>model_app</code>  <code>property</code>","text":"<p>The app-model application instance.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.object_type_map","title":"<code>object_type_map</code>  <code>property</code>","text":"<p>Mapping object to string that describes the type.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.rect","title":"<code>rect</code>  <code>property</code> <code>writable</code>","text":"<p>Window rect (left, top, width, height) of the main window.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.size","title":"<code>size</code>  <code>property</code> <code>writable</code>","text":"<p>Size (width, height) of the main window.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.tabs","title":"<code>tabs</code>  <code>property</code>","text":"<p>Tab list object.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow.theme","title":"<code>theme</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current color theme of the main window.</p>"},{"location":"api/widgets/#himena.widgets.MainWindow._iter_widget_class","title":"<code>_iter_widget_class(model)</code>","text":"<p>Pick the most suitable widget class for the given model.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def _iter_widget_class(self, model: WidgetDataModel) -&gt; Iterator[type[_W]]:\n    \"\"\"Pick the most suitable widget class for the given model.\"\"\"\n    if model.force_open_with:\n        yield import_object(model.force_open_with)\n        return\n    widget_classes, fallback_class = self._backend_main_window._list_widget_class(\n        model.type\n    )\n    if not widget_classes:\n        warnings.warn(\n            f\"No widget class is registered for model type {model.type!r}.\",\n            RuntimeWarning,\n            stacklevel=2,\n        )\n        yield fallback_class\n        return\n    complete_match = [\n        (tup.priority, tup.widget_class)\n        for tup in widget_classes\n        if tup.type == model.type and tup.priority &gt;= 0\n    ]\n    if complete_match:\n        yield from _iter_sorted(complete_match)\n    subtype_match = [\n        ((tup.type.count(\".\"), tup.priority), tup.widget_class)\n        for tup in widget_classes\n        if tup.priority &gt;= 0\n    ]\n    yield from _iter_sorted(subtype_match)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow._pick_widget","title":"<code>_pick_widget(model)</code>","text":"<p>Pick the most suitable widget for the given model.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def _pick_widget(self, model: WidgetDataModel) -&gt; _W:\n    \"\"\"Pick the most suitable widget for the given model.\"\"\"\n    exceptions: list[tuple[Any, Exception]] = []\n    for factory in self._iter_widget_class(model):\n        try:\n            try:\n                widget = factory(self)\n            except TypeError:\n                widget = factory()\n            widget_id = get_widget_class_id(type(widget))\n            reg = _actions.AppActionRegistry.instance()\n            if self.model_app.name != \".\" and (\n                plugin_configs := self.app_profile.plugin_configs.get(widget_id)\n            ):\n                params = {}\n                for k, v in plugin_configs.items():\n                    params[k] = v[\"value\"]\n                cfgs = reg._plugin_default_configs\n                cfg_type = cfgs[widget_id].config_class\n                # widget should always have `update_configs` in this case\n                widget.update_configs(cfg_type(**params))\n            widget.update_model(model)\n        except Exception as e:\n            exceptions.append((factory, e))\n        else:\n            break\n    else:\n        raise ValueError(\n            f\"Failed to create a widget for {model}. Errors:\\n\"\n            f\"{_format_exceptions(exceptions)}\"\n        ) from exceptions[-1][1]\n    if exceptions:\n        raise exceptions[-1][1]\n\n    return widget\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.add_data_model","title":"<code>add_data_model(model_data)</code>","text":"<p>Add a widget data model as a widget.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def add_data_model(self, model_data: WidgetDataModel) -&gt; SubWindow[_W]:\n    \"\"\"Add a widget data model as a widget.\"\"\"\n    _, tabarea = self._current_or_new_tab()\n    return tabarea.add_data_model(model_data)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.add_dock_widget","title":"<code>add_dock_widget(widget, *, title=None, area=DockArea.RIGHT, allowed_areas=None, _identifier=None)</code>","text":"<p>Add a custom widget as a dock widget of the main window.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>Widget type</code> <p>Widget instance that is allowed for the backend.</p> required <code>title</code> <code>str</code> <p>Title of the dock widget.</p> <code>None</code> <code>area</code> <code>dock area</code> <p>String or DockArea enum that describes where the dock widget initially appears.</p> <code>DockArea.RIGHT</code> <code>allowed_areas</code> <code>list of dock area</code> <p>List of allowed dock areas for the widget.</p> <code>None</code> <p>Returns:</p> Type Description <code>DockWidget</code> <p>The dock widget handler.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def add_dock_widget(\n    self,\n    widget: _W,\n    *,\n    title: str | None = None,\n    area: DockAreaString | DockArea | None = DockArea.RIGHT,\n    allowed_areas: list[DockAreaString | DockArea] | None = None,\n    _identifier: uuid.UUID | None = None,\n) -&gt; DockWidget[_W]:\n    \"\"\"Add a custom widget as a dock widget of the main window.\n\n    Parameters\n    ----------\n    widget : Widget type\n        Widget instance that is allowed for the backend.\n    title : str, optional\n        Title of the dock widget.\n    area : dock area, default DockArea.RIGHT\n        String or DockArea enum that describes where the dock widget initially\n        appears.\n    allowed_areas : list of dock area, optional\n        List of allowed dock areas for the widget.\n\n    Returns\n    -------\n    DockWidget\n        The dock widget handler.\n    \"\"\"\n    dock = DockWidget(widget, self._backend_main_window, identifier=_identifier)\n    dock_native = dock._split_interface_and_frontend()[1]\n    self._backend_main_window.add_dock_widget(\n        dock_native, title=title, area=area, allowed_areas=allowed_areas\n    )\n    self._dock_widget_list._add_dock_widget(dock)\n    _checker.call_widget_added_callback(widget)\n    _checker.call_theme_changed_callback(widget, self.theme)\n    return dock\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.add_function","title":"<code>add_function(func, *, preview=False, title=None, show_parameter_labels=True, auto_close=True, run_async=False, result_as='window')</code>","text":"<p>Add a function as a parametric sub-window.</p> <p>The input function must return a <code>WidgetDataModel</code> instance, which can be interpreted by the application.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>function (...) -&gt; WidgetDataModel</code> <p>Function that generates a model from the input parameters.</p> required <code>title</code> <code>str</code> <p>Title of the sub-window.</p> <code>None</code> <p>Returns:</p> Type Description <code>SubWindow</code> <p>The sub-window instance that represents the output model.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def add_function(\n    self,\n    func: Callable[..., _T],\n    *,\n    preview: bool = False,\n    title: str | None = None,\n    show_parameter_labels: bool = True,\n    auto_close: bool = True,\n    run_async: bool = False,\n    result_as: Literal[\"window\", \"below\", \"right\"] = \"window\",\n) -&gt; ParametricWindow[_W]:\n    \"\"\"Add a function as a parametric sub-window.\n\n    The input function must return a `WidgetDataModel` instance, which can be\n    interpreted by the application.\n\n    Parameters\n    ----------\n    func : function (...) -&gt; WidgetDataModel\n        Function that generates a model from the input parameters.\n    title : str, optional\n        Title of the sub-window.\n\n    Returns\n    -------\n    SubWindow\n        The sub-window instance that represents the output model.\n    \"\"\"\n    _, tabarea = self._current_or_new_tab()\n    return tabarea.add_function(\n        func, title=title, preview=preview, result_as=result_as,\n        show_parameter_labels=show_parameter_labels, auto_close=auto_close,\n        run_async=run_async,\n    )  # fmt: skip\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.add_object","title":"<code>add_object(value, *, type=None, title=None, force_open_with=None, metadata=None)</code>","text":"<p>Add any data as a widget data model.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Any object. Whether it can be represented as a widget is dependent on the plugins that are installed.</p> required <code>type</code> <code>str</code> <p>Any str that describes the type of the object. This type must be registered with a proper widget class.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title of the sub-window.</p> <code>None</code> <p>Returns:</p> Type Description <code>SubWindow</code> <p>The sub-window handler.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def add_object(\n    self,\n    value: Any,\n    *,\n    type: str | None = None,\n    title: str | None = None,\n    force_open_with: str | None = None,\n    metadata: Any | None = None,\n) -&gt; SubWindow[_W]:\n    \"\"\"Add any data as a widget data model.\n\n    Parameters\n    ----------\n    value : Any\n        Any object. Whether it can be represented as a widget is dependent on the\n        plugins that are installed.\n    type : str, optional\n        Any str that describes the type of the object. This type must be registered\n        with a proper widget class.\n    title : str, optional\n        Title of the sub-window.\n\n    Returns\n    -------\n    SubWindow\n        The sub-window handler.\n    \"\"\"\n    if type is None:\n        type = self._object_type_map.pick_type(value)\n    wd = WidgetDataModel(\n        value=value,\n        type=type,\n        title=title,\n        force_open_with=force_open_with,\n        metadata=metadata,\n        workflow=ProgrammaticMethod(output_model_type=type).construct_workflow(),\n    )\n    return self.add_data_model(wd)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.add_tab","title":"<code>add_tab(title=None)</code>","text":"<p>Add a new tab of given name.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def add_tab(self, title: str | None = None) -&gt; TabArea[_W]:\n    \"\"\"Add a new tab of given name.\"\"\"\n    return self.tabs.add(title)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.add_widget","title":"<code>add_widget(widget, *, title=None)</code>","text":"<p>Add a widget to the sub window.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>QWidget</code> <p>Widget to add.</p> required <code>title</code> <code>str</code> <p>Title of the sub-window. If not given, its name will be automatically generated.</p> <code>None</code> <p>Returns:</p> Type Description <code>SubWindow</code> <p>The sub-window handler.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def add_widget(\n    self,\n    widget: _W,\n    *,\n    title: str | None = None,\n) -&gt; SubWindow[_W]:\n    \"\"\"Add a widget to the sub window.\n\n    Parameters\n    ----------\n    widget : QtW.QWidget\n        Widget to add.\n    title : str, optional\n        Title of the sub-window. If not given, its name will be automatically\n        generated.\n\n    Returns\n    -------\n    SubWindow\n        The sub-window handler.\n    \"\"\"\n    _, tabarea = self._current_or_new_tab()\n    return tabarea.add_widget(widget, title=title)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.clear","title":"<code>clear()</code>","text":"<p>Clear all widgets in the main window.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear all widgets in the main window.\"\"\"\n    self.tabs.clear()\n    self.dock_widgets.clear()\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.close","title":"<code>close()</code>","text":"<p>Close the main window.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the main window.\"\"\"\n    self._backend_main_window._exit_main_window(confirm=False)\n    remove_instance(self.model_app.name, self)\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.exec_action","title":"<code>exec_action(id, *, model_context=None, window_context=None, with_params=None, process_model_output=True)</code>","text":"<p>Execute an action by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Action ID.</p> required <code>model_context</code> <code>WidgetDataModel</code> <p>If given, this model will override the application context for the type <code>WidgetDataModel</code> before the execution.</p> <code>None</code> <code>window_context</code> <code>SubWindow</code> <p>If given, this window will override the application context for the type <code>SubWindow</code> before the execution.</p> <code>None</code> <code>with_params</code> <code>dict</code> <p>Parameters to pass to the parametric action. These parameters will directly be passed to the parametric window created after the action is executed.</p> <code>None</code> <code>process_model_output</code> <code>bool</code> <p>If True, the output result will be processed by the application context. If the command return a <code>WidgetDataModel</code> instance, it will be converted to a sub-window.</p> <code>True</code> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def exec_action(\n    self,\n    id: str,\n    *,\n    model_context: WidgetDataModel | None = None,\n    window_context: SubWindow | None = None,\n    with_params: dict[str, Any] | None = None,\n    process_model_output: bool = True,\n) -&gt; Any:\n    \"\"\"Execute an action by its ID.\n\n    Parameters\n    ----------\n    id : str\n        Action ID.\n    model_context : WidgetDataModel, optional\n        If given, this model will override the application context for the type\n        `WidgetDataModel` before the execution.\n    window_context : SubWindow, optional\n        If given, this window will override the application context for the type\n        `SubWindow` before the execution.\n    with_params : dict, optional\n        Parameters to pass to the parametric action. These parameters will directly\n        be passed to the parametric window created after the action is executed.\n    process_model_output : bool, default True\n        If True, the output result will be processed by the application context. If\n        the command return a `WidgetDataModel` instance, it will be converted to a\n        sub-window.\n    \"\"\"\n    providers: list[tuple[Any, type]] = []\n    if model_context is not None:\n        providers.append((model_context, WidgetDataModel, 1000))\n    if window_context is not None:\n        if isinstance(window_context, SubWindow):\n            _window_context = window_context\n        else:\n            raise TypeError(\n                f\"`window_context` must be SubWindow or UUID, got {window_context}\"\n            )\n        providers.append((_window_context, SubWindow, 1000))\n    # execute the command under the given context\n    with (\n        self.model_app.injection_store.register(providers=providers),\n        self._execute_in_context(\n            is_gui=with_params is None, process_model_output=process_model_output\n        ),\n    ):\n        result = self.model_app.commands.execute_command(id).result()\n        if with_params is not None:\n            if tab := self.tabs.current():\n                param_widget = tab[-1]\n            else:  # pragma: no cover\n                raise RuntimeError(\"Unreachable code.\")\n            if not isinstance(param_widget, ParametricWindow):\n                if len(with_params) == 0:\n                    if isinstance(result, Future):\n                        return result.result()  # or appropriate handling\n                    return result\n                raise ValueError(\n                    f\"Parametric widget expected but got {param_widget}.\"\n                )\n            # run the callback with the given parameters synchronously\n            result = param_widget._callback_with_params(\n                with_params, force_sync=True\n            )\n    return result\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.exec_choose_one_dialog","title":"<code>exec_choose_one_dialog(title, message, choices, how='buttons')</code>","text":"<pre><code>exec_choose_one_dialog(title: str, message: str, choices: list[tuple[str, _T]], how: Literal['buttons', 'radiobuttons'] = 'buttons') -&gt; _T | None\n</code></pre><pre><code>exec_choose_one_dialog(title: str, message: str, choices: list[str], how: Literal['buttons', 'radiobuttons'] = 'buttons') -&gt; str | None\n</code></pre> <p>Execute a dialog to choose one from the given choices.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Window title of the dialog.</p> required <code>message</code> <code>str</code> <p>HTML Message to show in the dialog.</p> required <code>choices</code> <code>list</code> <p>List of choices. Each choice can be a string or a tuple of (text, value). This method will return the selected value.</p> required <code>how</code> <code>str</code> <p>How to show the choices. \"buttons\" for horizontal buttons, \"radiobuttons\" for vertically arranged radio buttons.</p> <code>\"buttons\"</code> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def exec_choose_one_dialog(self, title, message, choices, how=\"buttons\"):\n    \"\"\"Execute a dialog to choose one from the given choices.\n\n    Parameters\n    ----------\n    title : str\n        Window title of the dialog.\n    message : str\n        HTML Message to show in the dialog.\n    choices : list\n        List of choices. Each choice can be a string or a tuple of (text, value).\n        This method will return the selected value.\n    how : str, default \"buttons\"\n        How to show the choices. \"buttons\" for horizontal buttons, \"radiobuttons\"\n        for vertically arranged radio buttons.\n    \"\"\"\n    if res := self._instructions.choose_one_dialog_response:\n        return res()\n    _choices_normed = []\n    for choice in choices:\n        if isinstance(choice, str):\n            _choices_normed.append((choice, choice))\n        else:\n            text, value = choice\n            _choices_normed.append((text, value))\n    return self._backend_main_window._request_choice_dialog(\n        title, message, _choices_normed, how=how\n    )\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.exec_file_dialog","title":"<code>exec_file_dialog(mode='r', *, extension_default=None, allowed_extensions=None, caption=None, start_path=None, group=None)</code>","text":"<pre><code>exec_file_dialog(mode: Literal['r', 'd', 'w'] = 'r', *, extension_default: str | None = None, allowed_extensions: list[str] | None = None, caption: str | None = None, start_path: str | Path | None = None, group: str | None = None) -&gt; Path | None\n</code></pre><pre><code>exec_file_dialog(mode: Literal['rm'], *, extension_default: str | None = None, allowed_extensions: list[str] | None = None, caption: str | None = None, start_path: str | Path | None = None, group: str | None = None) -&gt; list[Path] | None\n</code></pre> <p>Execute a file dialog to get file path(s).</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def exec_file_dialog(\n    self,\n    mode: Literal[\"r\", \"d\", \"w\", \"rm\"] = \"r\",\n    *,\n    extension_default=None,\n    allowed_extensions=None,\n    caption=None,\n    start_path=None,\n    group: str | None = None,\n):\n    \"\"\"Execute a file dialog to get file path(s).\"\"\"\n    if mode not in {\"r\", \"d\", \"w\", \"rm\"}:\n        raise ValueError(f\"`mode` must be 'r', 'd', 'w' or 'rm', got {mode!r}.\")\n    if res := self._instructions.file_dialog_response:\n        return res()\n    if group is None:\n        group = mode\n\n    if mode == \"w\":\n        if start_path is None:\n            _start_path = self._file_dialog_hist.get_path(group)\n        elif Path(start_path).parent != Path(\".\"):\n            _start_path = Path(start_path)\n        else:  # filename only is given\n            _start_path = self._file_dialog_hist.get_path(group, str(start_path))\n    else:\n        _start_path = Path(start_path or self._file_dialog_hist.get_path(group))\n    result = self._backend_main_window._open_file_dialog(\n        mode,\n        extension_default=extension_default,\n        allowed_extensions=allowed_extensions,\n        caption=caption,\n        start_path=_start_path,\n    )\n    if result is None:\n        return None\n    if mode in [\"r\", \"w\", \"d\"]:\n        self._file_dialog_hist.update(group, result.parent)\n    elif result:\n        self._file_dialog_hist.update(group, result[0].parent)\n    return result\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.iter_windows","title":"<code>iter_windows()</code>","text":"<p>Iterate over all the sub-windows in this main window.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def iter_windows(self) -&gt; Iterator[SubWindow[_W]]:\n    \"\"\"Iterate over all the sub-windows in this main window.\"\"\"\n    for tab in self.tabs:\n        yield from tab\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.load_session","title":"<code>load_session(path)</code>","text":"<p>Read a session file and update the main window based on the content.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def load_session(self, path: str | Path) -&gt; None:\n    \"\"\"Read a session file and update the main window based on the content.\"\"\"\n    from himena.session import update_from_zip, update_from_directory\n\n    fp = Path(path)\n    if fp.suffix == \".zip\":\n        update_from_zip(self, fp)\n    elif fp.is_dir():\n        update_from_directory(self, fp)\n    else:\n        raise ValueError(f\"Session must be a zip file or a directory, got {fp}.\")\n    # always plugin=None for reading a session file as a session\n    self._recent_session_manager.append_recent_files([(fp, None)])\n    self.set_status_tip(f\"Session loaded: {fp}\", duration=5)\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.move_window","title":"<code>move_window(sub, target_index)</code>","text":"<p>Move the sub-window to the target tab index.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def move_window(self, sub: SubWindow[_W], target_index: int) -&gt; None:\n    \"\"\"Move the sub-window to the target tab index.\"\"\"\n    i_tab = i_win = None\n    for _i_tab, tab in self.tabs.enumerate():\n        for _i_win, win in tab.enumerate():\n            if win is sub:\n                i_tab = _i_tab\n                i_win = _i_win\n                break\n\n    if i_tab is None or i_win is None or target_index == i_tab:\n        return None\n    title = self.tabs[i_tab][i_win].title\n    old_rect = self.tabs[i_tab][i_win].rect\n    win, widget = self.tabs[i_tab]._pop_no_emit(i_win)\n    if target_index &lt; 0:\n        self.add_tab()\n    self.tabs[target_index].append(win, title)\n    win.rect = old_rect\n    if layout := win._parent_layout_ref():\n        layout.remove(win)\n    self.tabs.current_index = i_tab\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.read_file","title":"<code>read_file(file_path, plugin=None)</code>","text":"<p>Read local file(s) and open as a new sub-window.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def read_file(\n    self,\n    file_path: PathOrPaths,\n    plugin: str | None = None,\n) -&gt; SubWindow[_W]:\n    \"\"\"Read local file(s) and open as a new sub-window.\"\"\"\n    _, tabarea = self._current_or_new_tab()\n    return tabarea.read_file(file_path, plugin=plugin)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.read_files","title":"<code>read_files(file_paths)</code>","text":"<p>Read multiple files one by one and open as new sub-windows in a same tab.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def read_files(self, file_paths: PathOrPaths):\n    \"\"\"Read multiple files one by one and open as new sub-windows in a same tab.\"\"\"\n    _, tabarea = self._current_or_new_tab()\n    return tabarea.read_files(file_paths)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.read_files_async","title":"<code>read_files_async(file_paths, plugin=None)</code>","text":"<p>Read multiple files asynchronously and open as new sub-windows.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def read_files_async(self, file_paths: PathOrPaths, plugin: str | None = None):\n    \"\"\"Read multiple files asynchronously and open as new sub-windows.\"\"\"\n    _, tabarea = self._current_or_new_tab()\n    return tabarea.read_files_async(file_paths, plugin=plugin)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.register_function","title":"<code>register_function(func=None, *, menus='plugins', title=None, types=None, enablement=None, keybindings=None, command_id=None)</code>","text":"<pre><code>register_function(func: None = None, *, menus: str | Sequence[str] = 'plugins', title: str | None = None, types: str | Sequence[str] | None = None, enablement: BoolOp | None = None, keybindings: Sequence[KeyBindingRule] | None = None, command_id: str | None = None) -&gt; None\n</code></pre><pre><code>register_function(func: _F, *, menus: str | Sequence[str] = 'plugins', title: str | None = None, types: str | Sequence[str] | None = None, enablement: BoolOp | None = None, keybindings: Sequence[KeyBindingRule] | None = None, command_id: str | None = None) -&gt; _F\n</code></pre> <p>Register a function as a callback in runtime.</p> Example <pre><code>@ui.register_function(menus=\"plugins\", title=\"Test functions)\ndef test_function():\n    print(\"test\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>Function to register as an action.</p> <code>None</code> <code>menus</code> <code>str or sequence of str</code> <p>Menu(s) to add the action. Submenus are separated by <code>/</code>.</p> <code>\"plugins\"</code> <code>title</code> <code>str</code> <p>Title of the action. Name of the function will be used if not given.</p> <code>None</code> <code>types</code> <p>The <code>type</code> parameter(s) allowed as the WidgetDataModel. If this parameter is given, action will be grayed out if the active window does not satisfy the listed types.</p> <code>None</code> <code>enablement</code> <p>Expression that describes when the action will be enabled. As this argument is a generalized version of <code>types</code> argument, you cannot use both of them.</p> <code>None</code> <code>command_id</code> <code>str</code> <p>Command ID. If not given, the function qualname will be used.</p> <code>None</code> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def register_function(\n    self,\n    func=None,\n    *,\n    menus=\"plugins\",\n    title=None,\n    types=None,\n    enablement=None,\n    keybindings=None,\n    command_id=None,\n):\n    \"\"\"\n    Register a function as a callback in runtime.\n\n    Example\n    -------\n    ``` python\n    @ui.register_function(menus=\"plugins\", title=\"Test functions)\n    def test_function():\n        print(\"test\")\n    ```\n\n    Parameters\n    ----------\n    func : callable, optional\n        Function to register as an action.\n    menus : str or sequence of str, default \"plugins\"\n        Menu(s) to add the action. Submenus are separated by `/`.\n    title : str, optional\n        Title of the action. Name of the function will be used if not given.\n    types: str or sequence of str, optional\n        The `type` parameter(s) allowed as the WidgetDataModel. If this parameter\n        is given, action will be grayed out if the active window does not satisfy\n        the listed types.\n    enablement: Expr, optional\n        Expression that describes when the action will be enabled. As this argument\n        is a generalized version of `types` argument, you cannot use both of them.\n    command_id : str, optional\n        Command ID. If not given, the function qualname will be used.\n    \"\"\"\n\n    def _inner(f):\n        action = _actions.make_action_for_function(\n            f,\n            menus=menus,\n            title=title,\n            types=types,\n            enablement=enablement,\n            keybindings=keybindings,\n            command_id=command_id,\n        )\n        _actions.AppActionRegistry.instance().add_action(action)\n        added_menus = _actions.AppActionRegistry.instance().install_to(\n            self.model_app, [action]\n        )\n        self._backend_main_window._rebuild_for_runtime(added_menus)\n        return f\n\n    return _inner(func) if func else _inner\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.save_session","title":"<code>save_session(path, *, save_copies=False, allow_calculate=())</code>","text":"<p>Save the current session to a zip file as a stand-along file.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def save_session(\n    self,\n    path: str | Path,\n    *,\n    save_copies: bool = False,\n    allow_calculate: Sequence[str] = (),\n) -&gt; None:\n    \"\"\"Save the current session to a zip file as a stand-along file.\"\"\"\n    from himena.session import dump_zip, dump_directory\n\n    path = Path(path)\n    if path.suffix == \".zip\":\n        dump_zip(\n            self, path, save_copies=save_copies, allow_calculate=allow_calculate\n        )\n    else:\n        dump_directory(\n            self, path, save_copies=save_copies, allow_calculate=allow_calculate\n        )\n    self.set_status_tip(f\"Session saved to {path}\")\n    self._recent_session_manager.append_recent_files([(path, None)])\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.set_status_tip","title":"<code>set_status_tip(text, duration=10.0)</code>","text":"<p>Set the status tip of the main window.</p> <p>This method can be safely called from any thread.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to show in the status bar.</p> required <code>duration</code> <code>float</code> <p>Duration (seconds) to show the status tip.</p> <code>10.0</code> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def set_status_tip(self, text: str, duration: float = 10.0) -&gt; None:\n    \"\"\"Set the status tip of the main window.\n\n    This method can be safely called from any thread.\n\n    Parameters\n    ----------\n    text : str\n        Text to show in the status bar.\n    duration : float, default 10.0\n        Duration (seconds) to show the status tip.\n    \"\"\"\n    self._backend_main_window._set_status_tip(text, duration)\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.show","title":"<code>show(run=False)</code>","text":"<p>Show the main window.</p> <p>Parameters:</p> Name Type Description Default <code>run</code> <code>bool</code> <p>If True, run the application event loop.</p> <code>False</code> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def show(self, run: bool = False) -&gt; None:\n    \"\"\"\n    Show the main window.\n\n    Parameters\n    ----------\n    run : bool, default False\n        If True, run the application event loop.\n    \"\"\"\n    self._backend_main_window.show(run)\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.submit_async_task","title":"<code>submit_async_task(func, *args, progress_description=None, **kwargs)</code>","text":"<p>Submit a task to the thread pool.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def submit_async_task(\n    self,\n    func: Callable,\n    *args,\n    progress_description: str | None = None,\n    **kwargs,\n) -&gt; Future:\n    \"\"\"Submit a task to the thread pool.\"\"\"\n    future = self._executor.submit(func, *args, **kwargs)\n    if progress_description is None:\n        progress_description = f\"Running {func!r}\"\n    self._backend_main_window._add_job_progress(\n        future, desc=progress_description, total=0\n    )\n    self.model_app.injection_store.process(future)\n    return future\n</code></pre>"},{"location":"api/widgets/#himena.widgets.MainWindow.window_for_id","title":"<code>window_for_id(identifier)</code>","text":"<p>Retrieve a sub-window by its identifier.</p> Source code in <code>src\\himena\\widgets\\_main_window.py</code> <pre><code>def window_for_id(self, identifier: uuid.UUID) -&gt; SubWindow[_W] | None:\n    \"\"\"Retrieve a sub-window by its identifier.\"\"\"\n    if not isinstance(identifier, uuid.UUID):\n        raise ValueError(f\"Expected UUID, got {identifier!r}.\")\n    for win in self.iter_windows():\n        if win._identifier == identifier:\n            return win\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.ParametricWindow","title":"<code>ParametricWindow</code>","text":"<p>Subwindow with a parametric widget inside.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>class ParametricWindow(SubWindow[_W]):\n    \"\"\"Subwindow with a parametric widget inside.\"\"\"\n\n    _IS_PREVIEWING = \"is_previewing\"  # keyword argument used for preview flag\n    btn_clicked = Signal(object)  # emit self\n    params_changed = Signal(object)  # emit self\n\n    def __init__(\n        self,\n        widget: _W,\n        callback: Callable,\n        main_window: BackendMainWindow[_W],\n        identifier: uuid.UUID | None = None,\n    ):\n        super().__init__(widget, main_window, identifier)\n        self._callback = callback\n        self.btn_clicked.connect(self._widget_callback)\n        self._preview_window_ref: Callable[[], WidgetWrapper[_W] | None] = _do_nothing\n        self._auto_close = True\n        self._run_asynchronously = False\n        self._last_future: Future | None = None\n        self._result_as: Literal[\"window\", \"below\", \"right\"] = \"window\"\n\n        # check if callback has \"is_previewing\" argument\n        sig = inspect.signature(callback)\n        self._has_is_previewing = self._IS_PREVIEWING in sig.parameters\n        self._fn_signature = sig\n\n    def get_params(self) -&gt; dict[str, Any]:\n        \"\"\"Get the parameters of the widget.\"\"\"\n        if hasattr(self.widget, PWPN.GET_PARAMS):\n            params = getattr(self.widget, PWPN.GET_PARAMS)()\n            if not isinstance(params, dict):\n                raise TypeError(\n                    f\"`{PWPN.GET_PARAMS}` of {self.widget!r} must return a dict, got \"\n                    f\"{type(params)}.\"\n                )\n        else:\n            params = {}\n        return params\n\n    def _get_preview_window(self) -&gt; SubWindow[_W] | None:\n        \"\"\"Return the preview window if it is alive.\"\"\"\n        if (prev := self._preview_window_ref()) and prev.is_alive:\n            return prev\n        return None\n\n    def _is_run_immediately(self) -&gt; bool:\n        for param in self._fn_signature.parameters.values():\n            annot = param.annotation\n            if _is_annotated(annot):\n                _, op = _split_annotated_type(annot)\n                if \"bind\" not in op:\n                    return False\n            else:\n                return False\n        return True\n\n    def _widget_callback(self):\n        \"\"\"Callback when the call button is clicked.\"\"\"\n        main = self._main_window()\n        main._set_parametric_widget_busy(self, True)\n        try:\n            self._callback_with_params(self.get_params())\n        except Exception:\n            main._set_parametric_widget_busy(self, False)\n            raise\n\n    def _call(self, **kwargs):\n        \"\"\"Call the callback (maybe) asynchronously.\"\"\"\n        ui = self._main_window()._himena_main_window\n        if self._run_asynchronously:\n            if self._last_future is not None:\n                self._last_future.cancel()\n                self._last_future = None\n            self._last_future = future = ui._executor.submit(self._callback, **kwargs)\n            return future\n        else:\n            return self._callback(**kwargs)\n\n    def _widget_preview_callback(self):\n        \"\"\"Callback function of parameter change during preview\"\"\"\n        main = self._main_window()\n        if not self.is_preview_enabled():\n            if prev := self._get_preview_window():\n                self._preview_window_ref = _do_nothing\n                self._child_windows.discard(prev)\n                if self._result_as == \"window\":\n                    prev._close_me(main._himena_main_window)\n                else:\n                    main._remove_widget_from_parametric_window(self)\n                    if hint := self.size_hint():\n                        self.rect = (self.rect.left, self.rect.top, hint[0], hint[1])\n            return None\n        kwargs = self.get_params()\n        if self._has_is_previewing:\n            kwargs[self._IS_PREVIEWING] = True\n        return_value = self._call(**kwargs)\n        if isinstance(return_value, Future):  # running asynchronously\n            done = main._process_future_done_callback(\n                self._widget_preview_callback_done,\n                lambda e: main._set_parametric_widget_busy(self, False),\n            )\n            return_value.add_done_callback(done)\n            main._set_parametric_widget_busy(self, True)\n        else:\n            temp_future = Future()\n            temp_future.set_result(return_value)\n            self._widget_preview_callback_done(temp_future)\n\n    def _widget_preview_callback_done(self, future: Future):\n        \"\"\"Callback function when the job of preview is done.\"\"\"\n        main = self._main_window()\n        main._set_parametric_widget_busy(self, False)\n        return_value = future.result()\n        if return_value is None:\n            return None\n        if not isinstance(return_value, WidgetDataModel):\n            raise NotImplementedError(\n                \"Preview is only supported for WidgetDataModel but the return value \"\n                f\"was {type(return_value)}\"\n            )\n        if prev := self._get_preview_window():\n            prev.update_model(return_value)\n        else:\n            # create a new preview window\n            result_widget = self._model_to_new_window(return_value)\n            if self._result_as == \"window\":\n                # create a new preview window\n                title = f\"{return_value.title} (preview)\"\n                prev = self.add_child(result_widget, title=title)\n                main.set_widget_as_preview(prev)\n                prev.force_not_editable(True)  # disable editing if possible\n                # move the window so that it does not overlap with the parametric window\n                prev.rect = _find_where_to_move(self, prev, main)\n            else:\n                main._add_widget_to_parametric_window(\n                    self, result_widget, self._result_as\n                )\n                # update the size because new window is added\n                if hint := self.size_hint():\n                    self.rect = (self.rect.left, self.rect.top, hint[0], hint[1])\n                prev = WidgetWrapper(result_widget, main)  # just for wrapping\n            self._preview_window_ref = weakref.ref(prev)\n            main._move_focus_to(self._frontend_widget())\n        return None\n\n    def _process_return_value(self, return_value: Any, kwargs: dict[str, Any]):\n        main = self._main_window()\n        ui = main._himena_main_window\n        main._set_parametric_widget_busy(self, False)\n        tracker = ModelTrack.get(self._callback)\n        _return_annot = self._fn_signature.return_annotation\n        _LOGGER.info(\"Got tracker: %r\", tracker)\n        if isinstance(return_value, WidgetDataModel):\n            if prev := self._get_preview_window():\n                # no need to create a new window, just use the preview window\n                self._preview_window_ref = _do_nothing\n                if self._result_as != \"window\":\n                    widget = prev.widget  # avoid garbage collection\n                    main._remove_widget_from_parametric_window(self)\n                    result_widget = ui.add_widget(widget)\n                    result_widget._update_from_returned_model(return_value)\n                else:\n                    self._child_windows.discard(prev)\n                    result_widget = prev\n                result_widget.title = return_value.title  # title needs update\n\n                # if callback has \"is_previewing\" argument, the returned value may\n                # differ, thus the widget needs update.\n                if self._has_is_previewing:\n                    result_widget.update_model(return_value)\n                result_widget.force_not_editable(False)\n                with suppress(AttributeError):\n                    result_widget.is_editable = True\n                if self._auto_close:\n                    self._close_me(ui)\n            else:\n                result_widget = self._process_model_output(return_value)\n                if result_widget is None:\n                    return None\n            _LOGGER.info(\"Got subwindow: %r\", result_widget)\n            if tracker is not None:\n                new_workflow = tracker.to_workflow(kwargs)\n                _LOGGER.info(\n                    \"Inherited method %r, where the original method was %r\",\n                    new_workflow,\n                    return_value.workflow,\n                )\n                # NOTE: overwrite=False is needed to avoid overwriting ReaderMethod\n                result_widget._update_model_workflow(new_workflow, overwrite=False)\n                if isinstance(new_workflow, CommandExecution):\n                    if not isinstance(\n                        return_value.save_behavior_override, NoNeedToSave\n                    ):\n                        result_widget._set_ask_save_before_close(True)\n        elif _return_annot in (Parametric, ParametricWidgetProtocol):\n            raise NotImplementedError\n        else:\n            annot = getattr(self._callback, \"__annotations__\", {})\n            if isinstance(return_value, Future):\n                injection_type_hint = Future\n                # This is hacky. The injection store will process the result but the\n                # return type cannot be inherited from the callback. Here, we just set\n                # the type hint to Future and let it processed in the\n                # \"_future_done_callback\" method of himena application.\n                if prev := self._get_preview_window():\n                    top_left = (prev.rect.left, prev.rect.top)\n                    size = prev.rect.size()\n                else:\n                    top_left = (self.rect.left, self.rect.top)\n                    size = None\n                injection_ns = ui.model_app.injection_store.namespace\n                FutureInfo(\n                    type_hint=annot.get(\"return\", None),\n                    track=tracker,\n                    kwargs=kwargs,\n                    top_left=top_left,\n                    size=size,\n                ).resolve_type_hint(injection_ns).set(return_value)\n            else:\n                injection_type_hint = annot.get(\"return\", None)\n            self._process_other_output(return_value, injection_type_hint)\n        return None\n\n    def _callback_with_params(\n        self,\n        kwargs: dict[str, Any],\n        force_sync: bool = False,\n    ) -&gt; Any:\n        if self._has_is_previewing:\n            kwargs = {**kwargs, self._IS_PREVIEWING: False}\n        main = self._main_window()\n        old_run_async = self._run_asynchronously\n        try:\n            if force_sync:\n                self._run_asynchronously = False\n            return_value = self._call(**kwargs)\n        except Exception:\n            main._set_parametric_widget_busy(self, False)\n            raise\n        finally:\n            self._run_asynchronously = old_run_async\n        if isinstance(return_value, Future):\n            main._add_job_progress(return_value, desc=self.title, total=0)\n            return_value.add_done_callback(\n                main._process_future_done_callback(\n                    self._process_return_value,\n                    lambda e: main._set_parametric_widget_busy(self, False),\n                    kwargs=kwargs,\n                )\n            )\n            return return_value\n        else:\n            main._set_parametric_widget_busy(self, False)\n            self._process_return_value(return_value, kwargs)\n            return return_value\n\n    def is_preview_enabled(self) -&gt; bool:\n        \"\"\"Whether the widget supports preview.\"\"\"\n        isfunc = getattr(self.widget, PWPN.IS_PREVIEW_ENABLED, None)\n        return callable(isfunc) and isfunc()\n\n    def _emit_btn_clicked(self) -&gt; None:\n        return self.btn_clicked.emit(self)\n\n    def _emit_param_changed(self) -&gt; None:\n        return self.params_changed.emit(self)\n\n    def _process_model_output(self, model: WidgetDataModel) -&gt; SubWindow[_W] | None:\n        \"\"\"Process the returned WidgetDataModel.\"\"\"\n        ui = self._main_window()._himena_main_window\n        i_tab, i_win = self._find_me(ui)\n        rect = self.rect\n        if self._auto_close:\n            del ui.tabs[i_tab][i_win]\n        if ui._instructions.process_model_output:\n            widget = self._model_to_new_window(model)\n            result_widget = ui.tabs[i_tab].add_widget(\n                widget, title=model.title, auto_size=False\n            )\n            # coerce rect\n            if size_hint := result_widget.size_hint():\n                new_rect = (rect.left, rect.top, size_hint[0], size_hint[1])\n            else:\n                new_rect = rect\n            result_widget.rect = new_rect\n            _checker.call_widget_added_callback(widget)\n            return result_widget._update_from_returned_model(model)\n        return None\n\n    def _model_to_new_window(self, model: WidgetDataModel) -&gt; _W:\n        ui = self._main_window()._himena_main_window\n        widget = ui._pick_widget(model)\n        return widget\n\n    def _process_other_output(self, return_value: Any, type_hint: Any | None = None):\n        _LOGGER.info(\"Got output: %r with type hint %r\", type(return_value), type_hint)\n        ui = self._main_window()._himena_main_window\n        ui.model_app.injection_store.process(return_value, type_hint=type_hint)\n        if self._auto_close:\n            self._close_me(ui)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.ParametricWindow._call","title":"<code>_call(**kwargs)</code>","text":"<p>Call the callback (maybe) asynchronously.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def _call(self, **kwargs):\n    \"\"\"Call the callback (maybe) asynchronously.\"\"\"\n    ui = self._main_window()._himena_main_window\n    if self._run_asynchronously:\n        if self._last_future is not None:\n            self._last_future.cancel()\n            self._last_future = None\n        self._last_future = future = ui._executor.submit(self._callback, **kwargs)\n        return future\n    else:\n        return self._callback(**kwargs)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.ParametricWindow._get_preview_window","title":"<code>_get_preview_window()</code>","text":"<p>Return the preview window if it is alive.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def _get_preview_window(self) -&gt; SubWindow[_W] | None:\n    \"\"\"Return the preview window if it is alive.\"\"\"\n    if (prev := self._preview_window_ref()) and prev.is_alive:\n        return prev\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.ParametricWindow._process_model_output","title":"<code>_process_model_output(model)</code>","text":"<p>Process the returned WidgetDataModel.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def _process_model_output(self, model: WidgetDataModel) -&gt; SubWindow[_W] | None:\n    \"\"\"Process the returned WidgetDataModel.\"\"\"\n    ui = self._main_window()._himena_main_window\n    i_tab, i_win = self._find_me(ui)\n    rect = self.rect\n    if self._auto_close:\n        del ui.tabs[i_tab][i_win]\n    if ui._instructions.process_model_output:\n        widget = self._model_to_new_window(model)\n        result_widget = ui.tabs[i_tab].add_widget(\n            widget, title=model.title, auto_size=False\n        )\n        # coerce rect\n        if size_hint := result_widget.size_hint():\n            new_rect = (rect.left, rect.top, size_hint[0], size_hint[1])\n        else:\n            new_rect = rect\n        result_widget.rect = new_rect\n        _checker.call_widget_added_callback(widget)\n        return result_widget._update_from_returned_model(model)\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.ParametricWindow._widget_callback","title":"<code>_widget_callback()</code>","text":"<p>Callback when the call button is clicked.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def _widget_callback(self):\n    \"\"\"Callback when the call button is clicked.\"\"\"\n    main = self._main_window()\n    main._set_parametric_widget_busy(self, True)\n    try:\n        self._callback_with_params(self.get_params())\n    except Exception:\n        main._set_parametric_widget_busy(self, False)\n        raise\n</code></pre>"},{"location":"api/widgets/#himena.widgets.ParametricWindow._widget_preview_callback","title":"<code>_widget_preview_callback()</code>","text":"<p>Callback function of parameter change during preview</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def _widget_preview_callback(self):\n    \"\"\"Callback function of parameter change during preview\"\"\"\n    main = self._main_window()\n    if not self.is_preview_enabled():\n        if prev := self._get_preview_window():\n            self._preview_window_ref = _do_nothing\n            self._child_windows.discard(prev)\n            if self._result_as == \"window\":\n                prev._close_me(main._himena_main_window)\n            else:\n                main._remove_widget_from_parametric_window(self)\n                if hint := self.size_hint():\n                    self.rect = (self.rect.left, self.rect.top, hint[0], hint[1])\n        return None\n    kwargs = self.get_params()\n    if self._has_is_previewing:\n        kwargs[self._IS_PREVIEWING] = True\n    return_value = self._call(**kwargs)\n    if isinstance(return_value, Future):  # running asynchronously\n        done = main._process_future_done_callback(\n            self._widget_preview_callback_done,\n            lambda e: main._set_parametric_widget_busy(self, False),\n        )\n        return_value.add_done_callback(done)\n        main._set_parametric_widget_busy(self, True)\n    else:\n        temp_future = Future()\n        temp_future.set_result(return_value)\n        self._widget_preview_callback_done(temp_future)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.ParametricWindow._widget_preview_callback_done","title":"<code>_widget_preview_callback_done(future)</code>","text":"<p>Callback function when the job of preview is done.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def _widget_preview_callback_done(self, future: Future):\n    \"\"\"Callback function when the job of preview is done.\"\"\"\n    main = self._main_window()\n    main._set_parametric_widget_busy(self, False)\n    return_value = future.result()\n    if return_value is None:\n        return None\n    if not isinstance(return_value, WidgetDataModel):\n        raise NotImplementedError(\n            \"Preview is only supported for WidgetDataModel but the return value \"\n            f\"was {type(return_value)}\"\n        )\n    if prev := self._get_preview_window():\n        prev.update_model(return_value)\n    else:\n        # create a new preview window\n        result_widget = self._model_to_new_window(return_value)\n        if self._result_as == \"window\":\n            # create a new preview window\n            title = f\"{return_value.title} (preview)\"\n            prev = self.add_child(result_widget, title=title)\n            main.set_widget_as_preview(prev)\n            prev.force_not_editable(True)  # disable editing if possible\n            # move the window so that it does not overlap with the parametric window\n            prev.rect = _find_where_to_move(self, prev, main)\n        else:\n            main._add_widget_to_parametric_window(\n                self, result_widget, self._result_as\n            )\n            # update the size because new window is added\n            if hint := self.size_hint():\n                self.rect = (self.rect.left, self.rect.top, hint[0], hint[1])\n            prev = WidgetWrapper(result_widget, main)  # just for wrapping\n        self._preview_window_ref = weakref.ref(prev)\n        main._move_focus_to(self._frontend_widget())\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.ParametricWindow.get_params","title":"<code>get_params()</code>","text":"<p>Get the parameters of the widget.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def get_params(self) -&gt; dict[str, Any]:\n    \"\"\"Get the parameters of the widget.\"\"\"\n    if hasattr(self.widget, PWPN.GET_PARAMS):\n        params = getattr(self.widget, PWPN.GET_PARAMS)()\n        if not isinstance(params, dict):\n            raise TypeError(\n                f\"`{PWPN.GET_PARAMS}` of {self.widget!r} must return a dict, got \"\n                f\"{type(params)}.\"\n            )\n    else:\n        params = {}\n    return params\n</code></pre>"},{"location":"api/widgets/#himena.widgets.ParametricWindow.is_preview_enabled","title":"<code>is_preview_enabled()</code>","text":"<p>Whether the widget supports preview.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def is_preview_enabled(self) -&gt; bool:\n    \"\"\"Whether the widget supports preview.\"\"\"\n    isfunc = getattr(self.widget, PWPN.IS_PREVIEW_ENABLED, None)\n    return callable(isfunc) and isfunc()\n</code></pre>"},{"location":"api/widgets/#himena.widgets.SubWindow","title":"<code>SubWindow</code>","text":"Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>class SubWindow(WidgetWrapper[_W], Layout):\n    state_changed = Signal(WindowState)\n    renamed = Signal(str)\n    closed = Signal()\n\n    def __init__(\n        self,\n        widget: _W,\n        main_window: BackendMainWindow[_W],\n        identifier: uuid.UUID | None = None,\n    ):\n        super().__init__(widget, main_window=main_window, identifier=identifier)\n        Layout.__init__(self, main_window)\n        self._child_windows: weakref.WeakSet[SubWindow[_W]] = weakref.WeakSet()\n        self._alive = False\n        self.closed.connect(self._close_callback)\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"{type(self).__name__}(title={self.title!r}, widget={_widget_repr(self)})\"\n        )\n\n    def __class_getitem__(cls, widget_type: type[_W]):\n        # this hack allows in_n_out to assign both SubWindow and SubWindow[T] to the\n        # same provider/processor.\n        return cls\n\n    @classmethod\n    def _deserialize_layout(cls, obj: dict, main: MainWindow) -&gt; SubWindow[Any]:\n        win = main.window_for_id(uuid.UUID(obj[\"id\"]))\n        if win is None:\n            raise RuntimeError(f\"SubWindow {obj['id']} not found in main window.\")\n        return win\n\n    def _serialize_layout(self):\n        return {\"type\": \"subwindow\", \"id\": self._identifier.hex}\n\n    @property\n    def title(self) -&gt; str:\n        \"\"\"Title of the sub-window.\"\"\"\n        return self._main_window()._window_title(self._frontend_widget())\n\n    @title.setter\n    def title(self, value: str) -&gt; None:\n        self._main_window()._set_window_title(self._frontend_widget(), value)\n\n    @property\n    def state(self) -&gt; WindowState:\n        \"\"\"State (e.g. maximized, minimized) of the sub-window.\"\"\"\n        return self._main_window()._window_state(self._frontend_widget())\n\n    @state.setter\n    def state(self, value: WindowState | str) -&gt; None:\n        main = self._main_window()._himena_main_window\n        inst = main._instructions.updated(animate=False)\n        self._set_state(value, inst)\n\n    @property\n    def rect(self) -&gt; WindowRect:\n        \"\"\"Position and size of the sub-window.\"\"\"\n        return self._main_window()._window_rect(self._frontend_widget())\n\n    @rect.setter\n    def rect(self, value: tuple[int, int, int, int]) -&gt; None:\n        main = self._main_window()._himena_main_window\n        inst = main._instructions.updated(animate=False)\n        self._set_rect(value, inst)\n\n    @property\n    def is_alive(self) -&gt; bool:\n        \"\"\"Whether the sub-window is present in a main window.\"\"\"\n        return self._alive\n\n    def to_model(self) -&gt; WidgetDataModel:\n        \"\"\"Export the widget data.\"\"\"\n        if not self.supports_to_model:\n            raise ValueError(\"Widget does not have `to_model` method.\")\n        model = self.widget.to_model()  # type: ignore\n        if not isinstance(model, WidgetDataModel):\n            raise TypeError(\n                \"`to_model` method must return an instance of WidgetDataModel, got \"\n                f\"{type(model)}\"\n            )\n\n        if model.title is None:\n            model.title = self.title\n        if len(model.workflow) == 0:\n            model.workflow = self._widget_workflow\n        if self.is_modified and not isinstance(model.workflow[-1], UserModification):\n            model.workflow = model.workflow.with_step(\n                UserModification(original=model.workflow[-1].id)\n            )\n        if model.extension_default is None:\n            model.extension_default = self._extension_default_fallback\n        return model\n\n    def update_value(self, value: Any) -&gt; None:\n        \"\"\"Update the value of the widget.\"\"\"\n        if hasattr(self.widget, \"update_value\"):\n            self.widget.update_value(value)\n        else:\n            model = self.to_model()\n            self.update_model(model.with_value(value))\n\n    def update_metadata(self, metadata: Any) -&gt; None:\n        \"\"\"Update the metadata of the widget data model.\"\"\"\n        return self.update_model(self.to_model().with_metadata(metadata))\n\n    def write_model(self, path: str | Path, plugin: str | None = None) -&gt; None:\n        \"\"\"Write the widget data to a file.\"\"\"\n        return self._write_model(path, plugin, self.to_model())\n\n    @property\n    def tab_area(self) -&gt; TabArea[_W]:\n        \"\"\"Tab area of the sub-window.\"\"\"\n        _hash = self._main_window()._tab_hash_for_window(self._frontend_widget())\n        return self._main_window()._himena_main_window.tabs._tab_areas[_hash]\n\n    def _write_model(\n        self, path: str | Path, plugin: str | None, model: WidgetDataModel\n    ) -&gt; None:\n        io_utils.write(model, path, plugin=plugin)\n        self.update_default_save_path(path)\n        return None\n\n    def _set_state(self, value: WindowState, inst: BackendInstructions | None = None):\n        main = self._main_window()\n        front = self._frontend_widget()\n        if main._window_state(front) is value:  # if already in the state, do nothing\n            return None\n        if inst is None:\n            inst = main._himena_main_window._instructions\n        main._set_window_state(front, value, inst)\n        stack = self.tab_area._minimized_window_stack_layout\n        if value is WindowState.MIN:\n            stack.add(self)\n            self.anchor = None\n        elif value in (WindowState.FULL, WindowState.MAX):\n            self.anchor = _anchor.AllCornersAnchor()\n        else:\n            self.anchor = None\n            if self._parent_layout_ref() is stack:\n                stack.remove(self)\n                stack._reanchor(Size(*main._area_size()))\n\n    def _set_rect(\n        self,\n        value: tuple[int, int, int, int],\n        inst: BackendInstructions | None = None,\n    ):\n        if inst is None:\n            inst = self._main_window()._himena_main_window._instructions\n        rect_old = self.rect\n        main = self._main_window()\n        front = self._frontend_widget()\n        rect = WindowRect.from_tuple(*value)\n        anc = self.anchor.update_for_window_rect(main._area_size(), rect)\n        main._set_window_rect(front, rect, inst)\n        self.anchor = anc\n        if parent := self._parent_layout_ref():\n            parent._adjust_child_resize(self, rect_old, rect)\n\n    def _reanchor(self, size: Size):\n        if self.state is WindowState.MIN:\n            pass\n        elif self.state in (WindowState.MAX, WindowState.FULL):\n            self.rect = WindowRect(0, 0, *size)\n        else:\n            super()._reanchor(size)\n\n    def update(\n        self,\n        *,\n        rect: tuple[int, int, int, int] | WindowRect | None = None,\n        state: WindowState | None = None,\n        title: str | None = None,\n        anchor: _anchor.WindowAnchor | str | None = None,\n    ) -&gt; SubWindow[_W]:\n        \"\"\"A helper method to update window properties.\"\"\"\n        if rect is not None:\n            self.rect = rect\n        if state is not None:\n            self.state = state\n        if title is not None:\n            self.title = title\n        if anchor is not None:\n            self.anchor = anchor\n        return self\n\n    def add_child(\n        self,\n        widget: _W,\n        *,\n        title: str | None = None,\n    ) -&gt; SubWindow[_W]:\n        \"\"\"Add a child sub-window, which is automatically closed when the parent is closed.\"\"\"  # noqa: E501\n        main = self._main_window()._himena_main_window\n        i_tab, _ = self._find_me(main)\n        child = main.tabs[i_tab].add_widget(widget, title=title)\n        self._child_windows.add(child)\n        return child\n\n    def _find_me(self, main: MainWindow) -&gt; tuple[int, int]:\n        for i_tab, tab in main.tabs.enumerate():\n            for i_win, win in tab.enumerate():\n                # NOTE: should not be `win is self`, because the wrapper may be\n                # recreated\n                if win.widget is self.widget:\n                    return i_tab, i_win\n        raise RuntimeError(f\"SubWindow {self.title} not found in main window.\")\n\n    def _close_me(self, main: MainWindow, confirm: bool = False) -&gt; None:\n        if self._need_ask_save_before_close() and confirm:\n            title_short = repr(self.title)\n            if len(title_short) &gt; 60:\n                title_short = title_short[:60] + \"...\"\n            if isinstance(self.save_behavior, SaveToNewPath):\n                message = f\"{title_short} is not saved yet. Save before closing?\"\n            else:\n                message = f\"Save changes to {title_short}?\"\n            request = main.exec_choose_one_dialog(\n                title=\"Closing window\",\n                message=message,\n                choices=[\"Save\", \"Don't save\", \"Cancel\"],\n            )\n            if request is None or request == \"Cancel\":\n                return None\n            elif request == \"Save\":\n                if cb := self._save_from_dialog(main):\n                    cb()\n                else:\n                    return None\n\n        i_tab, i_win = self._find_me(main)\n        del main.tabs[i_tab][i_win]\n\n    def _save_from_dialog(\n        self,\n        main: MainWindow,\n        behavior: SaveBehavior | None = None,\n        plugin: str | None = None,\n    ) -&gt; Callable[[], None] | None:\n        \"\"\"Save this window to a new path, return if saved.\"\"\"\n        if behavior is None:\n            behavior = self.save_behavior\n        model = self.to_model()\n        if save_path := behavior.get_save_path(main, model):\n\n            def _save():\n                main.set_status_tip(f\"Saving {self.title!r} to {save_path}\", duration=2)\n                self._write_model(save_path, plugin=plugin, model=model)\n                main.set_status_tip(f\"Saved {self.title!r} to {save_path}\", duration=2)\n                return None\n\n            return _save\n        return None\n\n    def _close_all_children(self, main: MainWindow) -&gt; None:\n        \"\"\"Close all the sub-windows that are children of this window.\"\"\"\n        for child in self._child_windows:\n            child._close_all_children(main)\n            if child.is_alive:\n                child._close_me(main, confirm=False)\n\n    def _close_callback(self):\n        main = self._main_window()._himena_main_window\n        self._close_all_children(main)\n        if layout := self._parent_layout_ref():\n            layout.remove(self)\n        self._alive = False\n\n    def _determine_read_from(self) -&gt; tuple[Path | list[Path], str | None] | None:\n        \"\"\"Determine how can the data be efficiently read.\"\"\"\n        workflow = self._widget_workflow.last()\n        if isinstance(workflow, LocalReaderMethod):\n            return workflow.path, workflow.plugin\n        elif isinstance(save_bh := self.save_behavior, SaveToPath):\n            return save_bh.path, None\n        else:\n            return None\n\n    def _update_from_returned_model(self, model: WidgetDataModel) -&gt; SubWindow[_W]:\n        \"\"\"Update the sub-window based on the returned model.\"\"\"\n        if isinstance(wf := model.workflow.last(), LocalReaderMethod):\n            # file is directly read from the local path\n            if isinstance(save_path := wf.path, Path):\n                self.update_default_save_path(save_path, plugin=wf.plugin)\n        elif isinstance(wf := model.workflow.last(), CommandExecution):\n            # model is created by some command\n            if not isinstance(model.save_behavior_override, NoNeedToSave):\n                self._set_ask_save_before_close(True)\n        if len(wlist := model.workflow) &gt; 0:\n            self._update_model_workflow(wlist)\n        if save_behavior_override := model.save_behavior_override:\n            self._save_behavior = save_behavior_override\n        if not model.editable:\n            with suppress(AttributeError):\n                self.is_editable = False\n        return self\n\n    def _switch_to_file_watch_mode(self):\n        # TODO: don't use Qt in the future\n        from himena.qt._qtwatchfiles import QWatchFileObject\n\n        self.title = f\"[Preview] {self.title}\"\n        QWatchFileObject(self)\n        return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.SubWindow.is_alive","title":"<code>is_alive</code>  <code>property</code>","text":"<p>Whether the sub-window is present in a main window.</p>"},{"location":"api/widgets/#himena.widgets.SubWindow.rect","title":"<code>rect</code>  <code>property</code> <code>writable</code>","text":"<p>Position and size of the sub-window.</p>"},{"location":"api/widgets/#himena.widgets.SubWindow.state","title":"<code>state</code>  <code>property</code> <code>writable</code>","text":"<p>State (e.g. maximized, minimized) of the sub-window.</p>"},{"location":"api/widgets/#himena.widgets.SubWindow.tab_area","title":"<code>tab_area</code>  <code>property</code>","text":"<p>Tab area of the sub-window.</p>"},{"location":"api/widgets/#himena.widgets.SubWindow.title","title":"<code>title</code>  <code>property</code> <code>writable</code>","text":"<p>Title of the sub-window.</p>"},{"location":"api/widgets/#himena.widgets.SubWindow._close_all_children","title":"<code>_close_all_children(main)</code>","text":"<p>Close all the sub-windows that are children of this window.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def _close_all_children(self, main: MainWindow) -&gt; None:\n    \"\"\"Close all the sub-windows that are children of this window.\"\"\"\n    for child in self._child_windows:\n        child._close_all_children(main)\n        if child.is_alive:\n            child._close_me(main, confirm=False)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.SubWindow._determine_read_from","title":"<code>_determine_read_from()</code>","text":"<p>Determine how can the data be efficiently read.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def _determine_read_from(self) -&gt; tuple[Path | list[Path], str | None] | None:\n    \"\"\"Determine how can the data be efficiently read.\"\"\"\n    workflow = self._widget_workflow.last()\n    if isinstance(workflow, LocalReaderMethod):\n        return workflow.path, workflow.plugin\n    elif isinstance(save_bh := self.save_behavior, SaveToPath):\n        return save_bh.path, None\n    else:\n        return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.SubWindow._save_from_dialog","title":"<code>_save_from_dialog(main, behavior=None, plugin=None)</code>","text":"<p>Save this window to a new path, return if saved.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def _save_from_dialog(\n    self,\n    main: MainWindow,\n    behavior: SaveBehavior | None = None,\n    plugin: str | None = None,\n) -&gt; Callable[[], None] | None:\n    \"\"\"Save this window to a new path, return if saved.\"\"\"\n    if behavior is None:\n        behavior = self.save_behavior\n    model = self.to_model()\n    if save_path := behavior.get_save_path(main, model):\n\n        def _save():\n            main.set_status_tip(f\"Saving {self.title!r} to {save_path}\", duration=2)\n            self._write_model(save_path, plugin=plugin, model=model)\n            main.set_status_tip(f\"Saved {self.title!r} to {save_path}\", duration=2)\n            return None\n\n        return _save\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.SubWindow._update_from_returned_model","title":"<code>_update_from_returned_model(model)</code>","text":"<p>Update the sub-window based on the returned model.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def _update_from_returned_model(self, model: WidgetDataModel) -&gt; SubWindow[_W]:\n    \"\"\"Update the sub-window based on the returned model.\"\"\"\n    if isinstance(wf := model.workflow.last(), LocalReaderMethod):\n        # file is directly read from the local path\n        if isinstance(save_path := wf.path, Path):\n            self.update_default_save_path(save_path, plugin=wf.plugin)\n    elif isinstance(wf := model.workflow.last(), CommandExecution):\n        # model is created by some command\n        if not isinstance(model.save_behavior_override, NoNeedToSave):\n            self._set_ask_save_before_close(True)\n    if len(wlist := model.workflow) &gt; 0:\n        self._update_model_workflow(wlist)\n    if save_behavior_override := model.save_behavior_override:\n        self._save_behavior = save_behavior_override\n    if not model.editable:\n        with suppress(AttributeError):\n            self.is_editable = False\n    return self\n</code></pre>"},{"location":"api/widgets/#himena.widgets.SubWindow.add_child","title":"<code>add_child(widget, *, title=None)</code>","text":"<p>Add a child sub-window, which is automatically closed when the parent is closed.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def add_child(\n    self,\n    widget: _W,\n    *,\n    title: str | None = None,\n) -&gt; SubWindow[_W]:\n    \"\"\"Add a child sub-window, which is automatically closed when the parent is closed.\"\"\"  # noqa: E501\n    main = self._main_window()._himena_main_window\n    i_tab, _ = self._find_me(main)\n    child = main.tabs[i_tab].add_widget(widget, title=title)\n    self._child_windows.add(child)\n    return child\n</code></pre>"},{"location":"api/widgets/#himena.widgets.SubWindow.to_model","title":"<code>to_model()</code>","text":"<p>Export the widget data.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def to_model(self) -&gt; WidgetDataModel:\n    \"\"\"Export the widget data.\"\"\"\n    if not self.supports_to_model:\n        raise ValueError(\"Widget does not have `to_model` method.\")\n    model = self.widget.to_model()  # type: ignore\n    if not isinstance(model, WidgetDataModel):\n        raise TypeError(\n            \"`to_model` method must return an instance of WidgetDataModel, got \"\n            f\"{type(model)}\"\n        )\n\n    if model.title is None:\n        model.title = self.title\n    if len(model.workflow) == 0:\n        model.workflow = self._widget_workflow\n    if self.is_modified and not isinstance(model.workflow[-1], UserModification):\n        model.workflow = model.workflow.with_step(\n            UserModification(original=model.workflow[-1].id)\n        )\n    if model.extension_default is None:\n        model.extension_default = self._extension_default_fallback\n    return model\n</code></pre>"},{"location":"api/widgets/#himena.widgets.SubWindow.update","title":"<code>update(*, rect=None, state=None, title=None, anchor=None)</code>","text":"<p>A helper method to update window properties.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def update(\n    self,\n    *,\n    rect: tuple[int, int, int, int] | WindowRect | None = None,\n    state: WindowState | None = None,\n    title: str | None = None,\n    anchor: _anchor.WindowAnchor | str | None = None,\n) -&gt; SubWindow[_W]:\n    \"\"\"A helper method to update window properties.\"\"\"\n    if rect is not None:\n        self.rect = rect\n    if state is not None:\n        self.state = state\n    if title is not None:\n        self.title = title\n    if anchor is not None:\n        self.anchor = anchor\n    return self\n</code></pre>"},{"location":"api/widgets/#himena.widgets.SubWindow.update_metadata","title":"<code>update_metadata(metadata)</code>","text":"<p>Update the metadata of the widget data model.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def update_metadata(self, metadata: Any) -&gt; None:\n    \"\"\"Update the metadata of the widget data model.\"\"\"\n    return self.update_model(self.to_model().with_metadata(metadata))\n</code></pre>"},{"location":"api/widgets/#himena.widgets.SubWindow.update_value","title":"<code>update_value(value)</code>","text":"<p>Update the value of the widget.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def update_value(self, value: Any) -&gt; None:\n    \"\"\"Update the value of the widget.\"\"\"\n    if hasattr(self.widget, \"update_value\"):\n        self.widget.update_value(value)\n    else:\n        model = self.to_model()\n        self.update_model(model.with_value(value))\n</code></pre>"},{"location":"api/widgets/#himena.widgets.SubWindow.write_model","title":"<code>write_model(path, plugin=None)</code>","text":"<p>Write the widget data to a file.</p> Source code in <code>src\\himena\\widgets\\_wrapper.py</code> <pre><code>def write_model(self, path: str | Path, plugin: str | None = None) -&gt; None:\n    \"\"\"Write the widget data to a file.\"\"\"\n    return self._write_model(path, plugin, self.to_model())\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea","title":"<code>TabArea</code>","text":"<p>An area containing multiple sub-windows.</p> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>class TabArea(SemiMutableSequence[SubWindow[_W]], _HasMainWindowRef[_W]):\n    \"\"\"An area containing multiple sub-windows.\"\"\"\n\n    def __init__(self, main_window: BackendMainWindow[_W], hash_value: Hashable):\n        super().__init__(main_window)\n        self._hash_value = hash_value\n        # A tab area always has a layout for stacking minimized windows\n        self._minimized_window_stack_layout = VStackLayout(main_window, inverted=True)\n        self._layouts = [self._minimized_window_stack_layout]\n        self._minimized_window_stack_layout._reanchor(Size(*main_window._area_size()))\n\n    @property\n    def layouts(self) -&gt; FrozenList[Layout]:\n        \"\"\"List of layouts in the tab area.\"\"\"\n        return FrozenList(self._layouts)\n\n    def _tab_index(self) -&gt; int:\n        main = self._main_window()\n        for i in range(main._num_tabs()):\n            if main._tab_hash(i) == self._hash_value:\n                return i\n        raise ValueError(\"Tab is already removed from the main window.\")\n\n    def __getitem__(self, index_or_name: int | str) -&gt; SubWindow[_W]:\n        index = self._norm_index_or_name(index_or_name)\n        widgets = self._main_window()._get_widget_list(self._tab_index())\n        front = widgets[index][1]\n        return front._himena_widget\n\n    def __delitem__(self, index_or_name: int | str) -&gt; None:\n        index = self._norm_index_or_name(index_or_name)\n        win, widget = self._pop_no_emit(index)\n        _checker.call_widget_closed_callback(widget)\n        win.closed.emit()\n\n    def _pop_no_emit(self, index: int) -&gt; tuple[SubWindow[_W], _W]:\n        main = self._main_window()\n        win = self[index]\n        widget = win.widget  # get widget here to avoid garbage collection\n        main._del_widget_at(self._tab_index(), index)\n        main._remove_control_widget(widget)\n        if isinstance(sb := win.save_behavior, SaveToPath):\n            main._himena_main_window._history_closed.add((sb.path, sb.plugin))\n        return win, widget\n\n    def __len__(self) -&gt; int:\n        return len(self._main_window()._get_widget_list(self._tab_index()))\n\n    def __iter__(self) -&gt; Iterator[SubWindow[_W]]:\n        return iter(\n            w[1]._himena_widget\n            for w in self._main_window()._get_widget_list(self._tab_index())\n        )\n\n    def append(self, sub_window: SubWindow[_W], title: str) -&gt; None:\n        \"\"\"Append a sub-window to the tab area.\"\"\"\n        main = self._main_window()\n        interf, front = sub_window._split_interface_and_frontend()\n        front._himena_widget = sub_window\n        out = main.add_widget(front, self._tab_index(), title)\n        if hasattr(interf, \"control_widget\"):\n            main._set_control_widget(front, interf.control_widget())\n\n        main._connect_window_events(sub_window, out)\n        sub_window.title = title\n        sub_window.state_changed.connect(main._update_context)\n\n        main._set_current_tab_index(self._tab_index())\n        if main._himena_main_window._new_widget_behavior is NewWidgetBehavior.TAB:\n            main._set_window_state(\n                front,\n                WindowState.FULL,\n                main._himena_main_window._instructions.updated(animate=False),\n            )\n\n        main._move_focus_to(front)\n        sub_window._alive = True\n        return None\n\n    def current(self, default: _T = None) -&gt; SubWindow[_W] | _T:\n        \"\"\"Get the current sub-window or a default value.\"\"\"\n        idx = self.current_index\n        if idx is None:\n            return default\n        try:\n            return self[idx]\n        except IndexError:\n            return default\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Name of the tab area.\"\"\"\n        return self._main_window()._get_tab_name_list()[self._tab_index()]\n\n    @property\n    def current_index(self) -&gt; int | None:\n        \"\"\"Get the index of the current sub-window.\"\"\"\n        return self._main_window()._current_sub_window_index(self._tab_index())\n\n    @current_index.setter\n    def current_index(self, index: int) -&gt; None:\n        self._main_window()._set_current_sub_window_index(self._tab_index(), index)\n\n    @property\n    def title(self) -&gt; str:\n        \"\"\"Title of the tab area.\"\"\"\n        return self._main_window()._tab_title(self._tab_index())\n\n    def add_widget(\n        self,\n        widget: _W,\n        *,\n        title: str | None = None,\n        auto_size: bool = True,\n    ) -&gt; SubWindow[_W]:\n        \"\"\"Add a widget to the sub window.\n\n        Parameters\n        ----------\n        widget : QtW.QWidget\n            Widget to add.\n        title : str, optional\n            Title of the sub-window. If not given, its name will be automatically\n            generated.\n\n        Returns\n        -------\n        SubWindow\n            A sub-window widget. The added widget is available by calling\n            `widget` property.\n        \"\"\"\n        main = self._main_window()\n        sub_window = SubWindow(widget=widget, main_window=main)\n        self._process_new_widget(sub_window, title, auto_size)\n        main._move_focus_to(sub_window._split_interface_and_frontend()[1])\n        _checker.call_theme_changed_callback(widget, main._himena_main_window.theme)\n        return sub_window\n\n    def add_function(\n        self,\n        func: Callable[..., _T],\n        *,\n        preview: bool = False,\n        title: str | None = None,\n        show_parameter_labels: bool = True,\n        auto_close: bool = True,\n        run_async: bool = False,\n        result_as: Literal[\"window\", \"below\", \"right\"] = \"window\",\n    ) -&gt; ParametricWindow[_W]:\n        \"\"\"\n        Add a function as a parametric sub-window.\n\n        The input function must return a `WidgetDataModel` instance, which can be\n        interpreted by the application.\n\n        Parameters\n        ----------\n        func : function (...) -&gt; WidgetDataModel\n            Function that generates a model from the input parameters.\n        preview : bool, default False\n            If true, the parametric widget will be implemented with a preview toggle\n            button, and the preview window will be created when it is enabled.\n        title : str, optional\n            Title of the parametric window.\n        show_parameter_labels : bool, default True\n            If true, the parameter labels will be shown in the parametric window.\n        auto_close : bool, default True\n            If true, close the parametric window after the function call.\n\n        Returns\n        -------\n        SubWindow\n            The sub-window instance that represents the output model.\n        \"\"\"\n        sig = inspect.signature(func)\n        back_main = self._main_window()\n        _is_prev_arg = ParametricWindow._IS_PREVIEWING\n        if preview and _is_prev_arg in sig.parameters:\n            parameters = [p for p in sig.parameters.values() if p.name != _is_prev_arg]\n            sig = sig.replace(parameters=parameters)\n        fn_widget = back_main._signature_to_widget(\n            sig,\n            show_parameter_labels=show_parameter_labels,\n            preview=preview,\n        )\n        param_widget = self.add_parametric_widget(\n            fn_widget, func, title=title, preview=preview, run_async=run_async,\n            auto_close=auto_close, result_as=result_as,\n        )  # fmt: skip\n        return param_widget\n\n    def add_parametric_widget(\n        self,\n        widget: _W,\n        callback: Callable | None = None,\n        *,\n        title: str | None = None,\n        preview: bool = False,\n        auto_close: bool = True,\n        auto_size: bool = True,\n        run_async: bool = False,\n        result_as: Literal[\"window\", \"below\", \"right\"] = \"window\",\n    ) -&gt; ParametricWindow[_W]:\n        \"\"\"Add a custom parametric widget and its callback as a subwindow.\n\n        This method creates a parametric window inside the workspace, so that the\n        calculation can be done with the user-defined parameters.\n\n        Parameters\n        ----------\n        widget : _W\n            The parametric widget implemented with `get_params` and/or `get_output`.\n        callback : callable, optional\n            The callback function that will be called with the parameters set by the\n            widget.\n        title : str, optional\n            Title of the window to manage parameters.\n        preview : bool, default False\n            If true, the parametric widget will be check for whether preview is enabled\n            everytime the parameter changed, and if preview is enabled, a preview window\n            is created to show the preview result.\n        auto_close : bool, default True\n            If true, close the parametric window after the function call.\n        auto_size : bool, default True\n            If true, the output window will be auto-sized to the size of the parametric\n            window.\n\n        Returns\n        -------\n        ParametricWindow[_W]\n            A wrapper containing the backend widget.\n        \"\"\"\n        if callback is None:\n            if not hasattr(widget, PWPN.GET_OUTPUT):\n                raise TypeError(\n                    f\"Parametric widget must have `{PWPN.GET_OUTPUT}` method if \"\n                    \"callback is not given.\"\n                )\n            callback = getattr(widget, PWPN.GET_OUTPUT)\n        main = self._main_window()\n        widget0 = main._process_parametric_widget(widget)\n        param_widget = ParametricWindow(widget0, callback, main_window=main)\n        param_widget._auto_close = auto_close\n        param_widget._result_as = result_as\n        param_widget._run_asynchronously = run_async\n        main._connect_parametric_widget_events(param_widget, widget0)\n        self._process_new_widget(param_widget, title, auto_size)\n        if preview:\n            if not (\n                hasattr(widget, PWPN.CONNECT_CHANGED_SIGNAL)\n                and hasattr(widget, PWPN.IS_PREVIEW_ENABLED)\n            ):\n                raise TypeError(\n                    f\"If preview=True, the backend widget {widget!r} must implements \"\n                    f\"methods {PWPN.CONNECT_CHANGED_SIGNAL!r} and \"\n                    f\"{PWPN.IS_PREVIEW_ENABLED!r}\"\n                )\n            param_widget.params_changed.connect(param_widget._widget_preview_callback)\n        main._move_focus_to(widget0)\n        return param_widget\n\n    def add_layout(self, layout: Layout) -&gt; Layout:\n        layout._main_window_ref = weakref.ref(self._main_window())\n        return self._add_layout_impl(layout)\n\n    def add_vbox_layout(\n        self,\n        *,\n        margins: Margins[int] | tuple[int, int, int, int] = (0, 0, 0, 0),\n        spacing: int = 0,\n    ) -&gt; VBoxLayout:\n        \"\"\"Add a vertical box layout to the tab area.\n\n        Parameters\n        ----------\n        margins : (int, int, int, int) or Margins, optional\n            Left, top, right and bottom margins of the layout.\n        spacing : int, optional\n            Spacing between the widgets.\n        \"\"\"\n        main = self._main_window()\n        layout = VBoxLayout(main, margins=margins, spacing=spacing)\n        return self._add_layout_impl(layout)\n\n    def add_hbox_layout(\n        self,\n        *,\n        margins: Margins[int] | tuple[int, int, int, int] = (0, 0, 0, 0),\n        spacing: int = 0,\n    ) -&gt; HBoxLayout:\n        \"\"\"Add a horizontal box layout to the tab area.\n\n        Parameters\n        ----------\n        margins : (int, int, int, int) or Margins, optional\n            Left, top, right and bottom margins of the layout.\n        spacing : int, optional\n            Spacing between the widgets.\n        \"\"\"\n        main = self._main_window()\n        layout = HBoxLayout(main, margins=margins, spacing=spacing)\n        return self._add_layout_impl(layout)\n\n    def _add_layout_impl(self, layout: Layout) -&gt; Layout:\n        self._layouts.append(layout)\n        layout._reanchor(self._main_window()._area_size())\n        return layout\n\n    def _process_new_widget(\n        self,\n        sub_window: SubWindow[_W],\n        title: str | None = None,\n        auto_size: bool = True,\n    ) -&gt; None:\n        \"\"\"Add, resize, and set the focus to the new widget.\"\"\"\n        main = self._main_window()\n        interf, front = sub_window._split_interface_and_frontend()\n        if title is None:\n            title = getattr(interf, \"default_title\", _make_title)(len(self))\n        out = main.add_widget(front, self._tab_index(), title)\n        if hasattr(interf, \"control_widget\"):\n            main._set_control_widget(front, interf.control_widget())\n\n        main._connect_window_events(sub_window, out)\n        sub_window.title = title\n        sub_window.state_changed.connect(main._update_context)\n\n        main._set_current_tab_index(self._tab_index())\n        nwindows = len(self)\n        if main._himena_main_window._new_widget_behavior is NewWidgetBehavior.TAB:\n            main._set_window_state(\n                front,\n                WindowState.FULL,\n                main._himena_main_window._instructions.updated(animate=False),\n            )\n        else:\n            i_tab = main._current_tab_index()\n            main._set_current_sub_window_index(i_tab, len(self) - 1)\n            if auto_size:\n                left = 4 + 24 * (nwindows % 5)\n                top = 4 + 24 * (nwindows % 5)\n                if size_hint := sub_window.size_hint():\n                    width, height = size_hint\n                else:\n                    _, _, width, height = sub_window.rect\n                sub_window.rect = WindowRect(left, top, width, height)\n        _checker.call_widget_added_callback(sub_window.widget)\n        sub_window._alive = True\n        return None\n\n    def add_data_model(self, model: WidgetDataModel) -&gt; SubWindow[_W]:\n        \"\"\"Add a widget data model as a widget.\"\"\"\n        if not isinstance(model, WidgetDataModel):\n            raise TypeError(\n                f\"input model must be an instance of WidgetDataModel, got {model!r}\"\n            )\n        if len(model.workflow) == 0:\n            # this case may happen if this method was programatically called\n            wf = ProgrammaticMethod(output_model_type=model.type).construct_workflow()\n            model = model.model_copy(update={\"workflow\": wf})\n        ui = self._main_window()._himena_main_window\n        widget = ui._pick_widget(model)\n        ui.set_status_tip(f\"Data model {model.title!r} added.\", duration=1)\n        sub_win = self.add_widget(widget, title=model.title)\n        sub_win._update_from_returned_model(model)\n        if rect_factory := model.window_rect_override:\n            rect = WindowRect.from_tuple(*rect_factory(sub_win.size))\n            sub_win.rect = rect\n        if model.extension_default is not None:\n            sub_win._extension_default_fallback = model.extension_default\n        return sub_win\n\n    def read_file(\n        self,\n        file_path: PathOrPaths,\n        plugin: str | None = None,\n    ) -&gt; SubWindow[_W]:\n        \"\"\"Read local file(s) and open as a new sub-window in this tab.\n\n        Parameters\n        ----------\n        file_path : str or Path or list of them\n            Path(s) to the file to read. If a list is given, they will be read as a\n            group, not as separate windows.\n        plugin : str, optional\n            If given, reader provider will be searched with the plugin name. This value\n            is usually the full import path to the reader provider function, such as\n            `\"himena_builtins.io.default_reader_provider\"`.\n\n        Returns\n        -------\n        SubWindow\n            The sub-window instance that is constructed based on the return value of\n            the reader.\n        \"\"\"\n        return self.read_files([file_path], plugin=plugin)[0]\n\n    def read_files(\n        self,\n        file_paths: PathOrPaths,\n        plugin: str | None = None,\n    ) -&gt; list[SubWindow[_W]]:\n        \"\"\"Read multiple files and open as new sub-windows in this tab.\"\"\"\n        models = self._paths_to_models(file_paths, plugin=plugin)\n        out = [self.add_data_model(model) for model in models]\n        ui = self._main_window()._himena_main_window\n        if len(out) == 1:\n            ui.set_status_tip(f\"File opened: {out[0].title}\", duration=5)\n        elif len(out) &gt; 1:\n            _titles = \", \".join(w.title for w in out)\n            ui.set_status_tip(f\"File opened: {_titles}\", duration=5)\n        return out\n\n    def _paths_to_models(self, file_paths: PathOrPaths, plugin: str | None = None):\n        ins = _providers.ReaderStore.instance()\n        file_paths = _norm_paths(file_paths)\n        reader_path_sets = [\n            (ins.pick(file_path, plugin=plugin), file_path) for file_path in file_paths\n        ]\n        models = [\n            reader.read_and_update_source(file_path)\n            for reader, file_path in reader_path_sets\n        ]\n        ui = self._main_window()._himena_main_window\n        ui._recent_manager.append_recent_files(\n            [(fp, reader.plugin_str) for reader, fp in reader_path_sets]\n        )\n        return models\n\n    def read_files_async(\n        self,\n        file_paths: PathOrPaths,\n        plugin: str | None = None,\n    ) -&gt; Future:\n        ui = self._main_window()._himena_main_window\n        file_paths = _norm_paths(file_paths)\n        future = ui._executor.submit(self._paths_to_models, file_paths, plugin=plugin)\n        if len(file_paths) == 1:\n            ui.set_status_tip(f\"Opening: {file_paths[0].as_posix()}\", duration=5)\n        else:\n            ui.set_status_tip(f\"Opening {len(file_paths)} files\", duration=5)\n        FutureInfo(list[WidgetDataModel]).set(future)  # set info for injection store\n        return future\n\n    def save_session(\n        self,\n        file_path: str | Path,\n        save_copies: bool = False,\n        allow_calculate: Sequence[str] = (),\n    ) -&gt; None:\n        \"\"\"Save the current session to a file.\"\"\"\n        from himena.session import dump_tab_to_zip\n\n        dump_tab_to_zip(\n            self, file_path, save_copies=save_copies, allow_calculate=allow_calculate\n        )\n        return None\n\n    def tile_windows(\n        self,\n        nrows: int | None = None,\n        ncols: int | None = None,\n    ) -&gt; None:\n        main = self._main_window()\n        inst = main._himena_main_window._instructions\n        width, height = main._area_size()\n        nrows, ncols = _norm_nrows_ncols(nrows, ncols, len(self))\n\n        w = width / ncols\n        h = height / nrows\n        for i in range(nrows):\n            for j in range(ncols):\n                idx = i * ncols + j\n                if idx &gt;= len(self):\n                    break\n                x = j * width / ncols\n                y = i * height / nrows\n                sub = self[idx]\n                rect = WindowRect.from_tuple(x, y, w, h)\n                main._set_window_rect(sub.widget, rect, inst)\n        return None\n\n    def _norm_index_or_name(self, index_or_name: int | str) -&gt; int:\n        if isinstance(index_or_name, str):\n            for i, w in enumerate(\n                self._main_window()._get_widget_list(self._tab_index())\n            ):\n                if w[0] == index_or_name:\n                    index = i\n                    break\n            else:\n                raise ValueError(f\"Name {index_or_name!r} not found.\")\n        else:\n            if index_or_name &lt; 0:\n                index = len(self) + index_or_name\n            else:\n                index = index_or_name\n        return index\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea.current_index","title":"<code>current_index</code>  <code>property</code> <code>writable</code>","text":"<p>Get the index of the current sub-window.</p>"},{"location":"api/widgets/#himena.widgets.TabArea.layouts","title":"<code>layouts</code>  <code>property</code>","text":"<p>List of layouts in the tab area.</p>"},{"location":"api/widgets/#himena.widgets.TabArea.name","title":"<code>name</code>  <code>property</code>","text":"<p>Name of the tab area.</p>"},{"location":"api/widgets/#himena.widgets.TabArea.title","title":"<code>title</code>  <code>property</code>","text":"<p>Title of the tab area.</p>"},{"location":"api/widgets/#himena.widgets.TabArea._process_new_widget","title":"<code>_process_new_widget(sub_window, title=None, auto_size=True)</code>","text":"<p>Add, resize, and set the focus to the new widget.</p> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>def _process_new_widget(\n    self,\n    sub_window: SubWindow[_W],\n    title: str | None = None,\n    auto_size: bool = True,\n) -&gt; None:\n    \"\"\"Add, resize, and set the focus to the new widget.\"\"\"\n    main = self._main_window()\n    interf, front = sub_window._split_interface_and_frontend()\n    if title is None:\n        title = getattr(interf, \"default_title\", _make_title)(len(self))\n    out = main.add_widget(front, self._tab_index(), title)\n    if hasattr(interf, \"control_widget\"):\n        main._set_control_widget(front, interf.control_widget())\n\n    main._connect_window_events(sub_window, out)\n    sub_window.title = title\n    sub_window.state_changed.connect(main._update_context)\n\n    main._set_current_tab_index(self._tab_index())\n    nwindows = len(self)\n    if main._himena_main_window._new_widget_behavior is NewWidgetBehavior.TAB:\n        main._set_window_state(\n            front,\n            WindowState.FULL,\n            main._himena_main_window._instructions.updated(animate=False),\n        )\n    else:\n        i_tab = main._current_tab_index()\n        main._set_current_sub_window_index(i_tab, len(self) - 1)\n        if auto_size:\n            left = 4 + 24 * (nwindows % 5)\n            top = 4 + 24 * (nwindows % 5)\n            if size_hint := sub_window.size_hint():\n                width, height = size_hint\n            else:\n                _, _, width, height = sub_window.rect\n            sub_window.rect = WindowRect(left, top, width, height)\n    _checker.call_widget_added_callback(sub_window.widget)\n    sub_window._alive = True\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea.add_data_model","title":"<code>add_data_model(model)</code>","text":"<p>Add a widget data model as a widget.</p> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>def add_data_model(self, model: WidgetDataModel) -&gt; SubWindow[_W]:\n    \"\"\"Add a widget data model as a widget.\"\"\"\n    if not isinstance(model, WidgetDataModel):\n        raise TypeError(\n            f\"input model must be an instance of WidgetDataModel, got {model!r}\"\n        )\n    if len(model.workflow) == 0:\n        # this case may happen if this method was programatically called\n        wf = ProgrammaticMethod(output_model_type=model.type).construct_workflow()\n        model = model.model_copy(update={\"workflow\": wf})\n    ui = self._main_window()._himena_main_window\n    widget = ui._pick_widget(model)\n    ui.set_status_tip(f\"Data model {model.title!r} added.\", duration=1)\n    sub_win = self.add_widget(widget, title=model.title)\n    sub_win._update_from_returned_model(model)\n    if rect_factory := model.window_rect_override:\n        rect = WindowRect.from_tuple(*rect_factory(sub_win.size))\n        sub_win.rect = rect\n    if model.extension_default is not None:\n        sub_win._extension_default_fallback = model.extension_default\n    return sub_win\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea.add_function","title":"<code>add_function(func, *, preview=False, title=None, show_parameter_labels=True, auto_close=True, run_async=False, result_as='window')</code>","text":"<p>Add a function as a parametric sub-window.</p> <p>The input function must return a <code>WidgetDataModel</code> instance, which can be interpreted by the application.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>function (...) -&gt; WidgetDataModel</code> <p>Function that generates a model from the input parameters.</p> required <code>preview</code> <code>bool</code> <p>If true, the parametric widget will be implemented with a preview toggle button, and the preview window will be created when it is enabled.</p> <code>False</code> <code>title</code> <code>str</code> <p>Title of the parametric window.</p> <code>None</code> <code>show_parameter_labels</code> <code>bool</code> <p>If true, the parameter labels will be shown in the parametric window.</p> <code>True</code> <code>auto_close</code> <code>bool</code> <p>If true, close the parametric window after the function call.</p> <code>True</code> <p>Returns:</p> Type Description <code>SubWindow</code> <p>The sub-window instance that represents the output model.</p> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>def add_function(\n    self,\n    func: Callable[..., _T],\n    *,\n    preview: bool = False,\n    title: str | None = None,\n    show_parameter_labels: bool = True,\n    auto_close: bool = True,\n    run_async: bool = False,\n    result_as: Literal[\"window\", \"below\", \"right\"] = \"window\",\n) -&gt; ParametricWindow[_W]:\n    \"\"\"\n    Add a function as a parametric sub-window.\n\n    The input function must return a `WidgetDataModel` instance, which can be\n    interpreted by the application.\n\n    Parameters\n    ----------\n    func : function (...) -&gt; WidgetDataModel\n        Function that generates a model from the input parameters.\n    preview : bool, default False\n        If true, the parametric widget will be implemented with a preview toggle\n        button, and the preview window will be created when it is enabled.\n    title : str, optional\n        Title of the parametric window.\n    show_parameter_labels : bool, default True\n        If true, the parameter labels will be shown in the parametric window.\n    auto_close : bool, default True\n        If true, close the parametric window after the function call.\n\n    Returns\n    -------\n    SubWindow\n        The sub-window instance that represents the output model.\n    \"\"\"\n    sig = inspect.signature(func)\n    back_main = self._main_window()\n    _is_prev_arg = ParametricWindow._IS_PREVIEWING\n    if preview and _is_prev_arg in sig.parameters:\n        parameters = [p for p in sig.parameters.values() if p.name != _is_prev_arg]\n        sig = sig.replace(parameters=parameters)\n    fn_widget = back_main._signature_to_widget(\n        sig,\n        show_parameter_labels=show_parameter_labels,\n        preview=preview,\n    )\n    param_widget = self.add_parametric_widget(\n        fn_widget, func, title=title, preview=preview, run_async=run_async,\n        auto_close=auto_close, result_as=result_as,\n    )  # fmt: skip\n    return param_widget\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea.add_hbox_layout","title":"<code>add_hbox_layout(*, margins=(0, 0, 0, 0), spacing=0)</code>","text":"<p>Add a horizontal box layout to the tab area.</p> <p>Parameters:</p> Name Type Description Default <code>margins</code> <code>(int, int, int, int) or Margins</code> <p>Left, top, right and bottom margins of the layout.</p> <code>(0, 0, 0, 0)</code> <code>spacing</code> <code>int</code> <p>Spacing between the widgets.</p> <code>0</code> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>def add_hbox_layout(\n    self,\n    *,\n    margins: Margins[int] | tuple[int, int, int, int] = (0, 0, 0, 0),\n    spacing: int = 0,\n) -&gt; HBoxLayout:\n    \"\"\"Add a horizontal box layout to the tab area.\n\n    Parameters\n    ----------\n    margins : (int, int, int, int) or Margins, optional\n        Left, top, right and bottom margins of the layout.\n    spacing : int, optional\n        Spacing between the widgets.\n    \"\"\"\n    main = self._main_window()\n    layout = HBoxLayout(main, margins=margins, spacing=spacing)\n    return self._add_layout_impl(layout)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea.add_parametric_widget","title":"<code>add_parametric_widget(widget, callback=None, *, title=None, preview=False, auto_close=True, auto_size=True, run_async=False, result_as='window')</code>","text":"<p>Add a custom parametric widget and its callback as a subwindow.</p> <p>This method creates a parametric window inside the workspace, so that the calculation can be done with the user-defined parameters.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>_W</code> <p>The parametric widget implemented with <code>get_params</code> and/or <code>get_output</code>.</p> required <code>callback</code> <code>callable</code> <p>The callback function that will be called with the parameters set by the widget.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title of the window to manage parameters.</p> <code>None</code> <code>preview</code> <code>bool</code> <p>If true, the parametric widget will be check for whether preview is enabled everytime the parameter changed, and if preview is enabled, a preview window is created to show the preview result.</p> <code>False</code> <code>auto_close</code> <code>bool</code> <p>If true, close the parametric window after the function call.</p> <code>True</code> <code>auto_size</code> <code>bool</code> <p>If true, the output window will be auto-sized to the size of the parametric window.</p> <code>True</code> <p>Returns:</p> Type Description <code>ParametricWindow[_W]</code> <p>A wrapper containing the backend widget.</p> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>def add_parametric_widget(\n    self,\n    widget: _W,\n    callback: Callable | None = None,\n    *,\n    title: str | None = None,\n    preview: bool = False,\n    auto_close: bool = True,\n    auto_size: bool = True,\n    run_async: bool = False,\n    result_as: Literal[\"window\", \"below\", \"right\"] = \"window\",\n) -&gt; ParametricWindow[_W]:\n    \"\"\"Add a custom parametric widget and its callback as a subwindow.\n\n    This method creates a parametric window inside the workspace, so that the\n    calculation can be done with the user-defined parameters.\n\n    Parameters\n    ----------\n    widget : _W\n        The parametric widget implemented with `get_params` and/or `get_output`.\n    callback : callable, optional\n        The callback function that will be called with the parameters set by the\n        widget.\n    title : str, optional\n        Title of the window to manage parameters.\n    preview : bool, default False\n        If true, the parametric widget will be check for whether preview is enabled\n        everytime the parameter changed, and if preview is enabled, a preview window\n        is created to show the preview result.\n    auto_close : bool, default True\n        If true, close the parametric window after the function call.\n    auto_size : bool, default True\n        If true, the output window will be auto-sized to the size of the parametric\n        window.\n\n    Returns\n    -------\n    ParametricWindow[_W]\n        A wrapper containing the backend widget.\n    \"\"\"\n    if callback is None:\n        if not hasattr(widget, PWPN.GET_OUTPUT):\n            raise TypeError(\n                f\"Parametric widget must have `{PWPN.GET_OUTPUT}` method if \"\n                \"callback is not given.\"\n            )\n        callback = getattr(widget, PWPN.GET_OUTPUT)\n    main = self._main_window()\n    widget0 = main._process_parametric_widget(widget)\n    param_widget = ParametricWindow(widget0, callback, main_window=main)\n    param_widget._auto_close = auto_close\n    param_widget._result_as = result_as\n    param_widget._run_asynchronously = run_async\n    main._connect_parametric_widget_events(param_widget, widget0)\n    self._process_new_widget(param_widget, title, auto_size)\n    if preview:\n        if not (\n            hasattr(widget, PWPN.CONNECT_CHANGED_SIGNAL)\n            and hasattr(widget, PWPN.IS_PREVIEW_ENABLED)\n        ):\n            raise TypeError(\n                f\"If preview=True, the backend widget {widget!r} must implements \"\n                f\"methods {PWPN.CONNECT_CHANGED_SIGNAL!r} and \"\n                f\"{PWPN.IS_PREVIEW_ENABLED!r}\"\n            )\n        param_widget.params_changed.connect(param_widget._widget_preview_callback)\n    main._move_focus_to(widget0)\n    return param_widget\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea.add_vbox_layout","title":"<code>add_vbox_layout(*, margins=(0, 0, 0, 0), spacing=0)</code>","text":"<p>Add a vertical box layout to the tab area.</p> <p>Parameters:</p> Name Type Description Default <code>margins</code> <code>(int, int, int, int) or Margins</code> <p>Left, top, right and bottom margins of the layout.</p> <code>(0, 0, 0, 0)</code> <code>spacing</code> <code>int</code> <p>Spacing between the widgets.</p> <code>0</code> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>def add_vbox_layout(\n    self,\n    *,\n    margins: Margins[int] | tuple[int, int, int, int] = (0, 0, 0, 0),\n    spacing: int = 0,\n) -&gt; VBoxLayout:\n    \"\"\"Add a vertical box layout to the tab area.\n\n    Parameters\n    ----------\n    margins : (int, int, int, int) or Margins, optional\n        Left, top, right and bottom margins of the layout.\n    spacing : int, optional\n        Spacing between the widgets.\n    \"\"\"\n    main = self._main_window()\n    layout = VBoxLayout(main, margins=margins, spacing=spacing)\n    return self._add_layout_impl(layout)\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea.add_widget","title":"<code>add_widget(widget, *, title=None, auto_size=True)</code>","text":"<p>Add a widget to the sub window.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>QWidget</code> <p>Widget to add.</p> required <code>title</code> <code>str</code> <p>Title of the sub-window. If not given, its name will be automatically generated.</p> <code>None</code> <p>Returns:</p> Type Description <code>SubWindow</code> <p>A sub-window widget. The added widget is available by calling <code>widget</code> property.</p> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>def add_widget(\n    self,\n    widget: _W,\n    *,\n    title: str | None = None,\n    auto_size: bool = True,\n) -&gt; SubWindow[_W]:\n    \"\"\"Add a widget to the sub window.\n\n    Parameters\n    ----------\n    widget : QtW.QWidget\n        Widget to add.\n    title : str, optional\n        Title of the sub-window. If not given, its name will be automatically\n        generated.\n\n    Returns\n    -------\n    SubWindow\n        A sub-window widget. The added widget is available by calling\n        `widget` property.\n    \"\"\"\n    main = self._main_window()\n    sub_window = SubWindow(widget=widget, main_window=main)\n    self._process_new_widget(sub_window, title, auto_size)\n    main._move_focus_to(sub_window._split_interface_and_frontend()[1])\n    _checker.call_theme_changed_callback(widget, main._himena_main_window.theme)\n    return sub_window\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea.append","title":"<code>append(sub_window, title)</code>","text":"<p>Append a sub-window to the tab area.</p> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>def append(self, sub_window: SubWindow[_W], title: str) -&gt; None:\n    \"\"\"Append a sub-window to the tab area.\"\"\"\n    main = self._main_window()\n    interf, front = sub_window._split_interface_and_frontend()\n    front._himena_widget = sub_window\n    out = main.add_widget(front, self._tab_index(), title)\n    if hasattr(interf, \"control_widget\"):\n        main._set_control_widget(front, interf.control_widget())\n\n    main._connect_window_events(sub_window, out)\n    sub_window.title = title\n    sub_window.state_changed.connect(main._update_context)\n\n    main._set_current_tab_index(self._tab_index())\n    if main._himena_main_window._new_widget_behavior is NewWidgetBehavior.TAB:\n        main._set_window_state(\n            front,\n            WindowState.FULL,\n            main._himena_main_window._instructions.updated(animate=False),\n        )\n\n    main._move_focus_to(front)\n    sub_window._alive = True\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea.current","title":"<code>current(default=None)</code>","text":"<p>Get the current sub-window or a default value.</p> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>def current(self, default: _T = None) -&gt; SubWindow[_W] | _T:\n    \"\"\"Get the current sub-window or a default value.\"\"\"\n    idx = self.current_index\n    if idx is None:\n        return default\n    try:\n        return self[idx]\n    except IndexError:\n        return default\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea.read_file","title":"<code>read_file(file_path, plugin=None)</code>","text":"<p>Read local file(s) and open as a new sub-window in this tab.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str or Path or list of them</code> <p>Path(s) to the file to read. If a list is given, they will be read as a group, not as separate windows.</p> required <code>plugin</code> <code>str</code> <p>If given, reader provider will be searched with the plugin name. This value is usually the full import path to the reader provider function, such as <code>\"himena_builtins.io.default_reader_provider\"</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>SubWindow</code> <p>The sub-window instance that is constructed based on the return value of the reader.</p> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>def read_file(\n    self,\n    file_path: PathOrPaths,\n    plugin: str | None = None,\n) -&gt; SubWindow[_W]:\n    \"\"\"Read local file(s) and open as a new sub-window in this tab.\n\n    Parameters\n    ----------\n    file_path : str or Path or list of them\n        Path(s) to the file to read. If a list is given, they will be read as a\n        group, not as separate windows.\n    plugin : str, optional\n        If given, reader provider will be searched with the plugin name. This value\n        is usually the full import path to the reader provider function, such as\n        `\"himena_builtins.io.default_reader_provider\"`.\n\n    Returns\n    -------\n    SubWindow\n        The sub-window instance that is constructed based on the return value of\n        the reader.\n    \"\"\"\n    return self.read_files([file_path], plugin=plugin)[0]\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea.read_files","title":"<code>read_files(file_paths, plugin=None)</code>","text":"<p>Read multiple files and open as new sub-windows in this tab.</p> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>def read_files(\n    self,\n    file_paths: PathOrPaths,\n    plugin: str | None = None,\n) -&gt; list[SubWindow[_W]]:\n    \"\"\"Read multiple files and open as new sub-windows in this tab.\"\"\"\n    models = self._paths_to_models(file_paths, plugin=plugin)\n    out = [self.add_data_model(model) for model in models]\n    ui = self._main_window()._himena_main_window\n    if len(out) == 1:\n        ui.set_status_tip(f\"File opened: {out[0].title}\", duration=5)\n    elif len(out) &gt; 1:\n        _titles = \", \".join(w.title for w in out)\n        ui.set_status_tip(f\"File opened: {_titles}\", duration=5)\n    return out\n</code></pre>"},{"location":"api/widgets/#himena.widgets.TabArea.save_session","title":"<code>save_session(file_path, save_copies=False, allow_calculate=())</code>","text":"<p>Save the current session to a file.</p> Source code in <code>src\\himena\\widgets\\_widget_list.py</code> <pre><code>def save_session(\n    self,\n    file_path: str | Path,\n    save_copies: bool = False,\n    allow_calculate: Sequence[str] = (),\n) -&gt; None:\n    \"\"\"Save the current session to a file.\"\"\"\n    from himena.session import dump_tab_to_zip\n\n    dump_tab_to_zip(\n        self, file_path, save_copies=save_copies, allow_calculate=allow_calculate\n    )\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.current_instance","title":"<code>current_instance(name=None)</code>","text":"<p>Get current instance of the main window (raise if not exists).</p> Source code in <code>src\\himena\\widgets\\_initialize.py</code> <pre><code>def current_instance(name: str | None = None) -&gt; MainWindow[_W]:\n    \"\"\"Get current instance of the main window (raise if not exists).\"\"\"\n    if name is None:\n        name = next(iter(_APP_INSTANCES))\n    return _APP_INSTANCES[name][-1]\n</code></pre>"},{"location":"api/widgets/#himena.widgets.get_clipboard","title":"<code>get_clipboard()</code>","text":"<p>Get the current clipboard data.</p> Source code in <code>src\\himena\\widgets\\_functions.py</code> <pre><code>def get_clipboard() -&gt; ClipboardDataModel:\n    \"\"\"Get the current clipboard data.\"\"\"\n    return current_instance().clipboard\n</code></pre>"},{"location":"api/widgets/#himena.widgets.notify","title":"<code>notify(text, duration=5.0)</code>","text":"<p>Show a notification popup in the bottom right corner.</p> Source code in <code>src\\himena\\widgets\\_functions.py</code> <pre><code>def notify(text: str, duration: float = 5.0) -&gt; None:\n    \"\"\"Show a notification popup in the bottom right corner.\"\"\"\n    ins = current_instance()\n    ins._backend_main_window._show_notification(text, duration)\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.remove_instance","title":"<code>remove_instance(name, instance)</code>","text":"<p>Remove the instance from the list.</p> Source code in <code>src\\himena\\widgets\\_initialize.py</code> <pre><code>def remove_instance(name: str, instance: MainWindow[_W]) -&gt; None:\n    \"\"\"Remove the instance from the list.\"\"\"\n    if name in _APP_INSTANCES:\n        instances = _APP_INSTANCES[name]\n        if instance in instances:\n            instances.remove(instance)\n            instance.model_app.destroy(instance.model_app.name)\n        if not instances:\n            _APP_INSTANCES.pop(name, None)\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.set_clipboard","title":"<code>set_clipboard(model=None, **kwargs)</code>","text":"<pre><code>set_clipboard(*, text: str | None = None, html: str | None = None, image: Any | None = None, files: list[str | Path] | None = None, interanal_data: Any | None = None) -&gt; None\n</code></pre><pre><code>set_clipboard(model: ClipboardDataModel) -&gt; None\n</code></pre> <p>Set data to clipboard.</p> Source code in <code>src\\himena\\widgets\\_functions.py</code> <pre><code>def set_clipboard(model=None, **kwargs) -&gt; None:\n    \"\"\"Set data to clipboard.\"\"\"\n    ins = current_instance()\n    if model is not None:\n        if kwargs:\n            raise TypeError(\"Cannot specify both model and keyword arguments\")\n        ins.clipboard = model\n    else:\n        ins.set_clipboard(**kwargs)\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.set_current_instance","title":"<code>set_current_instance(name, instance)</code>","text":"<p>Set the instance as the current one.</p> Source code in <code>src\\himena\\widgets\\_initialize.py</code> <pre><code>def set_current_instance(name: str, instance: MainWindow[_W]) -&gt; None:\n    \"\"\"Set the instance as the current one.\"\"\"\n    if name not in _APP_INSTANCES:\n        _APP_INSTANCES[name] = []\n    elif instance in _APP_INSTANCES[name]:\n        _APP_INSTANCES[name].remove(instance)\n    _APP_INSTANCES[name].append(instance)\n    return None\n</code></pre>"},{"location":"api/widgets/#himena.widgets.set_status_tip","title":"<code>set_status_tip(text, duration=10.0)</code>","text":"<p>Set a status tip to the current main window for duration (second).</p> Source code in <code>src\\himena\\widgets\\_functions.py</code> <pre><code>def set_status_tip(text: str, duration: float = 10.0) -&gt; None:\n    \"\"\"Set a status tip to the current main window for duration (second).\"\"\"\n\n    with suppress(Exception):\n        ins = current_instance()\n        ins.set_status_tip(text, duration=duration)\n    return None\n</code></pre>"},{"location":"api/standards/model_meta/","title":"himena.standards.model_meta","text":""},{"location":"api/standards/model_meta/#himena.standards.model_meta.ArrayAxis","title":"<code>ArrayAxis</code>","text":"<p>An axis in an array.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the axis.</p> required <code>scale</code> <code>float</code> <p>Pixel scale of the axis.</p> <code>1.0</code> <code>origin</code> <code>float</code> <p>Offset of the axis.</p> <code>0.0</code> <code>unit</code> <code>str</code> <p>Unit of the axis spacing.</p> <code>''</code> <code>labels</code> <code>list[str]</code> <p>Category labels of the axis.</p> <code>&lt;dynamic&gt;</code> <code>default_label_format</code> <code>str</code> <p>Default format of the labels.</p> <code>'{:s}'</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class ArrayAxis(BaseModel):\n    \"\"\"An axis in an array.\"\"\"\n\n    name: str = Field(..., description=\"Name of the axis.\")\n    scale: float = Field(default=1.0, description=\"Pixel scale of the axis.\")\n    origin: float = Field(default=0.0, description=\"Offset of the axis.\")\n    unit: str = Field(\"\", description=\"Unit of the axis spacing.\")\n    labels: list[str] = Field(\n        default_factory=list, description=\"Category labels of the axis.\"\n    )\n    default_label_format: str = Field(\n        \"{:s}\", description=\"Default format of the labels.\"\n    )\n\n    @field_validator(\"name\", mode=\"before\")\n    def _name_to_str(cls, v):\n        return str(v)\n\n    def get_label(self, index: int) -&gt; str:\n        \"\"\"Return the label of the axis at the given index.\"\"\"\n        if index &lt; 0:\n            raise ValueError(\"Index must be non-negative.\")\n        try:\n            return self.labels[index]\n        except IndexError:\n            return self.default_label_format.format(str(index))\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ArrayAxis.get_label","title":"<code>get_label(index)</code>","text":"<p>Return the label of the axis at the given index.</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>def get_label(self, index: int) -&gt; str:\n    \"\"\"Return the label of the axis at the given index.\"\"\"\n    if index &lt; 0:\n        raise ValueError(\"Index must be non-negative.\")\n    try:\n        return self.labels[index]\n    except IndexError:\n        return self.default_label_format.format(str(index))\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ArrayMeta","title":"<code>ArrayMeta</code>","text":"<p>Preset for describing an array metadata.</p> <p>Parameters:</p> Name Type Description Default <code>axes</code> <code>list[ArrayAxis] | None</code> <p>Axes of the array.</p> <code>None</code> <code>current_indices</code> <code>tuple[Optional[int], ...] | None</code> <p>Current slice indices to render the array in GUI.</p> <code>None</code> <code>selections</code> <code>list[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Selections of the array. This attribute should be any sliceable objects that can passed to the backend array object.</p> <code>&lt;dynamic&gt;</code> <code>unit</code> <code>str | None</code> <p>Unit of the array values.</p> <code>None</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class ArrayMeta(BaseMetadata):\n    \"\"\"Preset for describing an array metadata.\"\"\"\n\n    axes: list[ArrayAxis] | None = Field(None, description=\"Axes of the array.\")\n    current_indices: tuple[int | None, ...] | None = Field(\n        None, description=\"Current slice indices to render the array in GUI.\"\n    )\n    selections: list[tuple[tuple[int, int], tuple[int, int]]] = Field(\n        default_factory=list,\n        description=\"Selections of the array. This attribute should be any sliceable \"\n        \"objects that can passed to the backend array object.\",\n    )\n    unit: str | None = Field(\n        None,\n        description=\"Unit of the array values.\",\n    )\n\n    def without_selections(self) -&gt; \"ArrayMeta\":\n        \"\"\"Make a copy of the metadata without selections.\"\"\"\n        return self.model_copy(update={\"selections\": []})\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ArrayMeta.without_selections","title":"<code>without_selections()</code>","text":"<p>Make a copy of the metadata without selections.</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>def without_selections(self) -&gt; \"ArrayMeta\":\n    \"\"\"Make a copy of the metadata without selections.\"\"\"\n    return self.model_copy(update={\"selections\": []})\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.BaseMetadata","title":"<code>BaseMetadata</code>","text":"<p>The base class for a model metadata.</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class BaseMetadata(BaseModel):\n    \"\"\"The base class for a model metadata.\"\"\"\n\n    @classmethod\n    def from_metadata(cls, dir_path: Path) -&gt; \"TextMeta\":\n        return cls.model_validate_json(dir_path.joinpath(_META_NAME).read_text())\n\n    def write_metadata(self, dir_path: Path) -&gt; None:\n        dir_path.joinpath(_META_NAME).write_text(self.model_dump_json())\n\n    def _class_info(self) -&gt; dict:\n        return {\"name\": self.__class__.__name__, \"module\": self.__class__.__module__}\n\n    def _repr_pretty_(self, p, cycle):\n        \"\"\"Pretty print the metadata.\"\"\"\n        lines = [f\"{self.__class__.__name__}(\"]\n        for key, value in self.__repr_args__():\n            lines.append(f\"  {key}={value!r},\")\n        lines.append(\")\")\n        p.text(\"\\n\".join(lines))\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.BaseMetadata._repr_pretty_","title":"<code>_repr_pretty_(p, cycle)</code>","text":"<p>Pretty print the metadata.</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>def _repr_pretty_(self, p, cycle):\n    \"\"\"Pretty print the metadata.\"\"\"\n    lines = [f\"{self.__class__.__name__}(\"]\n    for key, value in self.__repr_args__():\n        lines.append(f\"  {key}={value!r},\")\n    lines.append(\")\")\n    p.text(\"\\n\".join(lines))\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.DataFrameMeta","title":"<code>DataFrameMeta</code>","text":"<p>Preset for describing the metadata for a \"dataframe\" type.</p> <p>Parameters:</p> Name Type Description Default <code>current_position</code> <code>list[int] | None</code> <p>Current index position of (row, column) in the table.</p> <code>None</code> <code>selections</code> <code>list[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Table selections in the format of ((row_start, row_end), (col_start, col_end)), where the end index is exclusive, as is always the case for the Python indexing.</p> <code>&lt;dynamic&gt;</code> <code>separator</code> <code>str | None</code> <p>Separator of the table.</p> <code>None</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class DataFrameMeta(TableMeta):\n    \"\"\"Preset for describing the metadata for a \"dataframe\" type.\"\"\"\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.DataFramePlotMeta","title":"<code>DataFramePlotMeta</code>","text":"<p>Preset for describing the metadata for a \"dataframe.plot\" type.</p> <p>Parameters:</p> Name Type Description Default <code>current_position</code> <code>list[int] | None</code> <p>Current index position of (row, column) in the table.</p> <code>None</code> <code>selections</code> <code>list[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Table selections in the format of ((row_start, row_end), (col_start, col_end)), where the end index is exclusive, as is always the case for the Python indexing.</p> <code>&lt;dynamic&gt;</code> <code>separator</code> <code>str | None</code> <p>Separator of the table.</p> <code>None</code> <code>plot_type</code> <code>Literal[str, str]</code> <p>Type of the plot.</p> <code>'line'</code> <code>plot_color_cycle</code> <code>list[str] | None</code> <p>Color cycle of the plot.</p> <code>None</code> <code>plot_background_color</code> <code>str | None</code> <p>Background color of the plot.</p> <code>'#FFFFFF'</code> <code>rois</code> <code>RoiListModel | Callable[list, RoiListModel]</code> <p>Regions of interest.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class DataFramePlotMeta(DataFrameMeta):\n    \"\"\"Preset for describing the metadata for a \"dataframe.plot\" type.\"\"\"\n\n    model_config = {\"arbitrary_types_allowed\": True}\n\n    plot_type: Literal[\"line\", \"scatter\"] = Field(\n        \"line\", description=\"Type of the plot.\"\n    )\n    plot_color_cycle: list[str] | None = Field(\n        None, description=\"Color cycle of the plot.\"\n    )\n    plot_background_color: str | None = Field(\n        \"#FFFFFF\", description=\"Background color of the plot.\"\n    )\n    rois: roi.RoiListModel | Callable[[], roi.RoiListModel] = Field(\n        default_factory=roi.RoiListModel, description=\"Regions of interest.\"\n    )\n\n    @classmethod\n    def from_metadata(cls, dir_path: Path) -&gt; \"DataFramePlotMeta\":\n        self = cls.model_validate_json(dir_path.joinpath(_META_NAME).read_text())\n        if (rois_path := dir_path.joinpath(\"rois.roi.json\")).exists():\n            self.rois = roi.RoiListModel.model_validate_json(rois_path.read_text())\n        return self\n\n    def unwrap_rois(self) -&gt; roi.RoiListModel:\n        \"\"\"Unwrap the lazy-evaluation of the ROIs.\"\"\"\n        if isinstance(self.rois, roi.RoiListModel):\n            return self.rois\n        self.rois = self.rois()\n        return self.rois\n\n    def write_metadata(self, dir_path: Path) -&gt; None:\n        dir_path.joinpath(_META_NAME).write_text(self.model_dump_json(exclude={\"rois\"}))\n        rois = self.unwrap_rois()\n        if len(rois) &gt; 0:\n            with dir_path.joinpath(\"rois.roi.json\").open(\"w\") as f:\n                json.dump(rois.model_dump_typed(), f)\n        return None\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.DataFramePlotMeta.unwrap_rois","title":"<code>unwrap_rois()</code>","text":"<p>Unwrap the lazy-evaluation of the ROIs.</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>def unwrap_rois(self) -&gt; roi.RoiListModel:\n    \"\"\"Unwrap the lazy-evaluation of the ROIs.\"\"\"\n    if isinstance(self.rois, roi.RoiListModel):\n        return self.rois\n    self.rois = self.rois()\n    return self.rois\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.DictMeta","title":"<code>DictMeta</code>","text":"<p>Parameters:</p> Name Type Description Default <code>current_tab</code> <code>str | None</code> <p>Current tab name.</p> <code>None</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class DictMeta(BaseMetadata):\n    current_tab: str | None = Field(None, description=\"Current tab name.\")\n    child_meta: dict[str, BaseMetadata] = Field(\n        default_factory=dict, description=\"Metadata of the child models.\"\n    )\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.FunctionMeta","title":"<code>FunctionMeta</code>","text":"<p>Preset for describing the metadata for a \"function\" type.</p> <p>Parameters:</p> Name Type Description Default <code>source_code</code> <code>str | None</code> <p>Source code of the function.</p> <code>None</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class FunctionMeta(BaseMetadata):\n    \"\"\"Preset for describing the metadata for a \"function\" type.\"\"\"\n\n    source_code: str | None = Field(None, description=\"Source code of the function.\")\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageChannel","title":"<code>ImageChannel</code>","text":"<p>A channel in an image file.</p> <p>Parameters:</p> Name Type Description Default <code>colormap</code> <code>str | None</code> <p>Color map of the channel.</p> <code>None</code> <code>contrast_limits</code> <code>tuple[float, float] | None</code> <p>Contrast limits of the channel.</p> <code>None</code> <code>visible</code> <code>bool</code> <p>Whether the channel is visible.</p> <code>True</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class ImageChannel(BaseModel):\n    \"\"\"A channel in an image file.\"\"\"\n\n    colormap: str | None = Field(None, description=\"Color map of the channel.\")\n    contrast_limits: tuple[float, float] | None = Field(\n        None, description=\"Contrast limits of the channel.\"\n    )\n    visible: bool = Field(True, description=\"Whether the channel is visible.\")\n\n    @classmethod\n    def default(cls) -&gt; \"ImageChannel\":\n        \"\"\"Return a default channel (also used for mono-channel images).\"\"\"\n        return cls(name=None, colormap=\"gray\", contrast_limits=None)\n\n    def with_colormap(self, colormap: str) -&gt; \"ImageChannel\":\n        \"\"\"Set the colormap of the channel.\"\"\"\n        return self.model_copy(update={\"colormap\": colormap})\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageChannel.default","title":"<code>default()</code>  <code>classmethod</code>","text":"<p>Return a default channel (also used for mono-channel images).</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>@classmethod\ndef default(cls) -&gt; \"ImageChannel\":\n    \"\"\"Return a default channel (also used for mono-channel images).\"\"\"\n    return cls(name=None, colormap=\"gray\", contrast_limits=None)\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageChannel.with_colormap","title":"<code>with_colormap(colormap)</code>","text":"<p>Set the colormap of the channel.</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>def with_colormap(self, colormap: str) -&gt; \"ImageChannel\":\n    \"\"\"Set the colormap of the channel.\"\"\"\n    return self.model_copy(update={\"colormap\": colormap})\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageMeta","title":"<code>ImageMeta</code>","text":"<p>Preset for describing an image file metadata.</p> <p>Parameters:</p> Name Type Description Default <code>axes</code> <code>list[ArrayAxis] | None</code> <p>Axes of the array.</p> <code>None</code> <code>current_indices</code> <code>tuple[Optional[int], ...] | None</code> <p>Current slice indices to render the array in GUI.</p> <code>None</code> <code>selections</code> <code>list[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Selections of the array. This attribute should be any sliceable objects that can passed to the backend array object.</p> <code>&lt;dynamic&gt;</code> <code>unit</code> <code>str | None</code> <p>Unit of the array values.</p> <code>None</code> <code>channels</code> <code>list[ImageChannel]</code> <p>Channels of the image. At least one channel is required.</p> <code>[ImageChannel(colormap='gray', contrast_limits=None, visible=True)]</code> <code>channel_axis</code> <code>int | None</code> <p>Channel axis of the image.</p> <code>None</code> <code>is_rgb</code> <code>bool</code> <p>Whether the image is RGB.</p> <code>False</code> <code>current_roi</code> <code>RoiModel | None</code> <p>Current region of interest.</p> <code>None</code> <code>rois</code> <code>RoiListModel | Callable[list, RoiListModel]</code> <p>Regions of interest.</p> <code>&lt;dynamic&gt;</code> <code>interpolation</code> <code>str | None</code> <p>Interpolation method.</p> <code>None</code> <code>skip_image_rerendering</code> <code>bool</code> <p>Skip image rerendering when the model is passed to the <code>update_model</code> method. This field is only used when a function does not touch the image data itself.</p> <code>False</code> <code>more_metadata</code> <code>Any | None</code> <p>More metadata if exists.</p> <code>None</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class ImageMeta(ArrayMeta):\n    \"\"\"Preset for describing an image file metadata.\"\"\"\n\n    model_config = {\"arbitrary_types_allowed\": True}\n\n    channels: list[ImageChannel] = Field(\n        default_factory=lambda: [ImageChannel.default()],\n        description=\"Channels of the image. At least one channel is required.\",\n    )\n    channel_axis: int | None = Field(None, description=\"Channel axis of the image.\")\n    is_rgb: bool = Field(False, description=\"Whether the image is RGB.\")\n    current_roi: roi.RoiModel | None = Field(\n        None, description=\"Current region of interest.\"\n    )\n    rois: roi.RoiListModel | Callable[[], roi.RoiListModel] = Field(\n        default_factory=roi.RoiListModel, description=\"Regions of interest.\"\n    )\n    interpolation: str | None = Field(\n        default=None,\n        description=\"Interpolation method.\",\n    )\n    skip_image_rerendering: bool = Field(\n        default=False,\n        description=\"Skip image rerendering when the model is passed to the `update_model` method. This field is only used when a function does not touch the image data itself.\",\n    )\n    more_metadata: Any | None = Field(None, description=\"More metadata if exists.\")\n\n    def without_rois(self) -&gt; \"ImageMeta\":\n        return self.model_copy(update={\"rois\": roi.RoiListModel(), \"current_roi\": None})\n\n    def get_one_axis(self, index: int, value: int) -&gt; \"ImageMeta\":\n        \"\"\"Drop an axis by index for the array slicing arr[..., value, ...].\"\"\"\n        if index &lt; 0:\n            index += len(self.axes)\n        if index &lt; 0 or index &gt;= len(self.axes):\n            raise IndexError(f\"Invalid axis index: {index}.\")\n        axes = self.axes.copy()\n        del axes[index]\n        update = {\"axes\": axes, \"rois\": self.unwrap_rois().take_axis(index, value)}\n        if (caxis := self.channel_axis) == index:\n            update[\"channels\"] = [self.channels[value]]\n            update[\"channel_axis\"] = None\n            update[\"is_rgb\"] = False\n        elif caxis is not None:\n            update[\"channel_axis\"] = caxis - 1 if caxis &gt; index else caxis\n        return self.model_copy(update=update)\n\n    def unwrap_rois(self) -&gt; roi.RoiListModel:\n        \"\"\"Unwrap the lazy-evaluation of the ROIs.\"\"\"\n        if isinstance(self.rois, roi.RoiListModel):\n            return self.rois\n        self.rois = self.rois()\n        return self.rois\n\n    @field_validator(\"axes\", mode=\"before\")\n    def _strings_to_axes(cls, v, values: \"ValidationInfo\"):\n        if v is None:\n            return None\n        out: list[ArrayAxis] = []\n        for axis in v:\n            if isinstance(axis, str):\n                axis = ArrayAxis(name=axis)\n            elif isinstance(axis, dict):\n                axis = ArrayAxis(**axis)\n            out.append(axis)\n        return out\n\n    @field_validator(\"channel_axis\")\n    def _is_rgb_and_channels_exclusive(cls, v, values: \"ValidationInfo\"):\n        if values.data.get(\"is_rgb\") and v is not None:\n            raise ValueError(\"Channel axis must be None for RGB images.\")\n        if v is None and len(values.data[\"channels\"]) &gt; 1:\n            raise ValueError(\"Channel axis is required for multi-channel images.\")\n        return v\n\n    @field_validator(\"channels\")\n    def _channels_not_empty(cls, v, values: \"ValidationInfo\"):\n        if not v:\n            raise ValueError(\"At least one channel is required.\")\n        return v\n\n    @property\n    def contrast_limits(self) -&gt; tuple[float, float] | None:\n        \"\"\"Return the contrast limits of the first visible channel.\"\"\"\n        return self.channels[0].contrast_limits\n\n    @contrast_limits.setter\n    def contrast_limits(self, value: tuple[float, float] | None):\n        \"\"\"Set the contrast limits of all channels.\"\"\"\n        for channel in self.channels:\n            channel.contrast_limits = value\n\n    @property\n    def colormap(self) -&gt; Any | None:\n        \"\"\"Return the colormap of the first visible channel.\"\"\"\n        return self.channels[0].colormap\n\n    @colormap.setter\n    def colormap(self, value: Any | None):\n        \"\"\"Set the colormap of all channels.\"\"\"\n        for channel in self.channels:\n            channel.colormap = value\n\n    @classmethod\n    def from_metadata(cls, dir_path: Path) -&gt; \"ImageMeta\":\n        self = cls.model_validate_json(dir_path.joinpath(_META_NAME).read_text())\n        if (rois_path := dir_path.joinpath(\"rois.roi.json\")).exists():\n            self.rois = roi.RoiListModel.model_validate_json(rois_path.read_text())\n        if (cur_roi_path := dir_path.joinpath(\"current_roi.json\")).exists():\n            roi_js = json.loads(cur_roi_path.read_text())\n            self.current_roi = roi.RoiModel.construct(roi_js.pop(\"type\"), roi_js)\n        if (more_meta_path := dir_path.joinpath(\"more_meta.json\")).exists():\n            with more_meta_path.open() as f:\n                self.more_metadata = json.load(f)\n        return self\n\n    def write_metadata(self, dir_path: Path) -&gt; None:\n        dir_path.joinpath(_META_NAME).write_text(\n            self.model_dump_json(\n                exclude={\"current_roi\", \"rois\", \"labels\", \"more_metadata\"}\n            )\n        )\n        rois = self.unwrap_rois()\n        if cur_roi := self.current_roi:\n            with dir_path.joinpath(\"current_roi.json\").open(\"w\") as f:\n                json.dump(cur_roi.model_dump_typed(), f)\n        if len(rois) &gt; 0:\n            with dir_path.joinpath(\"rois.roi.json\").open(\"w\") as f:\n                json.dump(rois.model_dump_typed(), f)\n        if (more_metadata := self.more_metadata) is not None:\n            try:\n                with dir_path.joinpath(\"more_meta.json\").open(\"w\") as f:\n                    json.dump(more_metadata, f)\n            except Exception as e:\n                warnings.warn(\n                    f\"Failed to save `more_metadata`: {e}\",\n                    UserWarning,\n                    stacklevel=2,\n                )\n        return None\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageMeta.colormap","title":"<code>colormap</code>  <code>property</code> <code>writable</code>","text":"<p>Return the colormap of the first visible channel.</p>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageMeta.contrast_limits","title":"<code>contrast_limits</code>  <code>property</code> <code>writable</code>","text":"<p>Return the contrast limits of the first visible channel.</p>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageMeta.get_one_axis","title":"<code>get_one_axis(index, value)</code>","text":"<p>Drop an axis by index for the array slicing arr[..., value, ...].</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>def get_one_axis(self, index: int, value: int) -&gt; \"ImageMeta\":\n    \"\"\"Drop an axis by index for the array slicing arr[..., value, ...].\"\"\"\n    if index &lt; 0:\n        index += len(self.axes)\n    if index &lt; 0 or index &gt;= len(self.axes):\n        raise IndexError(f\"Invalid axis index: {index}.\")\n    axes = self.axes.copy()\n    del axes[index]\n    update = {\"axes\": axes, \"rois\": self.unwrap_rois().take_axis(index, value)}\n    if (caxis := self.channel_axis) == index:\n        update[\"channels\"] = [self.channels[value]]\n        update[\"channel_axis\"] = None\n        update[\"is_rgb\"] = False\n    elif caxis is not None:\n        update[\"channel_axis\"] = caxis - 1 if caxis &gt; index else caxis\n    return self.model_copy(update=update)\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageMeta.unwrap_rois","title":"<code>unwrap_rois()</code>","text":"<p>Unwrap the lazy-evaluation of the ROIs.</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>def unwrap_rois(self) -&gt; roi.RoiListModel:\n    \"\"\"Unwrap the lazy-evaluation of the ROIs.\"\"\"\n    if isinstance(self.rois, roi.RoiListModel):\n        return self.rois\n    self.rois = self.rois()\n    return self.rois\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageRoisMeta","title":"<code>ImageRoisMeta</code>","text":"<p>Preset for describing an image-rois metadata.</p> <p>Parameters:</p> Name Type Description Default <code>axes</code> <code>list[ArrayAxis] | None</code> <p>Axes of the ROIs.</p> <code>None</code> <code>selections</code> <code>list[int]</code> <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class ImageRoisMeta(BaseMetadata):\n    \"\"\"Preset for describing an image-rois metadata.\"\"\"\n\n    axes: list[ArrayAxis] | None = Field(None, description=\"Axes of the ROIs.\")\n    selections: list[int] = Field(default_factory=list)\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.TableMeta","title":"<code>TableMeta</code>","text":"<p>Preset for describing the metadata for a \"table\" type.</p> <p>Parameters:</p> Name Type Description Default <code>current_position</code> <code>list[int] | None</code> <p>Current index position of (row, column) in the table.</p> <code>None</code> <code>selections</code> <code>list[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Table selections in the format of ((row_start, row_end), (col_start, col_end)), where the end index is exclusive, as is always the case for the Python indexing.</p> <code>&lt;dynamic&gt;</code> <code>separator</code> <code>str | None</code> <p>Separator of the table.</p> <code>None</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class TableMeta(BaseMetadata):\n    \"\"\"Preset for describing the metadata for a \"table\" type.\"\"\"\n\n    current_position: list[int] | None = Field(\n        default=None,\n        description=\"Current index position of (row, column) in the table.\",\n    )\n    selections: list[tuple[tuple[int, int], tuple[int, int]]] = Field(\n        default_factory=list,\n        description=\"Table selections in the format of ((row_start, row_end), (col_start, col_end)), where the end index is exclusive, as is always the case for the Python indexing.\",\n    )\n    separator: str | None = Field(None, description=\"Separator of the table.\")\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.TextMeta","title":"<code>TextMeta</code>","text":"<p>Preset for describing the metadata for a \"text\" type.</p> <p>Parameters:</p> Name Type Description Default <code>language</code> <code>str | None</code> <p>Language of the text file.</p> <code>None</code> <code>spaces</code> <code>int</code> <p>Number of spaces for indentation.</p> <code>4</code> <code>selection</code> <code>tuple[int, int] | None</code> <p>Selection range.</p> <code>None</code> <code>font_family</code> <code>str | None</code> <p>Font family.</p> <code>None</code> <code>font_size</code> <code>float</code> <p>Font size.</p> <code>10</code> <code>encoding</code> <code>str | None</code> <p>Encoding of the text file.</p> <code>None</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class TextMeta(BaseMetadata):\n    \"\"\"Preset for describing the metadata for a \"text\" type.\"\"\"\n\n    language: str | None = Field(None, description=\"Language of the text file.\")\n    spaces: int = Field(4, description=\"Number of spaces for indentation.\")\n    selection: tuple[int, int] | None = Field(None, description=\"Selection range.\")\n    font_family: str | None = Field(None, description=\"Font family.\")\n    font_size: float = Field(10, description=\"Font size.\")\n    encoding: str | None = Field(None, description=\"Encoding of the text file.\")\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.read_metadata","title":"<code>read_metadata(dir_path)</code>","text":"<p>Read the metadata from a directory.</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>def read_metadata(dir_path: Path) -&gt; BaseMetadata:\n    \"\"\"Read the metadata from a directory.\"\"\"\n    with dir_path.joinpath(_CLASS_JSON).open(\"r\") as f:\n        class_js = json.load(f)\n    module = class_js[\"module\"]\n    name = class_js[\"name\"]\n    for sub in iter_subclasses(BaseMetadata):\n        if sub.__name__ == name and sub.__module__ == module:\n            metadata_class = sub\n            break\n    else:\n        raise ValueError(f\"Metadata class {name=}n {module=} not found.\")\n\n    return metadata_class.from_metadata(dir_path)\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.write_metadata","title":"<code>write_metadata(meta, dir_path)</code>","text":"<p>Write the metadata to a directory.</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>def write_metadata(meta: BaseMetadata, dir_path: Path) -&gt; None:\n    \"\"\"Write the metadata to a directory.\"\"\"\n    meta.write_metadata(dir_path)\n    with dir_path.joinpath(_CLASS_JSON).open(\"w\") as f:\n        json.dump(meta._class_info(), f)\n    return None\n</code></pre>"},{"location":"api/standards/roi/","title":"himena.standards.roi","text":"<p>Standard ROI (Region of Interest) classes for images.</p>"},{"location":"api/standards/roi/#himena.standards.roi.EllipseRoi","title":"<code>EllipseRoi</code>","text":"<p>ROI that represents an ellipse.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>x</code> <code>int | float</code> <p>X-coordinate of the center.</p> required <code>y</code> <code>int | float</code> <p>Y-coordinate of the center.</p> required <code>width</code> <code>int | float</code> <p>Diameter along the x-axis.</p> required <code>height</code> <code>int | float</code> <p>Diameter along the y-axis.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class EllipseRoi(Roi2D):\n    \"\"\"ROI that represents an ellipse.\"\"\"\n\n    x: Union[int, float] = Field(..., description=\"X-coordinate of the center.\")\n    y: Union[int, float] = Field(..., description=\"Y-coordinate of the center.\")\n    width: Union[int, float] = Field(..., description=\"Diameter along the x-axis.\")\n    height: Union[int, float] = Field(..., description=\"Diameter along the y-axis.\")\n\n    def center(self) -&gt; tuple[float, float]:\n        return self.x + self.width / 2, self.y + self.height / 2\n\n    def shifted(self, dx: float, dy: float) -&gt; EllipseRoi:\n        return self.model_copy(update={\"x\": self.x + dx, \"y\": self.y + dy})\n\n    def area(self) -&gt; float:\n        return math.pi * self.width * self.height / 4\n\n    def circumference(self) -&gt; float:\n        a, b = self.width / 2, self.height / 2\n        return math.pi * (3 * (a + b) - math.sqrt((3 * a + b) * (a + 3 * b)))\n\n    def eccentricity(self) -&gt; float:\n        a, b = self.width / 2, self.height / 2\n        return math.sqrt(1 - b**2 / a**2)\n\n    def bbox(self) -&gt; Rect[float]:\n        return Rect(self.x, self.y, self.width, self.height)\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        _yy, _xx = np.indices(shape[-2:])\n        cx, cy = self.center()\n        comp_a = (_yy - cy) / self.height * 2\n        comp_b = (_xx - cx) / self.width * 2\n        return comp_a**2 + comp_b**2 &lt;= 1\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.LineRoi","title":"<code>LineRoi</code>","text":"<p>A 2D line ROI.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>x1</code> <code>float</code> <p>X-coordinate of the first point.</p> required <code>y1</code> <code>float</code> <p>Y-coordinate of the first point.</p> required <code>x2</code> <code>float</code> <p>X-coordinate of the second point.</p> required <code>y2</code> <code>float</code> <p>Y-coordinate of the second point.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class LineRoi(Roi2D):\n    \"\"\"A 2D line ROI.\"\"\"\n\n    x1: float = Field(..., description=\"X-coordinate of the first point.\")\n    y1: float = Field(..., description=\"Y-coordinate of the first point.\")\n    x2: float = Field(..., description=\"X-coordinate of the second point.\")\n    y2: float = Field(..., description=\"Y-coordinate of the second point.\")\n\n    def shifted(self, dx: float, dy: float) -&gt; LineRoi:\n        return LineRoi(\n            x1=self.x1 + dx,\n            y1=self.y1 + dy,\n            x2=self.x2 + dx,\n            y2=self.y2 + dy,\n        )\n\n    def length(self) -&gt; float:\n        \"\"\"Length of the line.\"\"\"\n        return math.hypot(self.x2 - self.x1, self.y2 - self.y1)\n\n    def angle(self) -&gt; float:\n        \"\"\"Angle in degrees.\"\"\"\n        return math.degrees(math.atan2(self.y2 - self.y1, self.x2 - self.x1))\n\n    def radian(self) -&gt; float:\n        \"\"\"Angle in radians.\"\"\"\n        return math.atan2(self.y2 - self.y1, self.x2 - self.x1)\n\n    def linspace(self, num: int) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n        \"\"\"Return a tuple of x and y coordinates of np.linspace along the line.\"\"\"\n        return np.linspace(self.x1, self.x2, num), np.linspace(self.y1, self.y2, num)\n\n    def arange(\n        self, step: float = 1.0\n    ) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n        \"\"\"Return a tuple of x and y coordinates of np.arange along the line.\"\"\"\n        radian = self.radian()\n        num, rem = divmod(self.length(), step)\n        xrem = rem * math.cos(radian)\n        yrem = rem * math.sin(radian)\n        return (\n            np.linspace(self.x1, self.x2 - xrem, int(num) + 1),\n            np.linspace(self.y1, self.y2 - yrem, int(num) + 1),\n        )\n\n    def bbox(self) -&gt; Rect[float]:\n        xmin, xmax = min(self.x1, self.x2), max(self.x1, self.x2)\n        ymin, ymax = min(self.y1, self.y2), max(self.y1, self.y2)\n        return Rect(xmin, ymin, xmax - xmin, ymax - ymin)\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        arr = np.zeros(shape, dtype=bool)\n        xs, ys = self.linspace(int(self.length() + 1))\n        xs = xs.round().astype(int)\n        ys = ys.round().astype(int)\n        arr[ys, xs] = True\n        return arr\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.LineRoi.angle","title":"<code>angle()</code>","text":"<p>Angle in degrees.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def angle(self) -&gt; float:\n    \"\"\"Angle in degrees.\"\"\"\n    return math.degrees(math.atan2(self.y2 - self.y1, self.x2 - self.x1))\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.LineRoi.arange","title":"<code>arange(step=1.0)</code>","text":"<p>Return a tuple of x and y coordinates of np.arange along the line.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def arange(\n    self, step: float = 1.0\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n    \"\"\"Return a tuple of x and y coordinates of np.arange along the line.\"\"\"\n    radian = self.radian()\n    num, rem = divmod(self.length(), step)\n    xrem = rem * math.cos(radian)\n    yrem = rem * math.sin(radian)\n    return (\n        np.linspace(self.x1, self.x2 - xrem, int(num) + 1),\n        np.linspace(self.y1, self.y2 - yrem, int(num) + 1),\n    )\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.LineRoi.length","title":"<code>length()</code>","text":"<p>Length of the line.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def length(self) -&gt; float:\n    \"\"\"Length of the line.\"\"\"\n    return math.hypot(self.x2 - self.x1, self.y2 - self.y1)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.LineRoi.linspace","title":"<code>linspace(num)</code>","text":"<p>Return a tuple of x and y coordinates of np.linspace along the line.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def linspace(self, num: int) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n    \"\"\"Return a tuple of x and y coordinates of np.linspace along the line.\"\"\"\n    return np.linspace(self.x1, self.x2, num), np.linspace(self.y1, self.y2, num)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.LineRoi.radian","title":"<code>radian()</code>","text":"<p>Angle in radians.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def radian(self) -&gt; float:\n    \"\"\"Angle in radians.\"\"\"\n    return math.atan2(self.y2 - self.y1, self.x2 - self.x1)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.PointRoi2D","title":"<code>PointRoi2D</code>","text":"<p>ROI that represents a single point.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>x</code> <code>float</code> <p>X-coordinate of the point.</p> required <code>y</code> <code>float</code> <p>Y-coordinate of the point.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class PointRoi2D(Roi2D):\n    \"\"\"ROI that represents a single point.\"\"\"\n\n    x: float = Field(..., description=\"X-coordinate of the point.\")\n    y: float = Field(..., description=\"Y-coordinate of the point.\")\n\n    def shifted(self, dx: float, dy: float) -&gt; PointRoi2D:\n        return self.model_copy(update={\"x\": self.x + dx, \"y\": self.y + dy})\n\n    def bbox(self) -&gt; Rect[float]:\n        return Rect(self.x, self.y, 0, 0)\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        arr = np.zeros(shape, dtype=bool)\n        arr[..., int(round(self.y)), int(round(self.x))] = True\n        return arr\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.PointsRoi2D","title":"<code>PointsRoi2D</code>","text":"<p>ROI that represents a set of points.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>xs</code> <code>Any</code> <p>List of x-coordinates.</p> required <code>ys</code> <code>Any</code> <p>List of y-coordinates.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class PointsRoi2D(Roi2D):\n    \"\"\"ROI that represents a set of points.\"\"\"\n\n    xs: Any = Field(..., description=\"List of x-coordinates.\")\n    ys: Any = Field(..., description=\"List of y-coordinates.\")\n\n    @field_validator(\"xs\", \"ys\")\n    def _validate_np_arrays(cls, v) -&gt; NDArray[np.number]:\n        out = np.asarray(v)\n        if out.dtype.kind not in \"if\":\n            raise ValueError(\"Must be a numerical array.\")\n        return out\n\n    def shifted(self, dx: float, dy: float) -&gt; PointsRoi2D:\n        return self.model_copy(update={\"xs\": self.xs + dx, \"ys\": self.ys + dy})\n\n    def bbox(self) -&gt; Rect[float]:\n        xmin, xmax = np.min(self.xs), np.max(self.xs)\n        ymin, ymax = np.min(self.ys), np.max(self.ys)\n        return Rect(xmin, ymin, xmax - xmin, ymax - ymin)\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        arr = np.zeros(shape, dtype=bool)\n        xs = np.asarray(self.xs).round().astype(int)\n        ys = np.asarray(self.ys).round().astype(int)\n        arr[..., ys, xs] = True\n        return arr\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.PolygonRoi","title":"<code>PolygonRoi</code>","text":"<p>ROI that represents a closed polygon.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>xs</code> <code>Any</code> <p>List of x-coordinates.</p> required <code>ys</code> <code>Any</code> <p>List of y-coordinates.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class PolygonRoi(SegmentedLineRoi):\n    \"\"\"ROI that represents a closed polygon.\"\"\"\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        return _utils.polygon_mask(shape, np.column_stack((self.ys, self.xs)))\n\n    def area(self) -&gt; float:\n        dot_xy = np.dot(self.xs, np.roll(self.ys, 1))\n        dot_yx = np.dot(self.ys, np.roll(self.xs, 1))\n        return np.abs(dot_xy - dot_yx) / 2\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RectangleRoi","title":"<code>RectangleRoi</code>","text":"<p>ROI that represents a rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>x</code> <code>int | float</code> <p>X-coordinate of the top-left corner.</p> required <code>y</code> <code>int | float</code> <p>Y-coordinate of the top-left corner.</p> required <code>width</code> <code>int | float</code> <p>Width of the rectangle.</p> required <code>height</code> <code>int | float</code> <p>Height of the rectangle.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class RectangleRoi(Roi2D):\n    \"\"\"ROI that represents a rectangle.\"\"\"\n\n    x: Union[int, float] = Field(\n        ..., description=\"X-coordinate of the top-left corner.\"\n    )\n    y: Union[int, float] = Field(\n        ..., description=\"Y-coordinate of the top-left corner.\"\n    )\n    width: Union[int, float] = Field(..., description=\"Width of the rectangle.\")\n    height: Union[int, float] = Field(..., description=\"Height of the rectangle.\")\n\n    def shifted(self, dx: float, dy: float) -&gt; RectangleRoi:\n        \"\"\"Return a new rectangle shifted by the given amount.\"\"\"\n        return self.model_copy(update={\"x\": self.x + dx, \"y\": self.y + dy})\n\n    def area(self) -&gt; float:\n        \"\"\"Return the area of the rectangle.\"\"\"\n        return self.width * self.height\n\n    def bbox(self) -&gt; Rect[float]:\n        \"\"\"Return the bounding box of the rectangle.\"\"\"\n        return Rect(self.x, self.y, self.width, self.height)\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        bb = self.bbox().adjust_to_int(\"inner\")\n        arr = np.zeros(shape, dtype=bool)\n        arr[..., bb.top : bb.bottom, bb.left : bb.right] = True\n        return arr\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RectangleRoi.area","title":"<code>area()</code>","text":"<p>Return the area of the rectangle.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def area(self) -&gt; float:\n    \"\"\"Return the area of the rectangle.\"\"\"\n    return self.width * self.height\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RectangleRoi.bbox","title":"<code>bbox()</code>","text":"<p>Return the bounding box of the rectangle.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def bbox(self) -&gt; Rect[float]:\n    \"\"\"Return the bounding box of the rectangle.\"\"\"\n    return Rect(self.x, self.y, self.width, self.height)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RectangleRoi.shifted","title":"<code>shifted(dx, dy)</code>","text":"<p>Return a new rectangle shifted by the given amount.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def shifted(self, dx: float, dy: float) -&gt; RectangleRoi:\n    \"\"\"Return a new rectangle shifted by the given amount.\"\"\"\n    return self.model_copy(update={\"x\": self.x + dx, \"y\": self.y + dy})\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.Roi1D","title":"<code>Roi1D</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>class Roi1D(RoiModel):\n    def shifted(self, dx: float, dy: float) -&gt; Self:\n        \"\"\"Return a new 1D ROI translated by the given amount.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.Roi1D.shifted","title":"<code>shifted(dx, dy)</code>","text":"<p>Return a new 1D ROI translated by the given amount.</p> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>def shifted(self, dx: float, dy: float) -&gt; Self:\n    \"\"\"Return a new 1D ROI translated by the given amount.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.Roi2D","title":"<code>Roi2D</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>class Roi2D(RoiModel):\n    def bbox(self) -&gt; Rect[float]:\n        \"\"\"Return the bounding box of the ROI.\"\"\"\n        raise NotImplementedError\n\n    def shifted(self, dx: float, dy: float) -&gt; Self:\n        \"\"\"Return a new 2D ROI translated by the given amount.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.Roi2D.bbox","title":"<code>bbox()</code>","text":"<p>Return the bounding box of the ROI.</p> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>def bbox(self) -&gt; Rect[float]:\n    \"\"\"Return the bounding box of the ROI.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.Roi2D.shifted","title":"<code>shifted(dx, dy)</code>","text":"<p>Return a new 2D ROI translated by the given amount.</p> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>def shifted(self, dx: float, dy: float) -&gt; Self:\n    \"\"\"Return a new 2D ROI translated by the given amount.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.Roi3D","title":"<code>Roi3D</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>class Roi3D(RoiModel):\n    def shifted(self, dx: float, dy: float, dz: float) -&gt; Self:\n        \"\"\"Return a new 3D ROI translated by the given amount.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.Roi3D.shifted","title":"<code>shifted(dx, dy, dz)</code>","text":"<p>Return a new 3D ROI translated by the given amount.</p> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>def shifted(self, dx: float, dy: float, dz: float) -&gt; Self:\n    \"\"\"Return a new 3D ROI translated by the given amount.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RoiListModel","title":"<code>RoiListModel</code>  <code>dataclass</code>","text":"<p>List of ROIs, with useful methods.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>str</code> <code>array([], dtype=object)</code> <code>indices</code> <code>str</code> <code>array([], shape=(0, 0), dtype=int32)</code> <code>axis_names</code> <code>str</code> <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\standards\\roi\\_list.py</code> <pre><code>class RoiListModel(NDObjectCollection[RoiModel]):\n    \"\"\"List of ROIs, with useful methods.\"\"\"\n\n    def model_dump_typed(self) -&gt; dict:\n        return {\n            \"rois\": [roi.model_dump_typed() for roi in self],\n            \"indices\": self.indices.tolist() if self.indices is not None else None,\n            \"axis_names\": self.axis_names,\n        }\n\n    @classmethod\n    def construct(cls, dict_: dict) -&gt; RoiListModel:\n        \"\"\"Construct an instance from a dictionary.\"\"\"\n        rois = []\n        for roi_dict in dict_[\"rois\"]:\n            if not isinstance(roi_dict, dict):\n                raise ValueError(f\"Expected a dictionary for 'rois', got: {roi_dict!r}\")\n            roi_type = roi_dict.pop(\"type\")\n            roi = RoiModel.construct(roi_type, roi_dict)\n            rois.append(roi)\n        return cls(\n            items=rois,\n            indices=np.array(dict_[\"indices\"], dtype=np.int32),\n            axis_names=dict_[\"axis_names\"],\n        )\n\n    @classmethod\n    def model_validate_json(cls, text: str) -&gt; RoiListModel:\n        \"\"\"Validate the json string and return an instance.\"\"\"\n        js = json.loads(text)\n        return cls.construct(js)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RoiListModel.construct","title":"<code>construct(dict_)</code>  <code>classmethod</code>","text":"<p>Construct an instance from a dictionary.</p> Source code in <code>src\\himena\\standards\\roi\\_list.py</code> <pre><code>@classmethod\ndef construct(cls, dict_: dict) -&gt; RoiListModel:\n    \"\"\"Construct an instance from a dictionary.\"\"\"\n    rois = []\n    for roi_dict in dict_[\"rois\"]:\n        if not isinstance(roi_dict, dict):\n            raise ValueError(f\"Expected a dictionary for 'rois', got: {roi_dict!r}\")\n        roi_type = roi_dict.pop(\"type\")\n        roi = RoiModel.construct(roi_type, roi_dict)\n        rois.append(roi)\n    return cls(\n        items=rois,\n        indices=np.array(dict_[\"indices\"], dtype=np.int32),\n        axis_names=dict_[\"axis_names\"],\n    )\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RoiListModel.model_validate_json","title":"<code>model_validate_json(text)</code>  <code>classmethod</code>","text":"<p>Validate the json string and return an instance.</p> Source code in <code>src\\himena\\standards\\roi\\_list.py</code> <pre><code>@classmethod\ndef model_validate_json(cls, text: str) -&gt; RoiListModel:\n    \"\"\"Validate the json string and return an instance.\"\"\"\n    js = json.loads(text)\n    return cls.construct(js)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RoiModel","title":"<code>RoiModel</code>","text":"<p>Base class for ROIs (Region of Interest) in images.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>class RoiModel(BaseModel):\n    \"\"\"Base class for ROIs (Region of Interest) in images.\"\"\"\n\n    name: str | None = Field(None, description=\"Name of the ROI.\")\n\n    def model_dump_typed(self) -&gt; dict:\n        return {\n            \"type\": _strip_roi_suffix(type(self).__name__.lower()),\n            **self.model_dump(),\n        }\n\n    @classmethod\n    def construct(cls, typ: str, dict_: dict) -&gt; RoiModel:\n        \"\"\"Construct an instance from a dictionary.\"\"\"\n        model_type = pick_roi_model(typ)\n        return model_type.model_validate(dict_)\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        raise NotImplementedError\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RoiModel.construct","title":"<code>construct(typ, dict_)</code>  <code>classmethod</code>","text":"<p>Construct an instance from a dictionary.</p> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>@classmethod\ndef construct(cls, typ: str, dict_: dict) -&gt; RoiModel:\n    \"\"\"Construct an instance from a dictionary.\"\"\"\n    model_type = pick_roi_model(typ)\n    return model_type.model_validate(dict_)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RotatedEllipseRoi","title":"<code>RotatedEllipseRoi</code>","text":"<p>ROI that represents a rotated ellipse.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>start</code> <code>tuple[float, float]</code> <p>Coordinate of the start point.</p> required <code>end</code> <code>tuple[float, float]</code> <p>Coordinate of the end point.</p> required <code>width</code> <code>float</code> <p>Width of the ROI.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class RotatedEllipseRoi(RotatedRoi2D):\n    \"\"\"ROI that represents a rotated ellipse.\"\"\"\n\n    def area(self) -&gt; float:\n        return self.length() * self.width * math.pi / 4\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        _yy, _xx = np.indices(shape[-2:])\n        start_x, start_y = self.start\n        end_x, end_y = self.end\n        length = math.hypot(end_x - start_x, end_y - start_y)\n        cx, cy = (start_x + end_x) / 2, (start_y + end_y) / 2\n        angle = self.angle_radian()\n        comp_a = (_yy - cy) / length * 2\n        comp_b = (_xx - cx) / self.width * 2\n        comp_a, comp_b = (\n            comp_a * math.cos(angle) - comp_b * math.sin(angle),\n            comp_a * math.sin(angle) + comp_b * math.cos(angle),\n        )\n        return comp_a**2 + comp_b**2 &lt;= 1\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RotatedRectangleRoi","title":"<code>RotatedRectangleRoi</code>","text":"<p>ROI that represents a rotated rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>start</code> <code>tuple[float, float]</code> <p>Coordinate of the start point.</p> required <code>end</code> <code>tuple[float, float]</code> <p>Coordinate of the end point.</p> required <code>width</code> <code>float</code> <p>Width of the ROI.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class RotatedRectangleRoi(RotatedRoi2D):\n    \"\"\"ROI that represents a rotated rectangle.\"\"\"\n\n    def area(self) -&gt; float:\n        return self.length() * self.width\n\n    def bbox(self) -&gt; Rect[float]:\n        p00, p01, p11, p10 = self._get_vertices()\n        xmin = min(p00[0], p01[0], p10[0], p11[0])\n        xmax = max(p00[0], p01[0], p10[0], p11[0])\n        ymin = min(p00[1], p01[1], p10[1], p11[1])\n        ymax = max(p00[1], p01[1], p10[1], p11[1])\n        return Rect(xmin, ymin, xmax - xmin, ymax - ymin)\n\n    def _get_vertices(self):\n        start_x, start_y = self.start\n        end_x, end_y = self.end\n        vx, vy = self._get_vx_vy()\n        center = np.array([start_x + end_x, start_y + end_y]) / 2\n        p00 = center - vx / 2 - vy / 2\n        p01 = center - vx / 2 + vy / 2\n        p10 = center + vx / 2 - vy / 2\n        p11 = center + vx / 2 + vy / 2\n        return p00, p01, p11, p10\n\n    def to_mask(self, shape: tuple[int, ...]):\n        vertices = np.stack(self._get_vertices(), axis=0)\n        return _utils.polygon_mask(shape, vertices[:, ::-1])\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.SegmentedLineRoi","title":"<code>SegmentedLineRoi</code>","text":"<p>ROI that represents a segmented line.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>xs</code> <code>Any</code> <p>List of x-coordinates.</p> required <code>ys</code> <code>Any</code> <p>List of y-coordinates.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class SegmentedLineRoi(PointsRoi2D):\n    \"\"\"ROI that represents a segmented line.\"\"\"\n\n    def length(self) -&gt; np.float64:\n        return np.sum(self.lengths())\n\n    def lengths(self) -&gt; NDArray[np.float64]:\n        return np.hypot(np.diff(self.xs), np.diff(self.ys))\n\n    def linspace(self, num: int) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n        \"\"\"Return a tuple of x and y coordinates of np.linspace along the line.\"\"\"\n        tnots = np.cumsum(np.concatenate([[0], self.lengths()], dtype=np.float64))\n        teval = np.linspace(0, tnots[-1], num)\n        xi = np.interp(teval, tnots, self.xs)\n        yi = np.interp(teval, tnots, self.ys)\n        return xi, yi\n\n    def arange(\n        self, step: float = 1.0\n    ) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n        tnots = np.cumsum(np.concatenate([[0], self.lengths()], dtype=np.float64))\n        length = tnots[-1]\n        num, rem = divmod(length, step)\n        teval = np.linspace(0, length - rem, int(num + 1))\n        xi = np.interp(teval, tnots, self.xs)\n        yi = np.interp(teval, tnots, self.ys)\n        return xi, yi\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        arr = np.zeros(shape, dtype=bool)\n        xs, ys = self.linspace(int(math.ceil(self.length())))\n        xs = xs.round().astype(int)\n        ys = ys.round().astype(int)\n        arr[ys, xs] = True\n        return arr\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.SegmentedLineRoi.linspace","title":"<code>linspace(num)</code>","text":"<p>Return a tuple of x and y coordinates of np.linspace along the line.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def linspace(self, num: int) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n    \"\"\"Return a tuple of x and y coordinates of np.linspace along the line.\"\"\"\n    tnots = np.cumsum(np.concatenate([[0], self.lengths()], dtype=np.float64))\n    teval = np.linspace(0, tnots[-1], num)\n    xi = np.interp(teval, tnots, self.xs)\n    yi = np.interp(teval, tnots, self.ys)\n    return xi, yi\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.SplineRoi","title":"<code>SplineRoi</code>","text":"<p>ROI that represents a spline curve.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>degree</code> <code>int</code> <p>Degree of the spline curve.</p> <code>3</code> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class SplineRoi(Roi2D):\n    \"\"\"ROI that represents a spline curve.\"\"\"\n\n    degree: int = Field(3, description=\"Degree of the spline curve.\", ge=1)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.default_roi_label","title":"<code>default_roi_label(nth)</code>","text":"<p>Return a default label for the n-th ROI.</p> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>def default_roi_label(nth: int) -&gt; str:\n    \"\"\"Return a default label for the n-th ROI.\"\"\"\n    return f\"ROI-{nth}\"\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.pick_roi_model","title":"<code>pick_roi_model(typ)</code>  <code>cached</code>","text":"<p>Pick an ROI model class from the given type string</p> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>@cache\ndef pick_roi_model(typ: str) -&gt; type[RoiModel]:\n    \"\"\"Pick an ROI model class from the given type string\"\"\"\n    for sub in iter_subclasses(RoiModel):\n        if _strip_roi_suffix(sub.__name__.lower()) == typ:\n            return sub\n    raise ValueError(f\"Unknown ROI type: {typ!r}\")\n</code></pre>"},{"location":"dev/","title":"Developer's Guide","text":"<ul> <li>The WidgetDataModel Standard</li> <li>Plugin System</li> <li>Reader and Writer Functions</li> <li>Register Functions</li> <li>Register Widgets</li> <li>Register Dock Widgets</li> </ul>"},{"location":"dev/io_provider/","title":"Reader and Writer Functions","text":"<p>This section tells you how to extend the \"Open File(s) ...\" and \"Save ...\" actions so that it works for any file types you'd like to use in <code>himena</code>.</p>"},{"location":"dev/io_provider/#readerwriter-plugins","title":"Reader/Writer Plugins","text":"<p><code>himena</code> uses a <code>register_reader_plugin</code> and <code>register_writer_plugin</code> functions to register functions as reader/writer plugins.</p> <p>The example below is a simple text file reader plugin.</p> <pre><code>from pathlib import Path\nfrom himena.consts import StandardType\nfrom himena.plugins import register_reader_plugin\n\n@register_reader_plugin\ndef read_text(path: Path):\n    text_value = path.read_text()\n    return WidgetDataModel(\n        value=text_value,\n        type=StandardType.TEXT,\n        title=path.name,\n    )\n</code></pre> <p>Now <code>read_text</code> is a reader plugin object.</p> <pre><code>read_text\n</code></pre> Output<pre><code>&lt;ReaderPlugin read_text&gt;\n</code></pre> <p>This is not enough. When a path is given, <code>himena</code> does not know which reader function to be used. To let \".txt\" match the reader function we have just defined, use the <code>define_matcher</code> method. The matcher function must return <code>str</code> of data type if it can read the file, and <code>None</code> otherwise.</p> <pre><code>@read_text.define_matcher\ndef _(path: Path):\n    if path.suffix == \".txt\":\n        return StandardType.TEXT\n    return None\n</code></pre> Plugin priority <p>You can define the priority of the plugin to be chosen by passing the <code>priority</code> argument.</p> <pre><code>@register_reader_plugin(priority=10)\ndef read_text(path: Path):\n    ...\n</code></pre> <p><code>priority</code> is set to <code>100</code> by default, and the default providers have <code>priority=0</code>, which means that if you override the reader/writer for a file type, your provider will always be used.</p> <p>If <code>priority</code> is negative, the plugin will not be used unless users explicitly choose your plugin by \"Open File With ...\" command.</p> <p>Matcher must be fast</p> <p>The matcher function must not be a time-consuming function. When the application tries to open a file, all registered matcher functions are called.</p> <p>Similarly, you can define a writer plugin.</p> <pre><code>from pathlib import Path\nfrom himena.consts import StandardType\nfrom himena.plugins import register_writer_plugin\n\n@register_writer_plugin\ndef write_text(path: Path, model: WidgetDataModel):\n    return path.write_text(model.value)\n\n@write_text.define_matcher\ndef _(path: Path):\n    if path.suffix == \".txt\":\n        return True\n    return False\n</code></pre> <p>Unlike readers, matcher function returns <code>True</code> if the writer can write the file, and <code>False</code> otherwise.</p>"},{"location":"dev/plugin_system/","title":"Plugin System","text":"<p>To make your module discoverable by <code>himena</code>, you need to configure the <code>pyproject.toml</code> file.</p> <p>For example, if you have a module named <code>himena_my_plugin</code> and all the IO functions are registered in the <code>io</code> submodule, you need to add the following configuration to the <code>pyproject.toml</code> file.</p> <pre><code>[project.entry-points.\"himena.plugin\"]\n\"My Plugin IO\" = \"himena_my_plugin.io\"\n</code></pre> <p>The \"My Plugin IO\" is the display name of your plugin, and the value is the import path to the submodule.</p> <p>Note</p> <p>You don't have to create a new package just for the plugin. This single TOML field will allow your package integrated with <code>himena</code>.</p> <p>To improve the customizability of your plugin, your plugin should be well categorized. For example, IO, widgets, and data processing functions should be separated into different submodules.</p> <pre><code>[project.entry-points.\"himena.plugin\"]\n\"My Plugin IO\" = \"himena_my_plugin.io\"\n\"My Plugin Widgets\" = \"himena_my_plugin.widgets\"\n\"My Plugin Data Processing\" = \"himena_my_plugin.processing\"\n</code></pre>"},{"location":"dev/register_dock_widgets/","title":"Dock Widgets","text":"<p>Dock widgets can be added to the <code>himena</code> main window. Unlike the widgets that are supposed to be added to inside sub-windows, dock widgets don't need any <code>WidgetDataModel</code> to represent their state.</p> When to use dock widgets? <p>Unlike sub-windows, dock widgets are always visible to the user but don't have any internal data. Therefore, dock widgets are suitable for widgets that make data processing routines more efficiently. For example, dock widgets defined in <code>himena_builtins</code> include:</p> <ul> <li>Python interpreter console.</li> <li>File explorers.</li> <li>Command history viewer.</li> </ul>"},{"location":"dev/register_dock_widgets/#register-widget","title":"Register Widget","text":"<pre><code>from himena.plugin import register_dock_widget_action\n\nclass MyDockWidget:\n    ...  # implementation\n\n@register_dock_widget_action(\n    title=\"My Dock Widget\",  # (1)!\n    area=\"bottom\",  # (2)!\n    singleton=True,  # (3)!\n)\ndef my_dock_widget_action(ui):\n    # Construct and return the dock widget.\n    return MyDockWidget(ui)\n</code></pre> <ol> <li><code>title</code>: The title of the dock widget.</li> <li><code>area</code>: The area where the dock widget is placed. The value can be one of <code>\"left\"</code>,    <code>\"right\"</code>, <code>\"top\"</code>, or <code>\"bottom\"</code>.</li> <li><code>singleton</code>: If <code>True</code>, only one instance of the dock widget can be created.</li> </ol>"},{"location":"dev/register_dock_widgets/#plugin-configuration","title":"Plugin Configuration","text":"<p><code>himena</code> natively supports plugin configuration that can be defined by the developer and customized by the end user in the setting dialog.</p> <p>To define a plugin configuration, the simplest way is to define a data class.</p> <pre><code>from dataclasses import dataclass, field\n\n@dataclass\nclass MyPluginConfig:\n    some_default_value: str = field(default=\"Hello, world!\")\n</code></pre> <p>Pass the configuration instance to the <code>register_dock_widget_action</code> decorator</p> <pre><code>@register_dock_widget_action(\n    title=\"My Dock Widget\",\n    area=\"bottom\",\n    config=MyPluginConfig(),\n)\ndef my_dock_widget_action(ui):\n    ...\n</code></pre> <p>and define <code>update_configs</code> method in the dock widget class.</p> <pre><code>class MyDockWidget:\n    def update_configs(self, cfg: MyPluginConfig):\n        ... # update the widget state based on the configuration\n</code></pre> <p>This way, <code>MyPluginConfig</code> can be customized in the setting dialog and serialized to the user profile so that it is persistent across sessions.</p>"},{"location":"dev/register_functions/","title":"Register Functions","text":"<p>To process and analyze data, you need functions that convert an object into another. This section tells you how to register such functions so that you can run them on the GUI.</p>"},{"location":"dev/register_functions/#function-definition","title":"Function Definition","text":"<p>Basically, a function that processes data is a function that takes a <code>WidgetDataModel</code> object and returns another <code>WidgetDataModel</code> object. For example, the following function formats a non-indented json text data into an indented, pretty json text data.</p> <pre><code>from himena import WidgetDataModel\n\ndef format_json(model: WidgetDataModel) -&gt; WidgetDataModel:\n    value = json.dumps(json.loads(model.value), indent=4)\n    return WidgetDataModel(value=value, type=\"text\")\n</code></pre> <p>Because <code>himena</code> has its default widget for <code>\"text\"</code>-type model, this function can be readly used in the GUI. You can register this function using <code>register_function()</code> function.</p> <pre><code>from himena import WidgetDataModel\nfrom himena.plugins import register_function\nimport json\n\n@register_function(title=\"Format JSON Text\")\ndef format_json(model: WidgetDataModel) -&gt; WidgetDataModel:\n    value = json.dumps(json.loads(model.value), indent=4)\n    return WidgetDataModel(value=value, type=\"text\")\n</code></pre> <p>The registered function will be shown in the menu bar (under the \"Plugins\" menu by default) and the command palette. When this function is called from the GUI, currently active window will be converted into a <code>WidgetDataModel</code> object and passed to the function. The returned <code>WidgetDataModel</code> object will then be converted into another window.</p>"},{"location":"dev/register_functions/#dependency-injection-and-type-narrowing","title":"Dependency Injection and Type Narrowing","text":"<p><code>himena</code> uses <code>in_n_out</code> library to inject the application context into functions. For example, in the previous example, the <code>WidgetDataModel</code> of the current window is injected to the <code>model</code> argument of the <code>format_json</code> function. If no window is activated, the \"Format JSON Text\" menu is grayed out.</p> <p>Here are the list of type hints that will be provided to the argument.</p> <ul> <li><code>WidgetDataModel</code>: The current window's data.</li> <li><code>TabArea</code>: The current tab area.</li> <li><code>SubWindow</code>: The current window.</li> <li><code>MainWindow</code>: The main window.</li> <li><code>ClipboardDataModel</code>: The clipboard data.</li> </ul> <p>And here are the list of return types that will be processed.</p> <ul> <li><code>WidgetDataModel</code>: The returned value will be added to the current tab.</li> <li><code>list[WidgetDataModel]</code>: Each item will be added to the current tab.</li> <li><code>Parametric</code>: The returned function will be converted into a GUI for user input of   parameters (see here).</li> <li><code>ClipboardDataModel</code>: The returned data will overwrite the system clipboard.</li> <li><code>WidgetConstructor</code>: The returned function will be executed to add a new sub-window with the constructed widget.</li> <li><code>concurrent.Future</code>: The returned job will be executed asynchronously.</li> </ul> <p>A problem of the example above is that the <code>model</code> argument may contain any type of data (not only <code>\"text\"</code>-type data). To narrow the type of data, you can use the <code>types</code> argument of the <code>register_function()</code> decorator.</p> <pre><code>from himena.consts import StandardType\n\n@register_function(\n    title=\"Format JSON Text\",\n    types=[StandardType.TEXT],\n)\ndef format_json(model: WidgetDataModel) -&gt; WidgetDataModel:\n    ...\n</code></pre> <p>With this, the \"Format JSON Text\" menu will be enabled only if the current window is a widget for <code>\"text\"</code>-type data. Another benefit is that this command will be added to the model menu of the <code>\"text\"</code>-type widget.</p>"},{"location":"dev/register_functions/#place-the-function-in-any-places-in-menu-bar","title":"Place the Function in Any Places in Menu Bar","text":"<p>The place to put the function in the menu bar can be specified by the <code>menus</code> argument of the <code>register_function()</code> decorator. Each menu is specified by a \"/\"-separated string identifier. Following is an example that puts the function in the \"my-plugins &gt; my-text-plugins\" menu.</p> <pre><code>from himena import WidgetDataModel\nfrom himena.plugins import register_function\n\n@register_function(\n    title=\"Format JSON Text\",\n    types=[StandardType.TEXT],\n    menus=[\"my-plugins/my-text-plugins\"],\n)\ndef format_json(model: WidgetDataModel) -&gt; WidgetDataModel:\n    ...\n</code></pre> <p>To define how to display the menu title, you can use <code>configure_submenu()</code>.</p> <pre><code>from himena.plugins import configure_submenu\n\nconfigure_submenu(\"my-plugins\", title=\"My Plugins\")\nconfigure_submenu(\"my-plugins/my-text-plugins\", title=\"My Text Plugins\")\n</code></pre>"},{"location":"dev/register_functions/#parametric-functions","title":"Parametric Functions","text":"<p>Many functions require parameter inputs. It is very easy to implement a parametric function in Python: just add more arguments to the function. However, implementing parametric functions in GUI is usually tedious, as you need to create a specific widget for every function.</p> <p><code>himena</code> uses <code>magicgui</code> package to convert a function with parameters into a GUI widget based on the type hints of the function. Therefore, you can easily register a parametric function just by returning a function that takes parameters.</p> <p>To tell <code>himena</code> that the returned value should be converted into a GUI for user input of parameters, you need to annotate the returned value with the <code>Parametric</code> type.</p> <pre><code>from himena.plugins import register_function\nfrom himena.types import Parametric\n\n@register_function(\n    title=\"Format JSON Text\",\n    types=[StandardType.TEXT],\n)\ndef format_json(model: WidgetDataModel) -&gt; Parametric:\n    def run_format_json(indent: int = 4):\n        value = json.dumps(json.loads(model.value), indent=indent)\n        return WidgetDataModel(value=value, type=\"text\")\n    return run_format_json\n</code></pre> <p>The type-to-widget mapping is as follows:</p> <ul> <li><code>int</code>, <code>float</code>, <code>str</code>, <code>list[int]</code>, <code>list[float]</code> \u2192 Line edit with the   corresponding type.</li> <li><code>bool</code> \u2192 Toggle switch.</li> <li><code>enum.Enum</code>, <code>typing.Literal</code> \u2192 Combo box with the choices.</li> <li><code>pathlib.Path</code> \u2192 Entry with a file dialog button.</li> <li><code>tuple</code> \u2192 Group box with the corresponding types.</li> <li><code>WidgetDataModel</code>, <code>list[WidgetDataModel]</code>, <code>SubWindow</code>, <code>list[SubWindow]</code>   \u2192 Drop area that can drop other sub-windows to provide the corresponding data.</li> </ul>"},{"location":"dev/register_functions/#configure-parameter-input-window","title":"Configure Parameter Input Window","text":"<p>The parameter input window is automatically generated by <code>magicgui</code>. You can further customize its appearance by <code>configure_gui()</code> decorator.</p> <pre><code>from himena.plugins import register_function, configure_gui\nfrom himena.types import Parametric\n\n@register_function(\n    title=\"Format JSON Text\",\n    types=[StandardType.TEXT],\n)\ndef format_json(model: WidgetDataModel) -&gt; Parametric:\n    @configure_gui(\n        indent={\"label\": \"Indent in Spaces\", \"min\": 0, \"max\": 8},\n    )\n    def run_format_json(indent: int = 4):\n        value = json.dumps(json.loads(model.value), indent=indent)\n        return WidgetDataModel(value=value, type=\"text\")\n    return run_format_json\n</code></pre> <p><code>configure_gui</code> takes keyword arguments that are passed to the function it decorates, and use <code>dict</code> to configure the widget used for the parameter input.</p> <p>Here's some of the options you can use.</p> <ul> <li><code>label</code>: The label of the input field.</li> <li><code>value</code>: The default value.</li> <li><code>choices</code>: List of choices.</li> <li><code>widget_type</code>: Widget class to use. This option must be a <code>magicgui</code> ValueWidget.</li> <li><code>min</code>: The minimum value (if applicable).</li> <li><code>max</code>: The maximum value (if applicable).</li> </ul> <p>Note</p> <p>To avoid argument name collision, you can pass the options as a dict to <code>gui_options</code>.</p> <pre><code>@configure_gui(\n    gui_options={\"indent\": {\"label\": \"Indent in Spaces\", \"min\": 0, \"max\": 8}},\n)\ndef run_format_json(indent: int = 4):\n    value = json.dumps(json.loads(model.value), indent=indent)\n    return WidgetDataModel(value=value, type=\"text\")\n</code></pre>"},{"location":"dev/register_functions/#preview-function-outputs","title":"Preview Function Outputs","text":"<p>In some cases, parameters should be tuned based on the output of the function. For example in the case of the <code>format_json</code> function, the user may want to see the output so that the json string looks good. To add a \"preview\" toggle button to the parameter input window, just add the <code>preview</code> argument to the <code>configure_gui()</code> decorator.</p> <pre><code>@register_function(\n    title=\"Format JSON Text\",\n    types=[StandardType.TEXT],\n)\ndef format_json(model: WidgetDataModel) -&gt; Parametric:\n    @configure_gui(preview=True)\n    def run_format_json(indent: int = 4):\n        value = json.dumps(json.loads(model.value), indent=indent)\n        return WidgetDataModel(value=value, type=\"text\")\n    return run_format_json\n</code></pre> <p></p>"},{"location":"dev/register_functions/#asynchronous-execution","title":"Asynchronous Execution","text":"<p>It is also very easy to make your function asynchronous (make the application responsive during the execution). Just add the <code>run_async=True</code> argument to the <code>register_function()</code> decorator.</p> <pre><code>@register_function(\n    title=\"Format JSON Text\",\n    types=[StandardType.TEXT],\n    run_async=True,\n)\ndef format_json(model: WidgetDataModel) -&gt; Parametric:\n    def run_format_json(indent: int = 4):\n        value = json.dumps(json.loads(model.value), indent=indent)\n        return WidgetDataModel(value=value, type=\"text\")\n    return run_format_json\n</code></pre> <p>Do not update the GUI from an asynchronous function</p> <p>You should not update the GUI from an asynchronous function, because it can only be updated in the main thread.</p> This function crashes the application<pre><code>@register_function(\n    title=\"Add widget\",\n    run_async=True,\n)\ndef add_widget(ui: MainWindow):\n    ui.add_widget(QtW.QLabel(\"Hello, world!\"))\n</code></pre>"},{"location":"dev/register_widgets/","title":"Register Widgets","text":"<p>In this section, you will learn how to define and register custom widgets for specific data types.</p>"},{"location":"dev/register_widgets/#protocols","title":"Protocols","text":"<p>To avoid the potential dangers of metaclass collision and method collision, <code>himena</code> do not use a super class to define plugin widgets. Instead, your plugin widgets have to implement protocols (methods with correct name and arguments) to enable the communication between the plugin and the main application.</p> Check misspelling <p>Because the plugin widgets do not inherit anything like plugin classes, you have to be careful not to misspell the method name. To check if the method name is correct, you can decorate the protocol methods with <code>validate_protocol</code> decorator.</p> <pre><code>from himena.plugins import validate_protocol\n\nclass MyWidget:\n    @validate_protocol\n    def udpate_model(self, model):  # misspelled, raises error\n        ...\n</code></pre> <p>All the protocols are optional except for <code>update_model</code>, which is called when the widget is constructed from a data model. To make the plugin better, you should implement as many protocols as possible.</p>"},{"location":"dev/register_widgets/#compatibility-with-widgetdatamodel-standard","title":"Compatibility with <code>WidgetDataModel</code> Standard","text":"<p>To make the plugin widgets compatible with the <code>WidgetDataModel</code> standard that is used everywhere in <code>himena</code>, you have to implement the following protocols:</p> <ul> <li><code>update_model(self, model: WidgetDataModel) -&gt; None</code>: Update the widget state based   on the model.</li> <li><code>to_model(self) -&gt; WidgetDataModel</code>: Return the model that represents the current   state of the widget.</li> <li><code>model_type(self) -&gt; str</code>: Return the type of the model that the widget uses. Model   type is frequently checked in many occasions, so you should implement this method if   <code>to_model</code> is computationally expensive.</li> <li><code>update_value(self, value: Any) -&gt; None</code>: Update the widget state based on the value   without changing the states that are described by the <code>metadata</code> field of the   <code>WidgetDataModel</code>. This method is preferentially called by the <code>update_value</code> method   of <code>SubWindow</code> class.</li> </ul>"},{"location":"dev/register_widgets/#control-widget","title":"Control Widget","text":"<p>The control widget is a widget that is added to the tool bar of the main window to make the sub-window area tidy. This widget can be defined by implementing the following protocol.</p> <ul> <li><code>control_widget(self) -&gt; &lt;backend widget type&gt;</code>: Construct and return the control   widget.</li> </ul> <p>The return type must be interpretable by the backend GUI library. For example, if your plugin widget is implemented using <code>Qt</code>, the return type should be a <code>QWidget</code> object as well.</p>"},{"location":"dev/register_widgets/#use-wrapper-class","title":"Use Wrapper Class","text":"<p>Python already has a lot of libraries that wrap other GUI libraries to provide better interface. In <code>himena</code>, you can directly use these wrapper classes and implement all the protocols on the wrapper class. In this case, you will have to tell where the backend widget is located, which can be done by implementing the following protocol.</p> <ul> <li><code>native_widget(self) -&gt; &lt;backend widget type&gt;</code>: Return the backend widget that is   wrapped by the wrapper class.</li> </ul>"},{"location":"dev/register_widgets/#widget-interactivity","title":"Widget Interactivity","text":"<p>Widgets can be interactively modified by the user. To change the interactivity, or to programmatically mark the widget as modified, you can implement the following protocols.</p> <ul> <li><code>is_editable(self) -&gt; bool</code>: Return whether the widget is editable or not.</li> <li><code>set_editable(self, editable: bool) -&gt; None</code>: Set the widget editable or not.</li> <li><code>is_modified(self) -&gt; bool</code>: Return whether the underlying data is modified or not.</li> <li><code>set_modified(self, modified: bool) -&gt; None</code>: Set the modified state of the widget.</li> </ul>"},{"location":"dev/register_widgets/#response-to-the-gui-events","title":"Response to the GUI Events","text":"<p>Sometimes your widget needs to catch the GUI events to update the widget state.</p> <ul> <li><code>theme_changed_callback(self, theme: Theme) -&gt; None</code>: Called when the theme of the   application is changed. The <code>Theme</code> object is a data class that contains the color   theme of the application.</li> <li><code>widget_added_callback(self) -&gt; None</code>: Called when the sub-window containing this   widget is added to the main window.</li> <li><code>widget_activated_callback(self) -&gt; None</code>: Called when the sub-window containing this   widget is activated (clicked or focus).</li> <li><code>widget_closed_callback(self) -&gt; None</code>:  Called when the sub-window containing this   widget is closed.</li> <li><code>widget_resized_callback(self, old_size: Size, new_size: Size) -&gt; None</code>: Called when   the sub-window containing this widget is resized from the old size to a new size.   <code>Size</code> is a tuple like object with <code>width</code> and <code>height</code> fields.</li> </ul>"},{"location":"dev/register_widgets/#drag-and-drop","title":"Drag and Drop","text":"<p>Drag-and-drop operation is handled using <code>DragDataModel</code>.</p> <ul> <li><code>dropped_callback(self, model: DragDataModel) -&gt; None</code>: Callback method when an item   is dropped on the widget.</li> <li><code>allowed_drop_types(self) -&gt; list[str]</code>: List of types that the widget accepts.</li> </ul>"},{"location":"dev/register_widgets/#widget-appearance","title":"Widget Appearance","text":"<ul> <li><code>size_hint(self) -&gt; tuple[int, int]</code>: Return the size hint of the widget. This method   is called when the widget is added to the main window.</li> <li><code>default_title(self) -&gt; str</code>: Return the default title of the widget. This method is   called when the widget is added to the main window without specifying the title.</li> </ul>"},{"location":"dev/register_widgets/#register-the-widget","title":"Register the Widget","text":"<pre><code>from qtpy import QtWidgets as QtW\nfrom himena.plugins import validate_protocol\n\nclass MyWidget(QtW.QTextEdit):\n    def __init__(self):\n        super().__init__()\n\n    @validate_protocol\n    def update_model(self, model):\n        assert model.type == \"text\"\n        self.setPlainText(model.value)\n\n    @validate_protocol\n    def to_model(self):\n        return WidgetDataModel(value=self.toPlainText(), type=\"text\")\n\n    @validate_protocol\n    def size_hint(self):\n        return 400, 300\n</code></pre> <p>Once you have implemented the protocols like above, you can register the widget class using the <code>register_widget_class</code> function.</p> <pre><code>from himena import StandardType\nfrom himena.plugins import register_widget_class\n\nregister_widget_class(StandardType.TEXT, MyWidget)\n</code></pre> <p>The first argument is the type of the data the widget class is supposed to handle. Whenever the application is requested to add a data model of that type, this widget will be constructed like below:</p> <pre><code>widget = MyWidget()\nwidget.update_model(model)\n</code></pre> <p>and added to the main window inside a sub-window.</p> Register function instead of class <p>Because what is done here is just calling the constructor of the widget class, the object registered by the <code>register_widget_class</code> function does not have to be a class. You can also register a function that returns the widget object.</p> <pre><code>def create_widget():\n    return MyWidget()\n\nregister_widget_class(StandardType.TEXT, create_widget)\n</code></pre> <p>This is useful when you want to execute the file that defines the widget class lazily, in order to reduce the startup time of the application.</p>"},{"location":"dev/widget_data_model/","title":"The WidgetDataModel Standard","text":"<p>All the widgets in <code>himena</code> are built on the <code>WidgetDataModel</code> standard. A <code>WidgetDataModel</code> is a Python object that represents a value of any type, tagged with some additional information of how to interpret the value in GUI. For example, a text data \"xyz\" read from a txt file can be written as follows:</p> <pre><code>WidgetDataModel(value=\"abc\", type=\"text\")\n</code></pre> <p>All the \"data-embedded\" widgets in <code>himena</code> implements <code>update_model()</code> method to update the state of the widget from a <code>WidgetDataModel</code> object, and <code>to_model()</code> method to dump the state of the widget to a <code>WidgetDataModel</code> object.</p> <pre><code>class TextViewer:\n    def __init__(self):\n        # some GUI-specific initialization ...\n\n    def update_model(self, model: WidgetDataModel):\n        self.set_text(model.value)\n\n    def to_model(self) -&gt; WidgetDataModel:\n        return WidgetDataModel(value=self.get_text(), type=\"text\")\n</code></pre> <p>This widget can be registered as a widget that represents a <code>\"text\"</code>-type data using <code>register_widget_class()</code> function.</p> <pre><code>from himena.plugins import register_widget_class\n\nregister_widget_class(\"text\", widget_class=TextViewer)\n</code></pre> <p>The <code>WidgetDataModel</code> standard makes the different part of development very clear-cut.</p> <ul> <li> <p>Reader function is a GUI-independent function that reads a file and returns   a <code>WidgetDataModel</code>.</p> Example reader function<pre><code>def read_txt(file_path: Path) -&gt; WidgetDataModel:\n    text_value = file_path.read_text()\n    return WidgetDataModel(value=text_value, type=\"text\")\n</code></pre> </li> </ul> <p>A proper widget class will be automatically selected based on the <code>type</code> field, and   updated based on the returned model using <code>update_model()</code> method.</p> <ul> <li> <p>Writer function is a GUI-independent function that writes a <code>WidgetDataModel</code>   to a file.</p> Example writer function<pre><code>def write_text(file_path: Path, model: WidgetDataModel):\n    file_path.write_text(model.value)\n</code></pre> </li> </ul> <p>A widget will be automatically converted to a model using <code>to_model()</code> method before   calling this writer function.</p> <ul> <li> <p>Any function for data processing or analysis is also GUI-independent functions   that just convert a <code>WidgetDataModel</code> into another.</p> Example data processing function<pre><code>def to_upper(model: WidgetDataModel) -&gt; WidgetDataModel:\n    assert isinstance(model.value, str)\n    return WidgetDataModel(value=model.value.upper(), type=\"text\")\n</code></pre> <p>A widget will be automatically converted to a model using <code>to_model()</code> method before calling this function, and sent back to the GUI as another widget created based on the returned model.</p> </li> </ul>"},{"location":"dev/widget_data_model/#choosing-the-type","title":"Choosing the Type","text":"<p>You can use any string for <code>type</code> field, but to make your widget interpretable for the <code>himena</code> built-in functions and probably for other plugins, you may want to use the <code>StandardType</code>.</p> <pre><code>from himena.const import StandardType\n\nStandardType.TEXT  # \"text\"\nStandardType.TABLE  # \"table\"\nStandardType.ARRAY  # \"array\"\nStandardType.IMAGE  # \"array.image\"\n</code></pre> <p>You can use \".\" to separate the type into a hierarchy. For example, the standard type <code>\"array.image\"</code> is used for an image data, but it is under \"array\" type because all the image data are essentially arrays. A benefit of this subtyping is that all the \"array\" functions can be applied to the \"array.image\" data.</p>"},{"location":"dev/widget_data_model/#more-specifications","title":"More Specifications","text":"<p>You can set other fields of <code>WidgetDataModel</code> to provide more details of how to convert the data to a widget.</p> <pre><code>WidgetDataModel(\n    value=\"abc\",\n    type=\"text\",\n    title=\"My Text\"  # title of the widget\n    extension_default=\".txt\",  # default file extension in the save dialog\n    extensions=[\".txt\", \".md\"]  # allowed file extensions in the save dialog\n)\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<ul> <li>Basics</li> <li>Tab/Window Manipluation</li> <li>Workflows</li> <li>Sessions</li> <li>Built-in Widgets</li> </ul>"},{"location":"usage/basics/","title":"Basics","text":""},{"location":"usage/basics/#application-design","title":"Application Design","text":""},{"location":"usage/basics/#appearance","title":"Appearance","text":"<p><code>himena</code> GUI has components as shown below.</p> <p></p> <ol> <li>Menu bar. It contains most of the registered commands in the application.</li> <li>Tool bar. It contains frequently used commands.</li> <li>Tab bar. Each tab contains a sub-window area where widgets are placed.</li> <li>Sub-window. Each sub-window contains a widget as its content.</li> <li>Control widget. Each widget has a control widget that provides functionalities    specific to the widget.</li> <li>Python interpreter console. A console widget that can execute Python codes.</li> <li>Dock widget. Widgets docked to the main window. These widgets are usually added    by plugins. The Python interpreter console is also a dock widget.</li> <li>Status bar. It shows a simple one-line message.</li> </ol>"},{"location":"usage/basics/#sub-window","title":"Sub-window","text":"<p>A sub-window usually represents a single data, such as a <code>ndarray</code> or <code>DataFrame</code>. Therefore, data processing is usually done by taking sub-windows as input and output.</p> <p></p> <p>Each data is wrapped by a <code>WidgetDataModel</code> object, which is tagged with some GUI-related information, so that the application understands how to display, save and track the data.</p> <pre><code>from himena.types import WidgetDataModel\nimport numpy as np\n\ndata = WidgetDataModel(value=np.arange(10), type=\"array\", title=\"my array\")  # (1)!\nwin = ui.add_data_model(data)  # (2)!\n</code></pre> <ol> <li>Create a WidgetDataModel object. To interpret the data as an array, set the <code>type</code>     attribute to <code>\"array\"</code>.</li> <li>Add the data model to the application as a sub-window.</li> </ol> <p>More simply, you can just call <code>ui.add_object</code> method to directly add an object to the application.</p> <pre><code>win = ui.add_object(np.arange(10), type=\"array\", title=\"my array\")\n</code></pre> <p>Data can be retrieved from the sub-window by calling <code>to_model</code> method.</p> <pre><code>win.to_model()\n</code></pre> Output<pre><code>WidgetDataModel(value=&lt;ndarray&gt;, source=None, type='array', title='my array')\n</code></pre> <p><pre><code>win.to_model().value\n</code></pre> Output<pre><code>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n</code></pre></p>"},{"location":"usage/basics/#opening-and-saving-files","title":"Opening and Saving Files","text":""},{"location":"usage/basics/#new-file","title":"New file","text":"<p>Press Ctrl+N and you will see a command palette pops up. This palette contains many commands that are related to adding new items to the application. This category includes</p> <ul> <li>Empty window, such as a text or table.</li> <li>Opening a sample data.</li> </ul> <p>For example, the \"New Text\" command will add a new text editor sub-window to the current tab.</p>"},{"location":"usage/basics/#open-files-from-the-local-disk","title":"Open files from the local disk","text":"<p><code>himena</code> supports several ways to open files from the local disk.</p>"},{"location":"usage/basics/#1-open-a-file-as-a-sub-window","title":"(1) Open a file as a sub-window","text":"<p>This is the most common way to open a file. You can open a file from \"File\" menu press Ctrl+O or drag-and-drop the file to the application.</p> <p>Whether the file can be opened, and the opened data can be displayed as a widget, depends on the plugins installed in the application profile.</p>"},{"location":"usage/basics/#2-open-a-folder-as-a-sub-window","title":"(2) Open a folder as a sub-window","text":"<p>A special built-in widget can display a list of <code>WidgetDataModel</code> as a nested widget. Opening a folder will read the folder contents as a collection like below. This command is available from the \"File\" menu, Ctrl+K \u2192 Ctrl+O, or drag-and-drop the folder to the application.</p> <p></p>"},{"location":"usage/basics/#3-open-a-group-of-files-as-a-sub-window","title":"(3) Open a group of files as a sub-window","text":"<p>Instead of opening a folder, you can open a group of files as a sub-window.</p>"},{"location":"usage/basics/#saving-files-to-the-local-disk","title":"Saving files to the local disk","text":"<p>You can save the data in the sub-window to the local disk by selecting \"File\" \u2192 \"Save\" or pressing Ctrl+S. Whether the data can be saved to the specified format depends on the plugins installed in the application profile.</p>"},{"location":"usage/basics/#data-processing","title":"Data Processing","text":"<p>Most of the functions for data processing are defined by functions that take a <code>WidgetDataModel</code> as the input and another <code>WidgetDataModel</code> as the output.</p> <p>For example, starting from the data below</p> <pre><code>df = {\"a\": [2, 3, 5], \"b\": [1.3, 3.2, -1.2]}\nui.add_object(df, type=\"dataframe\")\n</code></pre> <p>you can find \"Filter DataFrame ...\" command in the model menu. This command will open a window for the parameter input, filter the data frame and show the result in a new sub-window.</p> <p></p> <p>The history of the data processing is recorded to the <code>WidgetDataModel</code>. You can open it from the \"Show workflow graph\" command in the window menu.</p> <p></p> <p>Note</p> <p>The workflow is just a <code>WidgetDataModel</code> with type <code>\"workflow\"</code>. Therefore, this operation is just a data processing like any other operations.</p>"},{"location":"usage/basics/#adding-custom-widgets","title":"Adding Custom Widgets","text":"<p>Currently, <code>himena</code> supports <code>Qt</code> as its GUI backend. Any <code>Qt</code> widgets can be added to the application using <code>add_widget()</code> method.</p> <pre><code>from qtpy.QtWidgets import QLabel\n\nlabel = QLabel(\"Hello, world!\")\nui.add_widget(label, title=\"My Label\")\n</code></pre> <p>If you have a widget wrapper of a <code>Qt</code> widget, it can also be added by defining the <code>native_widget()</code> interface method.</p> <pre><code>class MyLabel:\n    def __init__(self, text):\n        self._qt_label = QLabel(text)\n\n    def native_widget(self):\n        return self._qt_label\n\nlabel = MyLabel(\"Hello, world!\")\nui.add_widget(label, title=\"My Label Wrapper\")\n</code></pre> Using <code>magicgui</code> <p>Because <code>himena</code> depends on <code>magicgui</code> in many places, <code>magicgui</code> widgets can be directly used without the <code>native_widget()</code> method.</p> <pre><code>from magicgui import magicgui\n\n@magicgui\ndef my_func(x: int, y: str):\n    print(x, y)\n\nui.add_widget(my_func, title=\"My MagicGUI\")\n</code></pre> <p>This rule also applies to the widget plugin system. See here for more details.</p>"},{"location":"usage/builtin_dock_widgets/","title":"Built-in Dock Widgets","text":"<p>The dock widget actions implemented in <code>himena_builtins</code> are listed under the \"Tools &gt; Dock Widgets\" menu.</p>"},{"location":"usage/builtin_dock_widgets/#python-interpreter-console","title":"Python Interpreter Console","text":"<p>This widget is for running Python code interactively. The widget uses the Jupyter QtConsole widget.</p>"},{"location":"usage/builtin_dock_widgets/#file-explorer","title":"File Explorer","text":"<p>This widget is for browsing files and directories.</p>"},{"location":"usage/builtin_dock_widgets/#remote-file-explorer-ssh","title":"Remote File Explorer (SSH)","text":"<p>This widget makes it easier to browse files on a remote server using <code>ssh</code>, and transfer files between the local and remote machines using <code>scp</code>.</p>"},{"location":"usage/builtin_dock_widgets/#command-history","title":"Command History","text":"<p>This widget shows the history of commands that have been executed since the start of the application.</p>"},{"location":"usage/builtin_dock_widgets/#output-widget","title":"Output Widget","text":"<p>This widget shows the standard output stream and the logging messages.</p>"},{"location":"usage/builtin_widgets/","title":"Built-in Widgets","text":"<p><code>himena</code> provides <code>himena_builtins</code> plugin package for the most basic widgets for the widely-used data types.</p> <p>Note</p> <p>The detailed description of the widgets are available by running the \"what is this widget?\" command in the window menu.</p>"},{"location":"usage/builtin_widgets/#text-editor-widget","title":"Text Editor Widget","text":"<p>A text widget is simply used to display and edit a text data. Optionally, you can specify the language of the text data to enable syntax highlighting.</p> Specification widget class <code>himena_builtins.qt.widgets.QTextEdit</code> model type <code>\"text\"</code> (<code>StandardType.TEXT</code>) data type <code>str</code> <p></p> <pre><code>from himena.standards.model_meta import TextMeta\n\nui.add_object(\n    \"import numpy as np\\n\\nprint(np.arange(10))\",\n    type=\"text\",\n    title=\"Text Data\",\n    metadata=TextMeta(language=\"python\")\n)\n</code></pre>"},{"location":"usage/builtin_widgets/#spreadsheet-widget","title":"Spreadsheet Widget","text":"<p>A spreadsheet widget is used to display and edit a table data. All the items are stored as strings, so that numerical operations on this widget are not very efficient.</p> Specification widget class <code>himena_builtins.qt.widgets.QSpreadsheet</code> model type <code>\"table\"</code> (<code>StandardType.TABLE</code>) data type <code>ndarray</code> of string dtype <p></p> <pre><code>ui.add_object(\n    [[\"key\", \"value\"], [\"name\", \"Alice\"], [\"age\", 20]],\n    type=\"table\",\n    title=\"Table Data\"\n)\n</code></pre>"},{"location":"usage/builtin_widgets/#dataframe-viewer-widget","title":"DataFrame Viewer Widget","text":"<p>A dataframe viewer widget is used to display a dataframe-like object. Unlike a spreadsheet widget, the underlying data is structured and typed.</p> Specification widget class <code>himena_builtins.qt.widgets.QDataFrameView</code> model type <code>\"dataframe\"</code> (<code>StandardType.DATAFRAME</code>) data type dataframe-like object, such as <code>dict[str, list]</code>, <code>pandas.DataFrame</code>, <code>polars.DataFrame</code> <p></p> <pre><code>ui.add_object(\n    {\n        \"kind\": [\"cat\", \"dog\", \"cat\", \"dog\", \"cat\", \"dog\", \"cat\", \"dog\"],\n        \"size\": [\"small\", \"small\", \"large\", \"large\", \"small\", \"small\", \"large\", \"large\"],\n        \"weight\": [8, 10, 12, 15, 11, 13, 9, 14],\n    },\n    type=\"dataframe\",\n    title=\"DataFrame Data\",\n)\n</code></pre>"},{"location":"usage/builtin_widgets/#dataframe-plot-widget","title":"DataFrame Plot Widget","text":"<p>A dataframe plot widget contains a dataframe-like object just like a dataframe viewer, but the data is supposed to be plotted. Therefore, non-numerical columns are not allowed.</p> Specification widget class <code>himena_builtins.qt.widgets.QDataFramePlotView</code> model type <code>\"dataframe.plot\"</code> (<code>StandardType.DATAFRAME_PLOT</code>) data type dataframe-like object, such as <code>dict[str, list]</code>, <code>pandas.DataFrame</code>, <code>polars.DataFrame</code> <p></p> <pre><code>import numpy as np\n\nx = np.linspace(0, 10, 100)\nui.add_object(\n    {\n        \"x\": x,\n        \"y1\": np.sin(x),\n        \"y2\": np.cos(x) * 1.4,\n    },\n    type=\"dataframe.plot\",\n    title=\"DataFrame Plot Data\",\n)\n</code></pre>"},{"location":"usage/builtin_widgets/#array-viewer-widget","title":"Array Viewer Widget","text":"<p>This widget is used to display a multi-dimensional array-like object.</p> Specification widget class <code>himena_builtins.qt.widgets.QArrayView</code> model type <code>\"array\"</code> (<code>StandardType.ARRAY</code>) data type array-like object, such as <code>numpy.ndarray</code>, <code>xarray.DataArray</code>, <code>dask.Array</code> <p></p> <pre><code>import numpy as np\n\nrng = np.random.default_rng(10)\nui.add_object(\n    rng.normal(size=(3, 40, 18)),\n    type=\"array\",\n    title=\"Array Data\",\n)\n</code></pre>"},{"location":"usage/builtin_widgets/#image-viewer-widget","title":"Image Viewer Widget","text":"<p>This widget is for displaying a multi-dimensional image data. Its design is inspired by ImageJ.</p> <p>2D image slices are displayed in the main view, and the current slice can be changed by the slider. This widget also supports drawing ROIs (Region of Interests) on the image. RGB, complex value and multi-channel images are also supported.</p> Specification widget class <code>himena_builtins.qt.widgets.QImageView</code> model type <code>\"array.image\"</code> (<code>StandardType.IMAGE</code>) data type array-like object, such as <code>numpy.ndarray</code>, <code>xarray.DataArray</code>, <code>dask.Array</code> <p></p> <pre><code>import numpy as np\nfrom himena.standards.model_meta import ImageMeta\nfrom himena.standards import roi\n\nyy, xx = np.indices((100, 100))\nimage_stack = []\nfor n in range(3):\n    image_stack.append(np.sin(xx / 10 * n) * np.cos(yy / 8))\nimage = np.stack(image_stack, axis=0)\nui.add_object(\n    image,\n    type=\"array.image\",\n    metadata=ImageMeta(\n        current_roi=roi.RectangleRoi(x=11, y=28, width=32, height=20),\n        axes=[\"z\", \"y\", \"x\"],\n    ),\n    title=\"Image Data\",\n)\n</code></pre>"},{"location":"usage/builtin_widgets/#plot-widget","title":"Plot Widget","text":"<p><code>himena_builtins</code> provides two types of plot widgets. One is based on the standard plot model defined in <code>himena.standards.plotting</code>, and the other is a direct display of <code>matplotlib.Figure</code> object.</p> <p>The standard plot model is designed to be inter-changeable between different plotting libraries, and <code>himena</code> can understand the underlying structure. Therefore, the plotted data can be read, modified and written consistently. On the other hand, the <code>matplotlib</code> figure object supports the complete set of <code>matplotlib</code> functions.</p> himena standard plot modelmatplotlib figure object Specification widget class <code>himena_builtins.qt.widgets.QModelMatplotlibCanvas</code> model type <code>\"plot\"</code> (<code>StandardType.PLOT</code>) data type the standard plot model defined in <code>himena.standards.plotting</code> Specification widget class <code>himena_builtins.qt.widgets.QMatplotlibCanvas</code> model type <code>\"matplotlib-figure\"</code> (<code>StandardType.MPL_FIGURE</code>) data type <code>matplotlib.Figure</code> object <p></p> <pre><code>from himena.standards import plotting as hplt\nimport numpy as np\n\nfig = hplt.figure()\nx = np.linspace(-1, 1, 100)\nfig.plot(x, np.cos(x) * np.exp(-x**2 / 2))\nxsparse = np.linspace(-1, 1, 9)\nfig.scatter(xsparse, np.cos(xsparse) * np.exp(-xsparse**2 / 2), color=\"black\")\nui.add_object(fig, type=\"plot\", title=\"Plot Data\")\n</code></pre>"},{"location":"usage/builtin_widgets/#excel-like-widget","title":"Excel-like Widget","text":"<p>This widget is used to display and edit a dictionary of tables, which is technically an Excel-like data. The keys of the dictionary are the names of the sheets.</p> Specification widget class <code>himena_builtins.qt.widgets.QExcelEdit</code> model type <code>\"dict.table\"</code> (<code>StandardType.EXCEL</code>) data type <code>dict[str, ndarray]</code> <p></p> <pre><code>ui.add_object(\n    {\n        \"format\": [[\"key\", \"value\"], [\"name\", \"\"], [\"age\", \"\"]],\n        \"example\": [[\"key\", \"value\"], [\"name\", \"Alice\"], [\"age\", 20]],\n    },\n    type=\"dict.table\",\n    title=\"Excel-like Data\",\n)\n</code></pre>"},{"location":"usage/builtin_widgets/#function-widget","title":"Function Widget","text":"<p>This widget contains a non-editable function object. A function widget is usually created by the \"Compile as a function\" command on a text data. A function widget is useful to be used as callable inputs for custom commands, such as <code>scipy.optimization</code> or <code>scipy.integrate</code>.</p> Specification widget class <code>himena_builtins.qt.widgets.QFunctionEdit</code> model type <code>\"function\"</code> (<code>StandardType.FUNCTION</code>) data type callable object <p></p> <pre><code>from himena.standards.model_meta import FunctionMeta\n\ndef example_function(x):\n    return x**2\n\nui.add_object(\n    example_function,\n    type=\"function\",\n    metadata=FunctionMeta(source_code=\"def example_function(x):\\n    return x**2\"),\n    title=\"Function Data\",\n)\n</code></pre>"},{"location":"usage/builtin_widgets/#image-roi-widget","title":"Image ROI Widget","text":"Specification widget class <code>himena_builtins.qt.widgets.QImageRoiView</code> model type <code>\"rois\"</code> (<code>StandardType.ROIS</code>) data type standard roi-list model in <code>himena.standards.roi</code> <pre><code>from himena.standards import roi\n\nroilist = roi.RoiListModel(\n    items=[\n        roi.LineRoi(x1=4, y1=6, x2=18, y2=-1, name=\"line-roi-0\"),\n        roi.LineRoi(x1=12, y1=14, x2=6, y2=4, name=\"line-roi-1\"),\n        roi.RectangleRoi(x=6, y=7, width=8, height=8.4, name=\"rect-roi-0\"),\n        roi.LineRoi(x1=4, y1=6, x2=18, y2=-1, name=\"line-roi-2\"),\n        roi.EllipseRoi(x=6, y=7, width=8, height=8.4, name=\"ellipse-roi-0\")\n    ]\n)\nwin = ui.add_object(roilist, type=\"rois\")\nwin.size = (200, 180)\n</code></pre>"},{"location":"usage/builtin_widgets/#jupyter-notebook-widget","title":"Jupyter Notebook Widget","text":"<p>Text contents in \"ipynb\" format can be rendered in a way similar to Jupyter Notebook.</p> Specification widget class <code>himena_builtins.qt.widgets.QIpynbEdit</code> model type <code>\"text.json.ipynb\"</code> (<code>StandardType.IPYNB</code>) data type <code>str</code> in the IPython Notebook format <p></p> <pre><code>text = r\"\"\"{\n \"cells\": [\n  {\n   \"cell_type\": \"code\",\n   \"outputs\": [{\"name\": \"stdout\", \"output_type\": \"stream\", \"text\": [\"[0 1 2 3 4]\\n\"]}],\n   \"source\": [\"import numpy as np\\n\", \"import matplotlib.pyplot as plt\\n\", \"\\n\", \"print(np.arange(5))\"]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"source\": [\"# Test\\n\", \"\\n\", \"- this is a test file.\"]\n  }\n ]\n}\"\"\"\n\nui.add_object(text, type=\"text.json.ipynb\", title=\"Jupyter Notebook\")\n</code></pre>"},{"location":"usage/builtin_widgets/#model-stack-widget","title":"Model Stack Widget","text":"Specification widget class <code>himena_builtins.qt.widgets.QModelStack</code> model type <code>\"models\"</code> (<code>StandardType.MODELS</code>) data type <code>list[WidgetDataModel]</code> <pre><code>from himena.types import WidgetDataModel\n\nmodels = [\n    WidgetDataModel(value=[[\"key\", \"value\"], [\"name\", \"Alice\"], [\"age\", 20]], type=\"table\", title=\"Table Data\"),\n    WidgetDataModel(value=\"\", type=\"text\", title=\"Text Data\"),\n]\nwin = ui.add_object(models, type=\"models\", title=\"Model Stack\")\nwin.size = (300, 250)\n</code></pre>"},{"location":"usage/builtin_widgets/#workflow-viewer-widget","title":"Workflow Viewer Widget","text":"<p>The workflow of each data can be visualized in this widget.</p> Specification widget class <code>himena_builtins.qt.widgets.QWorkflowView</code> model type <code>\"workflow\"</code> (<code>StandardType.WORKFLOW</code>) data type <code>himena.workflows.Workflow</code> object <p></p> <pre><code>ui.exec_action(\"builtins:new-text\")\nwin = ui.add_object(ui.current_model.workflow, type=\"workflow\", title=\"Workflow\")\nwin.size = (280, 120)\n</code></pre>"},{"location":"usage/customization/","title":"Customization","text":"<p>You can customize your application profile from the setting dialog.</p>"},{"location":"usage/customization/#application-color-theme","title":"Application Color Theme","text":"<p>There are several color themes available. You can select your favorite one from the appearance tab in the setting dialog.</p> <p></p> <p>Alternatively, you can programmatically change it by setting the <code>theme</code> property.</p> <pre><code>ui.theme = \"dark-green\"\n</code></pre>"},{"location":"usage/customization/#plugin-settings","title":"Plugin Settings","text":"<p>Many settings that are not directly relevant to the data itself (such as the table cell size, default SSH host name, etc.) can be configured from the plugin settings tab.</p> <p></p>"},{"location":"usage/sessions/","title":"Sessions","text":"<p>A \"session\" is a collection of tabs and sub-windows that can be saved and restored later. Sessions are useful for saving your work halfway through. To save a session, click the \"File &gt; Session &gt; Save Session ...\" menu.</p> <p>Warning</p> <p>The session feature is still experimental. The saved session may not be restored in some special cases. Please make sure you will not lose your important data.</p>"},{"location":"usage/sessions/#how-it-works","title":"How it Works","text":"<p>A session is saved as a zip file suffixed with <code>.session.zip</code>. The zip file contains:</p> <ol> <li>Files that are created by writing all the sub-windows in the application.</li> <li>Directories that store the metadata of each data model.</li> <li><code>session.yaml</code> that describes many other states of the application.</li> </ol> <p>Therefore, if any of the windows cannot be written to files, saving the session will lose the data (or use workflows to avoid this).</p>"},{"location":"usage/sessions/#make-the-session-portable","title":"Make the Session Portable","text":"<p>By default, sub-windows directly read from the local disk will not be saved again in the session. However, this session will not work on another computer, or if the file is moved. To make the session portable, you have to check the \"save copies\" option.</p>"},{"location":"usage/sessions/#restore-subset-of-the-data-by-workflows","title":"Restore Subset of the Data by Workflows","text":"<p>Instead of saving a sub-window as a file, you can restore the data by rerunning all the commands needed to generate the data. As each sub-window has its workflow to track its history, this workflow can be used to restore the data.</p> <p>In the \"Save Session ...\" dialog, you can select which command you will allow to be executed. All the sub-windows that are directly generated by the command will not be saved as files, but will be restored by the workflow when the session is loaded.</p> <p>For example, if you have the following workflow:</p> <pre><code>        Command A         Command B\nData X0 --------&gt; Data X1 --------&gt; Data X2\n</code></pre> <p>and allowed Command A to be executed, the session will save Data X2 if \"Save copies\" is not checked, or will save Data X0 and Data X2 if \"Save copies\" is checked.</p>"},{"location":"usage/tab_and_window/","title":"Tab/Window Manipulation","text":"<p>The current state of the application can be programmatically manipulated by using the <code>ui</code> variable.</p>"},{"location":"usage/tab_and_window/#access-to-tabs-and-sub-windows","title":"Access to Tabs and Sub-windows","text":"<p><code>ui.tabs</code> is a list-like object that contains all the tab. Each tab is another list-like objects that contains all the sub-windows.</p> <pre><code>ui.tabs[0]  # The first tab\n</code></pre> Output Example<pre><code>TabArea([\n  SubWindow(title='Table-0', widget=&lt;builtins:QSpreadsheet&gt;),\n  SubWindow(title='Untitled-1', widget=&lt;builtins:QTextEdit&gt;),\n])\n</code></pre> <pre><code>ui.tabs[0][1]  # The second sub-window in the first tab\n</code></pre> Output Example<pre><code>SubWindow(title='Untitled-1', widget=&lt;builtins:QTextEdit&gt;)\n</code></pre> <p>Currently active tab and sub-window can be accessed by followign properties.</p> <pre><code>ui.tabs.current_index  # The index of the current tab\nui.tabs[0].current_index  # The index of the current sub-window in the first tab\n</code></pre> <p>There are shortcut methods to access the current sub-window and the underlying data model.</p> <pre><code>ui.current_window  # The current sub-window\nui.current_model  # The current data model\n</code></pre>"},{"location":"usage/tab_and_window/#adding-tabs-and-sub-windows","title":"Adding Tabs and Sub-windows","text":"<p>To add a new tab, use <code>ui.add_tab</code> method.</p> <pre><code>ui.add_tab()\nui.add_tab(\"new tab\")  # with a name\n</code></pre> <p>Both main window and tab have methods of same names to add sub-windows. If a method is called from the main window, sub-window will be added to the current tab, or to a new tab if there is no tab.</p> <pre><code># add array object to the current tab\nui.add_object(np.arange(10), type=\"array\", title=\"my array\")\n\n# add array object to the current tab\nui.tabs[0].add_object(np.arange(10), type=\"array\", title=\"my array\")\n\n# add a WidgetDataModel\nmodel = WidgetDataModel(value=np.arange(10), type=\"array\", title=\"my array\")\nui.add_data_model(model)\n\n# add any Qt widget\nfrom qtpy.QtWidgets import QPushButton\n\nui.add_widget(QPushButton(\"Hello, world!\"))\n\n# add a magicgui widget\nfrom magicgui.widgets import LineEdit\n\nui.add_widget(LineEdit(name=\"name\", value=\"abc\"))\n</code></pre>"},{"location":"usage/tab_and_window/#access-to-the-data-and-widget-states","title":"Access to the Data and Widget States","text":"<p>Basically, the sub-window state is obtained by a <code>WidgetDataModel</code>.</p> <pre><code>win = ui.add_object(\"abc\", type=\"text\", title=\"my text\")\nmodel = win.to_model()  # a WidgetDataModel object\nmodel.value  # \"abc\"\n</code></pre> <p>Widget states that are irrelevant to the data are stored in the <code>metadata</code> property. The type of this property differs between data types, and sometimes, widget types. In the case of text data, <code>TextMeta</code> object is used in the default widget.</p> <pre><code>model.metadata\n</code></pre> Output<pre><code>TextMeta(\n  language='Plain Text',\n  spaces=4,\n  selection=(0, 0),\n  font_family='Consolas',\n  font_size=10.0,\n  encoding='utf-8',\n)\n</code></pre>"},{"location":"usage/tab_and_window/#closing-tabs-and-sub-windows","title":"Closing Tabs and Sub-windows","text":"<p>Tabs and sub-windows can be closed by <code>del</code>.</p> <pre><code>del ui.tabs[0]  # close the first tab\ndel ui.tabs[0][1]  # close the second sub-window in the first tab\n</code></pre>"},{"location":"usage/tab_and_window/#resizing-and-moving-sub-windows","title":"Resizing and Moving Sub-windows","text":"<p>The geometry of sub-windows can be manipulated by <code>rect</code> property. It is a tuple-like <code>WindowRect</code> object.</p> <pre><code>win = ui.current_window\nwin.rect\n</code></pre> Output<pre><code>WindowRect(left=28, top=28, width=400, height=300)\n</code></pre> <pre><code>win.rect = (50, 40, 200, 250)  # update the geometry\n</code></pre> <p>If you only want to resize the window, you can use the <code>size</code> property.</p> <pre><code>win.size = (200, 250)  # resize the window\n</code></pre> <p>To move sub-windows, <code>WindowRect</code> object has several useful methods.</p> <ul> <li><code>move_top_left</code></li> <li><code>move_top_right</code></li> <li><code>move_bottom_left</code></li> <li><code>move_bottom_right</code></li> </ul> <p>These methods return a new <code>WindowRect</code> object with updated positions.</p> <pre><code>win.rect = win.rect.move_top_left(10, 20)\nwin.rect\n</code></pre> Output<pre><code>WindowRect(left=10, top=20, width=200, height=250)\n</code></pre>"},{"location":"usage/workflows/","title":"Workflows","text":"<p>A \"workflow\" is a record of the commands and parameters you used to create a data model. For complicated data analysis tasks, looking at the workflow will help you remember what you did.</p>"},{"location":"usage/workflows/#built-in-workflow-viewer","title":"Built-in Workflow Viewer","text":"<p><code>himena-builtins</code> subpackage provides a built-in workflow viewer. You can view the workflow of a sub-window</p>"}]}