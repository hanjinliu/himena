{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"himena","text":"<p><code>himena</code> is a GUI application framework aiming for highly cooperative GUI development, mainly focusing on data analysis and visualization.</p>"},{"location":"#source","title":"Source","text":"<p>Jump to GitHub repository.</p>"},{"location":"#index","title":"Index","text":"<ul> <li>Tutorial</li> <li>Developper's Guide</li> </ul>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#installation","title":"Installation","text":"<p><code>himena</code> is available on PyPI. You can install it with the recommended dependencies:</p> <pre><code>pip install himena[recommended]\n</code></pre> <p>or with the minimal dependencies:</p> <pre><code>pip install himena\n</code></pre>"},{"location":"tutorial/#start-application","title":"Start Application","text":"<p>After installation, you can start the application by running the <code>himena</code> command:</p> <pre><code>himena\n</code></pre> <p><code>himena</code> can manage multiple profiles. A profile is a set of configurations, color theme and plugins. You can create a new profile with:</p> <pre><code>himena --new test\n</code></pre> <p>and start the application with the profile:</p> <pre><code>himena test\n</code></pre> <p>Note</p> <p>A profile can be used to separate the configurations for different users, or for different purposes. For example, you can have a profile \"img\" for image analysis, in which <code>himena img</code> is just like a sub-command of <code>himena</code>.</p>"},{"location":"tutorial/#open-a-data","title":"Open a Data","text":"<p>Let's start with a simple example. From the menubar, select <code>File &gt; New &gt; Seaborn &gt; iris</code>. This command will fetch the iris dataset online open it as a subwindow.</p> <p></p> <p>In <code>himena</code>, a subwindow represents a single data model. For example, this iris dataset is opened as a \"table\" data model. <code>himena</code> automatically picked the table viewer widget to display the data.</p> <p>Of course, you can open a local file from <code>File &gt; Open File(s) ...</code> menu, Ctrl+O shortcut, drag-and-drop or directly paste the data from the clipboard.</p> <p>There are also several ways to create a new window. They are listed in <code>File &gt; New</code> menu, or you can use Ctrl+N shortcut to look for the available options.</p>"},{"location":"tutorial/#execute-commands","title":"Execute Commands","text":"<p>Many commands are registered on the startup of the application. There are several ways to run a command.</p>"},{"location":"tutorial/#window-menu-button","title":"Window Menu Button","text":"<p>The \"window menu button\" will show a menu that contains the commands relevant to the operation on the current window. These commands are always available regardless of the data model the window represents. For example, \"Duplicate window\" and \"Copy path to cliboard\" are in the window menu.</p>"},{"location":"tutorial/#model-menu-button","title":"Model Menu Button","text":"<p>The \"model menu button\" will show a menu that contains the commands relevant to the type of the underlying data model. For example, the \"Convert table to text\" is available in the window \"iris\" just opened above.</p>"},{"location":"tutorial/#command-palette","title":"Command Palette","text":"<p>All the commands are accessible from the command palette. Press Ctrl+Shift+P to open the command palette.</p>"},{"location":"tutorial/#manage-plugins","title":"Manage Plugins","text":"<p><code>himena</code> is designed to be highly extensible. You can install plugins to add new IO supports, new widgets, and commands. For example, <code>himena-stats</code>, a himena plugin for statistical analysis, can be installed with the following lines.</p> <pre><code>pip install himena-stats -U\nhimena --install himena-stats\nhimena your-profile-name --install himena-stats  # install to a specific profile\n</code></pre> <p>You can also select which plugins installed to the Python virtual environment to be included in the <code>himena</code> profile from the setting. A setting dialog can be opened from <code>File &gt; Settings ...</code> or shortcut Ctrl+,</p> <p></p>"},{"location":"tutorial/#the-python-interpreter-console","title":"The Python Interpreter Console","text":"<p>A built-in Qt console dock widget plugin is registered by default. You can oepn it by shortcut Ctrl+Shift+C.</p> <p></p>"},{"location":"api/consts/","title":"himena.consts","text":""},{"location":"api/consts/#himena.consts.StandardType","title":"<code>StandardType</code>","text":"<p>Conventions for standard model types.</p> <p>Developers should use these types as much as possible to ensure compatibility with other plugins.</p> Source code in <code>src\\himena\\consts.py</code> <pre><code>class StandardType(SimpleNamespace):\n    \"\"\"Conventions for standard model types.\n\n    Developers should use these types as much as possible to ensure compatibility with\n    other plugins.\n    \"\"\"\n\n    ### Basic types ###\n    TEXT = \"text\"  # any text\n    TABLE = \"table\"  # 2D data without any special structure\n    ARRAY = \"array\"  # nD grid data such as numpy array\n    DICT = \"dict\"  # dictionary\n    DATAFRAME = \"dataframe\"  # DataFrame object\n\n    ### Subtypes ###\n    # dict subtypes\n    EXCEL = \"dict.table\"  # Excel file (~= tabbed tables)\n    DATAFRAMES = \"dict.dataframe\"\n    ARRAYS = \"dict.array\"\n    IMAGES = \"dict.array.image\"\n\n    # text subtypes\n    HTML = \"text.html\"  # HTML text\n    SVG = \"text.svg\"  # SVG text\n    MARKDOWN = \"text.markdown\"  # markdown text\n    JSON = \"text.json\"  # JSON text\n    IPYNB = \"text.json.ipynb\"  # Jupyter notebook\n\n    # image data\n    IMAGE = \"array.image\"\n    # uint image data that will be interpreted as labels\n    IMAGE_LABELS = \"array.image.labels\"\n\n    # (N, D) numerical array, such as D-dimensional point cloud\n    COORDINATES = \"array.coordinates\"\n\n    # DataFrame that is supposed to be plotted immediately (such as image line scan)\n    DATAFRAME_PLOT = \"dataframe.plot\"\n\n    ### plotting ###\n    PLOT = \"plot\"  # objects that satisfy the plotting standard\n    MPL_FIGURE = \"matplotlib-figure\"  # matplotlib figure object\n\n    ### 3D ###\n    MESH = \"mesh\"  # vertices, faces and values for 3D mesh\n\n    ### Nested models ###\n    MODELS = \"models\"  # list or dict of models\n    LAZY = \"lazy\"  # lazy loading of models\n\n    ### Other types ###\n    WORKFLOW = \"workflow\"  # himena workflow object\n    GROUPBY = \"groupby\"  # DataFrame GroupBy object\n    ROIS = \"rois\"  # regions of interest\n    FUNCTION = \"function\"  # callable object\n    FUNCTION_PARTIAL = \"function.partial\"  # callable object\n    DISTRIBUTION = \"distribution\"  # probablistic distribution object\n\n    # fallback when no reader is found for the file (which means that the file could be\n    # opened as a text file)\n    READER_NOT_FOUND = \"reader_not_found\"\n\n    # fallback when no specific widget can be used for the data\n    ANY = \"any\"\n</code></pre>"},{"location":"api/layout/","title":"himena.layout","text":""},{"location":"api/layout/#himena.layout.BoxLayout1D","title":"<code>BoxLayout1D</code>","text":"Source code in <code>src\\himena\\layout.py</code> <pre><code>class BoxLayout1D(Layout1D):\n    def __init__(self, main=None, *, margins=(0, 0, 0, 0), spacing=0):\n        super().__init__(main, margins=margins, spacing=spacing)\n        self._stretches: list[float] = []\n\n    def insert(self, index: int, child: Layout, *, stretch: float = 1) -&gt; None:\n        \"\"\"Insert a child layout at the specified index.\"\"\"\n        if stretch &lt;= 0:\n            raise ValueError(f\"stretch must be positive, got {stretch!r}\")\n        if not isinstance(child, Layout):\n            raise TypeError(f\"Can only insert a Layout object, got {type(child)}\")\n        self._children.insert(index, child)\n        child._main_window_ref = self._main_window_ref\n        child._parent_layout_ref = weakref.ref(self)\n        self._stretches.insert(index, float(stretch))\n        self._resize_children(self.rect)\n        return self\n\n    def append(self, child: Layout, *, stretch: float = 1) -&gt; None:\n        return self.insert(len(self), child, stretch=stretch)\n\n    def add(\n        self,\n        child: Layout | Iterable[Layout],\n        *more: Layout,\n        stretch: float = 1,\n    ) -&gt; Self:\n        \"\"\"Add child layout(s) to the layout.\"\"\"\n        if not isinstance(child, Layout):\n            child, more = child[0], [*child[1:], *more]\n        self.append(child, stretch=stretch)\n        for ch in more:\n            self.append(ch, stretch=stretch)\n        return self\n\n    def __delitem__(self, key: int):\n        _assert_supports_index(key)\n        child = self._children.pop(key)\n        child._parent_layout_ref = _no_ref\n        del self._stretches[key]\n        self._resize_children(self.rect)\n\n    def add_vbox_layout(self, *, margins=(0, 0, 0, 0), spacing=0) -&gt; VBoxLayout:\n        layout = VBoxLayout(self._main_window_ref(), margins=margins, spacing=spacing)\n        self.append(layout)\n        return layout\n\n    def add_hbox_layout(self, *, margins=(0, 0, 0, 0), spacing=0) -&gt; HBoxLayout:\n        layout = HBoxLayout(self._main_window_ref(), margins=margins, spacing=spacing)\n        self.append(layout)\n        return layout\n\n    def _may_take_child(\n        self, child: Layout, rect_old: WindowRect, rect_new: WindowRect\n    ) -&gt; Layout:\n        # window moved\n        dist2 = (rect_old.top - rect_new.top) ** 2 + (\n            rect_old.left - rect_new.left\n        ) ** 2\n        if dist2 &gt; 60**2:\n            # remove window from the layout\n            self.remove(child)\n        self._resize_children(self.rect)\n</code></pre>"},{"location":"api/layout/#himena.layout.BoxLayout1D.add","title":"<code>add(child, *more, stretch=1)</code>","text":"<p>Add child layout(s) to the layout.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>def add(\n    self,\n    child: Layout | Iterable[Layout],\n    *more: Layout,\n    stretch: float = 1,\n) -&gt; Self:\n    \"\"\"Add child layout(s) to the layout.\"\"\"\n    if not isinstance(child, Layout):\n        child, more = child[0], [*child[1:], *more]\n    self.append(child, stretch=stretch)\n    for ch in more:\n        self.append(ch, stretch=stretch)\n    return self\n</code></pre>"},{"location":"api/layout/#himena.layout.BoxLayout1D.insert","title":"<code>insert(index, child, *, stretch=1)</code>","text":"<p>Insert a child layout at the specified index.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>def insert(self, index: int, child: Layout, *, stretch: float = 1) -&gt; None:\n    \"\"\"Insert a child layout at the specified index.\"\"\"\n    if stretch &lt;= 0:\n        raise ValueError(f\"stretch must be positive, got {stretch!r}\")\n    if not isinstance(child, Layout):\n        raise TypeError(f\"Can only insert a Layout object, got {type(child)}\")\n    self._children.insert(index, child)\n    child._main_window_ref = self._main_window_ref\n    child._parent_layout_ref = weakref.ref(self)\n    self._stretches.insert(index, float(stretch))\n    self._resize_children(self.rect)\n    return self\n</code></pre>"},{"location":"api/layout/#himena.layout.EmptyLayout","title":"<code>EmptyLayout</code>","text":"<p>A layout that does not contain anything.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>class EmptyLayout(Layout):\n    \"\"\"A layout that does not contain anything.\"\"\"\n\n    def __init__(self, main: BackendMainWindow | None = None):\n        super().__init__(main)\n        self._rect = WindowRect(0, 0, 0, 0)\n\n    @property\n    def rect(self):\n        return self._rect\n\n    @rect.setter\n    def rect(self, value):\n        rect_old = self._rect\n        self._rect = WindowRect.from_tuple(*value)\n        if parent := self._parent_layout_ref():\n            parent._adjust_child_resize(self, rect_old, self._rect)\n\n    def _serialize_layout(self):\n        return {\"type\": \"empty\", \"rect\": self.rect}\n\n    @classmethod\n    def _deserialize_layout(cls, obj, main: MainWindow):\n        self = cls(main._backend_main_window)\n        self.rect = obj[\"rect\"]\n        return self\n</code></pre>"},{"location":"api/layout/#himena.layout.GridLayout","title":"<code>GridLayout</code>","text":"Source code in <code>src\\himena\\layout.py</code> <pre><code>class GridLayout(LayoutContainer):\n    def __init__(\n        self,\n        main: BackendMainWindow | None = None,\n        *,\n        margins: Margins[int] | tuple[int, int, int, int] = (0, 0, 0, 0),\n        spacing: Size[int] | tuple[int, int] = 0,\n    ):\n        super().__init__(main)\n        self._margins = Margins(*margins)\n        self._spacing = Size(*spacing)\n\n    @property\n    def margins(self) -&gt; Margins[int]:\n        \"\"\"Margins around the layout.\"\"\"\n        return self._margins\n\n    @margins.setter\n    def margins(self, value: Margins[int] | tuple[int, int, int, int]):\n        self._margins = Margins(*value)\n        self._resize_children(self.rect)\n\n    @property\n    def spacing(self) -&gt; Size:\n        \"\"\"Spacing between children.\"\"\"\n        return self._spacing\n\n    @spacing.setter\n    def spacing(self, value: Size[int] | tuple[int, int]):\n        self._spacing = Size(*value)\n        self._resize_children(self.rect)\n</code></pre>"},{"location":"api/layout/#himena.layout.GridLayout.margins","title":"<code>margins</code>  <code>property</code> <code>writable</code>","text":"<p>Margins around the layout.</p>"},{"location":"api/layout/#himena.layout.GridLayout.spacing","title":"<code>spacing</code>  <code>property</code> <code>writable</code>","text":"<p>Spacing between children.</p>"},{"location":"api/layout/#himena.layout.HBoxLayout","title":"<code>HBoxLayout</code>","text":"<p>A horizontal box layout.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>class HBoxLayout(BoxLayout1D):\n    \"\"\"A horizontal box layout.\"\"\"\n\n    def _iter_edge_and_span(self, rect: WindowRect) -&gt; Iterator[tuple[int, int]]:\n        num = len(self._children)\n        if num == 0:\n            yield from ()\n            return\n        w_cumsum = np.cumsum([0] + self._stretches, dtype=np.float32)\n        edges = (w_cumsum / w_cumsum[-1] * rect.width).astype(np.int32)\n        dx = self.spacing // 2\n        edges[0] += self._margins.left - dx\n        edges[-1] += self._margins.right + dx\n        for i in range(num):\n            left = edges[i] + dx\n            width = edges[i + 1] - edges[i] - self.spacing\n            yield left, width\n\n    def _ortho_region(self, rect: WindowRect) -&gt; tuple[int, int]:\n        height = rect.height - self._margins.top - self._margins.bottom\n        top = rect.top + self._margins.top\n        return top, height\n\n    def _resize_children(self, rect: WindowRect):\n        top, height = self._ortho_region(rect)\n        with self._adjust_child_resize_context():\n            for i, (left, width) in enumerate(self._iter_edge_and_span(rect)):\n                irect = WindowRect(left, top, width, height)\n                self._children[i].rect = irect\n        return None\n\n    def _adjust_child_resize(self, child: Layout, rect_old, rect_new):\n        if self._is_calling_adjust_child_resize:\n            return\n        left_changed = rect_old.left != rect_new.left\n        right_changed = rect_old.right != rect_new.right\n        with self._adjust_child_resize_context():\n            if left_changed and right_changed:\n                return self._may_take_child(child, rect_old, rect_new)\n\n            top, height = self._ortho_region(self.rect)\n            new_rect = child.rect\n            stretches = self._stretches.copy()\n            for i, (left, width) in enumerate(self._iter_edge_and_span(self.rect)):\n                stretches[i] = width\n                if left_changed and self._children[i] is child:\n                    if i == 0:\n                        child.rect = WindowRect(left, top, width, height)\n                    else:\n                        old_sum = stretches[i - 1] + stretches[i]\n                        w0 = stretches[i - 1] = old_sum - new_rect.width\n                        self._children[i - 1].rect = self._children[\n                            i - 1\n                        ].rect.with_width(w0)\n                        stretches[i] = new_rect.width\n                elif right_changed and self._children[i - 1] is child:\n                    if i == len(self) - 1:\n                        child.rect = WindowRect(left, top, width, height)\n                    else:\n                        old_sum = stretches[i - 1] + stretches[i]\n                        w0 = stretches[i] = old_sum - new_rect.width\n                        self._children[i].rect = new_rect.with_width(w0)\n                        stretches[i - 1] = new_rect.width\n                else:\n                    child.rect = WindowRect(left, top, width, height)\n            self._stretches = stretches\n            self._resize_children(self.rect)\n</code></pre>"},{"location":"api/layout/#himena.layout.Layout","title":"<code>Layout</code>","text":"Source code in <code>src\\himena\\layout.py</code> <pre><code>class Layout(ABC):\n    def __init__(self, main: BackendMainWindow | None = None):\n        self._anchor = _anc.NoAnchor\n        if main:\n            self._main_window_ref = weakref.ref(main)\n        else:\n            self._main_window_ref = _no_ref\n        self._parent_layout_ref: Callable[[], LayoutContainer | None] = _no_ref\n\n    @property\n    @abstractmethod\n    def rect(self) -&gt; WindowRect:\n        \"\"\"Position and size of the sub-window.\"\"\"\n\n    @rect.setter\n    def rect(self, value: tuple[int, int, int, int] | WindowRect) -&gt; None: ...\n\n    @abstractmethod\n    def _serialize_layout(self) -&gt; Any:\n        \"\"\"Serialize the layout instance.\"\"\"\n\n    @classmethod\n    @abstractmethod\n    def _deserialize_layout(cls, obj, main: MainWindow) -&gt; Any:\n        \"\"\"Deserialize the layout instance.\"\"\"\n\n    @property\n    def size(self) -&gt; Size[int]:\n        \"\"\"Size of the object.\"\"\"\n        return self.rect.size()\n\n    @size.setter\n    def size(self, value: tuple[int, int]) -&gt; None:\n        self.rect = (self.rect.left, self.rect.top, *value)\n        return None\n\n    @property\n    def anchor(self) -&gt; _anc.WindowAnchor:\n        return self._anchor\n\n    @anchor.setter\n    def anchor(self, anchor: _anc.WindowAnchor | None):\n        if anchor is None:\n            anchor = _anc.NoAnchor\n        elif isinstance(anchor, str):\n            anchor = self._anchor_from_str(anchor)\n        elif not isinstance(anchor, _anc.WindowAnchor):\n            raise TypeError(f\"Expected WindowAnchor, got {type(anchor)}\")\n        self._anchor = anchor\n\n    def _reanchor(self, size: Size):\n        \"\"\"Reanchor all windows if needed (such as minimized windows).\"\"\"\n        if rect := self._anchor.apply_anchor(size, self.size):\n            self.rect = rect\n\n    def _anchor_from_str(self, anchor: str):\n        rect = self.rect\n        main = self._main_window_ref()\n        if main is None:\n            w0, h0 = 100, 100\n        else:\n            w0, h0 = main._area_size()\n        if anchor in (\"top-left\", \"top left\", \"top_left\"):\n            return _anc.TopLeftConstAnchor(rect.left, rect.top)\n        elif anchor in (\"top-right\", \"top right\", \"top_right\"):\n            return _anc.TopRightConstAnchor(w0 - rect.right, rect.top)\n        elif anchor in (\"bottom-left\", \"bottom left\", \"bottom_left\"):\n            return _anc.BottomLeftConstAnchor(rect.left, h0 - rect.bottom)\n        elif anchor in (\"bottom-right\", \"bottom right\", \"bottom_right\"):\n            return _anc.BottomRightConstAnchor(w0 - rect.right, h0 - rect.bottom)\n        else:\n            raise ValueError(f\"Unknown anchor: {anchor}\")\n</code></pre>"},{"location":"api/layout/#himena.layout.Layout.rect","title":"<code>rect</code>  <code>abstractmethod</code> <code>property</code> <code>writable</code>","text":"<p>Position and size of the sub-window.</p>"},{"location":"api/layout/#himena.layout.Layout.size","title":"<code>size</code>  <code>property</code> <code>writable</code>","text":"<p>Size of the object.</p>"},{"location":"api/layout/#himena.layout.Layout1D","title":"<code>Layout1D</code>","text":"<p>Layout container that arranges children in 1D at the constant interval.</p> <p>Properties <code>margins</code> and <code>spacing</code> are defined as follows. <pre><code>        spacing                 margin\n         &gt; &lt;                     &gt; &lt;\n[ [child1] [   child2   ] [child3] ]\n           &lt;-  stretch -&gt;\n</code></pre></p> <p>Abstract methods: - <code>_resize_children(self, rect: WindowRect) -&gt; None</code> - <code>insert(self, index: int, child: Layout) -&gt; None</code></p> Source code in <code>src\\himena\\layout.py</code> <pre><code>class Layout1D(LayoutContainer, MutableSequence[Layout]):\n    \"\"\"Layout container that arranges children in 1D at the constant interval.\n\n    Properties `margins` and `spacing` are defined as follows.\n    ```\n            spacing                 margin\n             &gt; &lt;                     &gt; &lt;\n    [ [child1] [   child2   ] [child3] ]\n               &lt;-  stretch -&gt;\n    ```\n\n    Abstract methods:\n    - `_resize_children(self, rect: WindowRect) -&gt; None`\n    - `insert(self, index: int, child: Layout) -&gt; None`\n    \"\"\"\n\n    def __init__(\n        self,\n        main: BackendMainWindow | None = None,\n        *,\n        margins: Margins[int] | tuple[int, int, int, int] = (0, 0, 0, 0),\n        spacing: int = 0,\n    ):\n        super().__init__(main)\n        self._children: list[Layout] = []\n        self._margins = Margins(*margins)\n        self._spacing = spacing\n\n    @property\n    def margins(self) -&gt; Margins[int]:\n        \"\"\"Margins around the layout.\"\"\"\n        return self._margins\n\n    @margins.setter\n    def margins(self, value: Margins[int] | tuple[int, int, int, int]):\n        self._margins = Margins(*value)\n        self._resize_children(self.rect)\n\n    @property\n    def spacing(self) -&gt; int:\n        \"\"\"Spacing between children.\"\"\"\n        return self._spacing\n\n    @spacing.setter\n    def spacing(self, value: int):\n        if value &lt; 0 or not isinstance(value, (int, np.int_)):\n            raise ValueError(f\"spacing must be non-negative integer, got {value}\")\n        self._spacing = value\n        self._resize_children(self.rect)\n\n    def set_margins(\n        self,\n        *,\n        left: int | None = None,\n        top: int | None = None,\n        right: int | None = None,\n        bottom: int | None = None,\n    ):\n        \"\"\"Update margins around the layout.\"\"\"\n        margins_old = self.margins\n        left = left if left is not None else margins_old.left\n        top = top if top is not None else margins_old.top\n        right = right if right is not None else margins_old.right\n        bottom = bottom if bottom is not None else margins_old.bottom\n        self.margins = left, top, right, bottom\n        return None\n\n    def __len__(self) -&gt; int:\n        return len(self._children)\n\n    def __iter__(self) -&gt; Iterator[Layout]:\n        for _, child in self._children:\n            yield child\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}({self._children!r})\"\n\n    def __getitem__(self, key) -&gt; Layout:\n        _assert_supports_index(key)\n        return self._children[key]\n\n    def __setitem__(self, key, layout: Layout):\n        if not isinstance(layout, Layout):\n            raise TypeError(f\"Can only set a Layout object, got {type(layout)}\")\n        _assert_supports_index(key)\n        self._children[key] = layout\n        layout._main_window_ref = self._main_window_ref\n        layout._parent_layout_ref = weakref.ref(self)\n        self._resize_children(self.rect)\n\n    def remove(self, child: Layout) -&gt; None:\n        MutableSequence.remove(self, child)\n        child._parent_layout_ref = _no_ref\n        if len(self) &gt; 1:\n            self._resize_children(self.rect)\n        elif len(self) == 1:\n            self.remove(self[0])\n\n    def _serialize_layout(self):\n        return {\n            \"type\": type(self).__name__.lower(),\n            \"children\": [child._serialize_layout() for child in self._children],\n            \"margins\": list(self.margins),\n            \"spacing\": self.spacing,\n        }\n\n    @classmethod\n    def _deserialize_layout(cls, obj, main: MainWindow) -&gt; Self:\n        self = cls(\n            main._backend_main_window, margins=obj[\"margins\"], spacing=obj[\"spacing\"]\n        )\n        for child_obj in obj[\"children\"]:\n            child = construct_layout(child_obj, main)\n            self.append(child)\n        return self\n</code></pre>"},{"location":"api/layout/#himena.layout.Layout1D.margins","title":"<code>margins</code>  <code>property</code> <code>writable</code>","text":"<p>Margins around the layout.</p>"},{"location":"api/layout/#himena.layout.Layout1D.spacing","title":"<code>spacing</code>  <code>property</code> <code>writable</code>","text":"<p>Spacing between children.</p>"},{"location":"api/layout/#himena.layout.Layout1D.set_margins","title":"<code>set_margins(*, left=None, top=None, right=None, bottom=None)</code>","text":"<p>Update margins around the layout.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>def set_margins(\n    self,\n    *,\n    left: int | None = None,\n    top: int | None = None,\n    right: int | None = None,\n    bottom: int | None = None,\n):\n    \"\"\"Update margins around the layout.\"\"\"\n    margins_old = self.margins\n    left = left if left is not None else margins_old.left\n    top = top if top is not None else margins_old.top\n    right = right if right is not None else margins_old.right\n    bottom = bottom if bottom is not None else margins_old.bottom\n    self.margins = left, top, right, bottom\n    return None\n</code></pre>"},{"location":"api/layout/#himena.layout.LayoutContainer","title":"<code>LayoutContainer</code>","text":"<p>Layout that can contain other layouts.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>class LayoutContainer(Layout):\n    \"\"\"Layout that can contain other layouts.\"\"\"\n\n    def __init__(self, main: BackendMainWindow | None = None):\n        self._rect = WindowRect(0, 0, 1000, 1000)\n        super().__init__(main)\n        self._anchor = _anc.AllCornersAnchor()\n        self._is_calling_adjust_child_resize = False\n\n    @contextmanager\n    def _adjust_child_resize_context(self):\n        was = self._is_calling_adjust_child_resize\n        self._is_calling_adjust_child_resize = True\n        try:\n            yield\n        finally:\n            self._is_calling_adjust_child_resize = was\n\n    @property\n    def rect(self):\n        return self._rect\n\n    @rect.setter\n    def rect(self, value):\n        rect = WindowRect.from_tuple(*value)\n        rect_old = self._rect\n        self._rect = rect\n        self._resize_children(rect)\n        if parent := self._parent_layout_ref():\n            parent._adjust_child_resize(self, rect_old, rect)\n\n    @abstractmethod\n    def _resize_children(self, rect: WindowRect):\n        \"\"\"Resize all children layouts based on the geometry of this layout.\"\"\"\n\n    @abstractmethod\n    def remove(self, child: Layout) -&gt; None:\n        \"\"\"Remove a child layout from this layout.\"\"\"\n\n    # @abstractmethod\n    def _adjust_child_resize(\n        self, child: Layout, rect_old: WindowRect, rect_new: WindowRect\n    ):\n        \"\"\"Adjust layout container based on the child resize/move.\"\"\"\n</code></pre>"},{"location":"api/layout/#himena.layout.LayoutContainer.remove","title":"<code>remove(child)</code>  <code>abstractmethod</code>","text":"<p>Remove a child layout from this layout.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>@abstractmethod\ndef remove(self, child: Layout) -&gt; None:\n    \"\"\"Remove a child layout from this layout.\"\"\"\n</code></pre>"},{"location":"api/layout/#himena.layout.VBoxLayout","title":"<code>VBoxLayout</code>","text":"<p>A vertical box layout.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>class VBoxLayout(BoxLayout1D):\n    \"\"\"A vertical box layout.\"\"\"\n\n    def _iter_edge_and_span(self, rect: WindowRect) -&gt; Iterator[tuple[int, int]]:\n        num = len(self._children)\n        if num == 0:\n            yield from ()\n            return\n        h_cumsum = np.cumsum([0] + self._stretches, dtype=np.float32)\n        edges = (h_cumsum / h_cumsum[-1] * rect.height).astype(np.int32)\n        dy = self.spacing // 2\n        edges[0] += self._margins.top - dy\n        edges[-1] += self._margins.bottom + dy\n        for i in range(num):\n            top = edges[i] + dy\n            height = edges[i + 1] - edges[i] - self.spacing\n            yield top, height\n\n    def _ortho_region(self, rect: WindowRect) -&gt; tuple[int, int]:\n        width = rect.width - self._margins.left - self._margins.right\n        left = rect.left + self._margins.left\n        return left, width\n\n    def _resize_children(self, rect: WindowRect):\n        left, width = self._ortho_region(rect)\n        with self._adjust_child_resize_context():\n            for i, (top, height) in enumerate(self._iter_edge_and_span(rect)):\n                irect = WindowRect(left, top, width, height)\n                self._children[i].rect = irect\n        return None\n\n    def _adjust_child_resize(self, child: Layout, rect_old, rect_new):\n        if self._is_calling_adjust_child_resize:\n            return\n        top_changed = rect_old.top != rect_new.top\n        bottom_changed = rect_old.bottom != rect_new.bottom\n        with self._adjust_child_resize_context():\n            if top_changed and bottom_changed:\n                return self._may_take_child(child, rect_old, rect_new)\n\n            top, height = self._ortho_region(self.rect)\n            new_rect = child.rect\n            stretches = self._stretches.copy()\n            for i, (left, width) in enumerate(self._iter_edge_and_span(self.rect)):\n                stretches[i] = width\n                if top_changed and self._children[i] is child:\n                    if i == 0:\n                        child.rect = WindowRect(left, top, width, height)\n                    else:\n                        old_sum = stretches[i - 1] + stretches[i]\n                        stretches[i - 1] = old_sum - new_rect.height\n                        stretches[i] = new_rect.height\n                elif bottom_changed and self._children[i - 1] is child:\n                    if i == len(self) - 1:\n                        child.rect = WindowRect(left, top, width, height)\n                    else:\n                        old_sum = stretches[i - 1] + stretches[i]\n                        stretches[i] = old_sum - new_rect.height\n                        stretches[i - 1] = new_rect.height\n                else:\n                    child.rect = WindowRect(left, top, width, height)\n            self._stretches = stretches\n            self._resize_children(self.rect)\n</code></pre>"},{"location":"api/layout/#himena.layout.VStackLayout","title":"<code>VStackLayout</code>","text":"Source code in <code>src\\himena\\layout.py</code> <pre><code>class VStackLayout(Layout1D):\n    def __init__(\n        self,\n        main: BackendMainWindow | None = None,\n        *,\n        margins: Margins[int] | tuple[int, int, int, int] = (0, 0, 0, 0),\n        spacing: int = 0,\n        inverted: bool = False,\n    ):\n        super().__init__(main, margins=margins, spacing=spacing)\n        self._inverted = inverted\n\n    @property\n    def inverted(self) -&gt; bool:\n        return self._inverted\n\n    @inverted.setter\n    def inverted(self, value: bool):\n        self._inverted = bool(value)\n        self._resize_children(self.rect)\n\n    def insert(self, index: int, child: Layout) -&gt; None:\n        \"\"\"Insert a child layout at the specified index.\"\"\"\n        self._children.insert(index, child)\n        child._main_window_ref = self._main_window_ref\n        child._parent_layout_ref = weakref.ref(self)\n        self._resize_children(self.rect)\n        return self\n\n    def append(self, child: Layout) -&gt; None:\n        return self.insert(len(self), child)\n\n    def add(self, child: Layout) -&gt; Self:\n        self.append(child)\n        return self\n\n    def __delitem__(self, key: int):\n        _assert_supports_index(key)\n        self._children[key]._parent_layout_ref = _no_ref\n        del self._children[key]\n        self._resize_children(self.rect)\n\n    def _resize_children(self, rect):\n        num = len(self._children)\n        if num == 0:\n            return\n        heights = [ch.rect.height for ch in self._children]\n        h_cumsum = np.cumsum([0] + heights, dtype=np.uint32)\n        if self._inverted:\n            bottoms = rect.bottom - h_cumsum[:-1] + self._margins.bottom\n            for i, child in enumerate(self._children):\n                child.rect = child.rect.move_bottom_left(rect.left, bottoms[i])\n        else:\n            tops = h_cumsum[:-1] + rect.top + self._margins.top\n            for i, child in enumerate(self._children):\n                child.rect = child.rect.move_top_left(rect.left, tops[i])\n</code></pre>"},{"location":"api/layout/#himena.layout.VStackLayout.insert","title":"<code>insert(index, child)</code>","text":"<p>Insert a child layout at the specified index.</p> Source code in <code>src\\himena\\layout.py</code> <pre><code>def insert(self, index: int, child: Layout) -&gt; None:\n    \"\"\"Insert a child layout at the specified index.\"\"\"\n    self._children.insert(index, child)\n    child._main_window_ref = self._main_window_ref\n    child._parent_layout_ref = weakref.ref(self)\n    self._resize_children(self.rect)\n    return self\n</code></pre>"},{"location":"api/plugins/","title":"himena.plugins","text":""},{"location":"api/plugins/#himena.plugins.AppActionRegistry","title":"<code>AppActionRegistry</code>","text":"Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>class AppActionRegistry:\n    _global_instance: AppActionRegistry | None = None\n\n    def __init__(self):\n        self._actions: dict[str, Action] = {}\n        self._submenu_titles: dict[str, str] = {}\n        self._installed_plugins: list[str] = []\n        self._plugin_default_configs: dict[str, PluginConfigTuple] = {}\n\n    @classmethod\n    def instance(cls) -&gt; AppActionRegistry:\n        \"\"\"Get the global instance of the registry.\"\"\"\n        if cls._global_instance is None:\n            cls._global_instance = cls()\n        return cls._global_instance\n\n    def add_action(self, action: Action) -&gt; None:\n        \"\"\"Add an action to the registry.\"\"\"\n        id_ = action.id\n        if id_ in self._actions:\n            raise ValueError(f\"Action ID {id_} already exists.\")\n        self._actions[id_] = action\n\n    @property\n    def installed_plugins(self) -&gt; list[str]:\n        \"\"\"List of modules or python paths that are installed as plugins.\"\"\"\n        return self._installed_plugins\n\n    def iter_actions(self, app: Application) -&gt; Iterator[Action]:\n        for id_, action in self._actions.items():\n            if id_ not in app.commands:\n                yield action\n\n    def submenu_title(self, id: str) -&gt; str:\n        if title := self._submenu_titles.get(id):\n            return title\n        return id.split(\"/\")[-1].title()\n\n    @property\n    def submenu_titles(self) -&gt; dict[str, str]:\n        return self._submenu_titles\n\n    def install_to(\n        self,\n        app: Application,\n        actions: list[Action] | None = None,\n    ) -&gt; list[str]:\n        \"\"\"Install actions to the application.\n\n        This method automatically adds submenus if they are not already exists, and\n        returns the list of added root menu IDs. Note that this does NOT updates the\n        GUI menubar and toolbar.\n        \"\"\"\n        # look for existing menu items\n        if actions is None:\n            actions = list(self.iter_actions(app))\n        existing_menu_ids = {_id.value for _id in MenuId}\n        for menu_id, menu in app.menus:\n            existing_menu_ids.add(menu_id)\n            for each in menu:\n                if isinstance(each, SubmenuItem):\n                    existing_menu_ids.add(each.submenu)\n\n        added_menu_ids = OrderedSet[str]()\n        for action in actions:\n            if action.menus is not None:\n                ids = [a.id for a in action.menus]\n                added_menu_ids.update(ids)\n\n        # add submenus if not exists\n        to_add: list[tuple[str, SubmenuItem]] = []\n        new_menu_ids: list[str] = []\n\n        for place in added_menu_ids - existing_menu_ids:\n            place_components = place.split(\"/\")\n            if len(place_components) == 1:\n                new_menu_ids.append(place)\n            for i in range(1, len(place_components)):\n                menu_id = \"/\".join(place_components[:i])\n                submenu = \"/\".join(place_components[: i + 1])\n                if submenu in existing_menu_ids:\n                    continue\n                title = self.submenu_title(submenu)\n                item = SubmenuItem(title=title, submenu=submenu)\n                to_add.append((menu_id, item))\n\n        app.register_actions(actions)\n        app.menus.append_menu_items(to_add)\n        return new_menu_ids\n</code></pre>"},{"location":"api/plugins/#himena.plugins.AppActionRegistry.installed_plugins","title":"<code>installed_plugins</code>  <code>property</code>","text":"<p>List of modules or python paths that are installed as plugins.</p>"},{"location":"api/plugins/#himena.plugins.AppActionRegistry.add_action","title":"<code>add_action(action)</code>","text":"<p>Add an action to the registry.</p> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>def add_action(self, action: Action) -&gt; None:\n    \"\"\"Add an action to the registry.\"\"\"\n    id_ = action.id\n    if id_ in self._actions:\n        raise ValueError(f\"Action ID {id_} already exists.\")\n    self._actions[id_] = action\n</code></pre>"},{"location":"api/plugins/#himena.plugins.AppActionRegistry.install_to","title":"<code>install_to(app, actions=None)</code>","text":"<p>Install actions to the application.</p> <p>This method automatically adds submenus if they are not already exists, and returns the list of added root menu IDs. Note that this does NOT updates the GUI menubar and toolbar.</p> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>def install_to(\n    self,\n    app: Application,\n    actions: list[Action] | None = None,\n) -&gt; list[str]:\n    \"\"\"Install actions to the application.\n\n    This method automatically adds submenus if they are not already exists, and\n    returns the list of added root menu IDs. Note that this does NOT updates the\n    GUI menubar and toolbar.\n    \"\"\"\n    # look for existing menu items\n    if actions is None:\n        actions = list(self.iter_actions(app))\n    existing_menu_ids = {_id.value for _id in MenuId}\n    for menu_id, menu in app.menus:\n        existing_menu_ids.add(menu_id)\n        for each in menu:\n            if isinstance(each, SubmenuItem):\n                existing_menu_ids.add(each.submenu)\n\n    added_menu_ids = OrderedSet[str]()\n    for action in actions:\n        if action.menus is not None:\n            ids = [a.id for a in action.menus]\n            added_menu_ids.update(ids)\n\n    # add submenus if not exists\n    to_add: list[tuple[str, SubmenuItem]] = []\n    new_menu_ids: list[str] = []\n\n    for place in added_menu_ids - existing_menu_ids:\n        place_components = place.split(\"/\")\n        if len(place_components) == 1:\n            new_menu_ids.append(place)\n        for i in range(1, len(place_components)):\n            menu_id = \"/\".join(place_components[:i])\n            submenu = \"/\".join(place_components[: i + 1])\n            if submenu in existing_menu_ids:\n                continue\n            title = self.submenu_title(submenu)\n            item = SubmenuItem(title=title, submenu=submenu)\n            to_add.append((menu_id, item))\n\n    app.register_actions(actions)\n    app.menus.append_menu_items(to_add)\n    return new_menu_ids\n</code></pre>"},{"location":"api/plugins/#himena.plugins.AppActionRegistry.instance","title":"<code>instance()</code>  <code>classmethod</code>","text":"<p>Get the global instance of the registry.</p> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>@classmethod\ndef instance(cls) -&gt; AppActionRegistry:\n    \"\"\"Get the global instance of the registry.\"\"\"\n    if cls._global_instance is None:\n        cls._global_instance = cls()\n    return cls._global_instance\n</code></pre>"},{"location":"api/plugins/#himena.plugins.ReaderPlugin","title":"<code>ReaderPlugin</code>","text":"Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>class ReaderPlugin(_IOPluginBase):\n    def __init__(\n        self,\n        reader: Callable[[Path | list[Path]], WidgetDataModel],\n        matcher: Callable[[Path | list[Path]], bool] | None = None,\n        *,\n        priority: int = 100,\n    ):\n        super().__init__(reader, matcher, priority=priority)\n        self._skip_if_list = False\n        if hasattr(reader, \"__annotations__\"):\n            annot_types = list(reader.__annotations__.values())\n            if len(annot_types) == 1 and annot_types[0] in (\n                Path,\n                \"Path\",\n                ForwardRef(\"Path\"),\n            ):\n                self._skip_if_list = True\n\n    def read(self, path: Path | list[Path]) -&gt; WidgetDataModel:\n        \"\"\"Read file(s) and return a data model.\"\"\"\n        if isinstance(path, list):\n            out = self._func([Path(p) for p in path])\n        else:\n            out = self._func(Path(path))\n        if not isinstance(out, WidgetDataModel):\n            raise TypeError(f\"Reader plugin {self!r} did not return a WidgetDataModel.\")\n        return out\n\n    __call__ = read\n\n    def match_model_type(self, path: Path | list[Path]) -&gt; str | None:\n        \"\"\"True if the reader can read the file.\"\"\"\n        if self._skip_if_list and isinstance(path, list):\n            return None\n        if self._matcher is None:\n            return None\n        out = self._matcher(path)\n        if out is None or isinstance(out, str):\n            return out\n        raise TypeError(f\"Matcher {self._matcher!r} did not return a string.\")\n\n    def define_matcher(self, matcher: Callable[[Path | list[Path]], str | None]):\n        \"\"\"Mark a function as a matcher.\n\n        The matcher function should return a type string if the reader can read the\n        file, or None otherwise. If the reader function is annotated with `Path`, only\n        single Path input is forwarded to the matcher function, otherwise both `Path`\n        and `list[Path]` will be considered.\n\n        Examples\n        --------\n        A reader plugin that reads only text files:\n\n        ```python\n        @my_reader.define_matcher\n        def _(path: Path):\n            if path.suffix == \".txt\":\n                return \"text\"\n            return None\n        ```\n        \"\"\"\n        # NOTE: matcher don't have to return the priority. If users want to define\n        # a plugin that has different priority for different file type, they can just\n        # split the plugin function into two.\n        if self._matcher is self._undefined_matcher:\n            raise ValueError(f\"Matcher for {self!r} is already defined.\")\n        self._matcher = matcher\n        return matcher\n\n    def read_and_update_source(self, source: Path | list[Path]) -&gt; WidgetDataModel:\n        \"\"\"Update workflow to a local-reader method if it is not set.\"\"\"\n        model = self.read(source)\n        if len(model.workflow) == 0:\n            model = model._with_source(source=source, plugin=self.plugin)\n        return model\n</code></pre>"},{"location":"api/plugins/#himena.plugins.ReaderPlugin.define_matcher","title":"<code>define_matcher(matcher)</code>","text":"<p>Mark a function as a matcher.</p> <p>The matcher function should return a type string if the reader can read the file, or None otherwise. If the reader function is annotated with <code>Path</code>, only single Path input is forwarded to the matcher function, otherwise both <code>Path</code> and <code>list[Path]</code> will be considered.</p> <p>Examples:</p> <p>A reader plugin that reads only text files:</p> <pre><code>@my_reader.define_matcher\ndef _(path: Path):\n    if path.suffix == \".txt\":\n        return \"text\"\n    return None\n</code></pre> Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>def define_matcher(self, matcher: Callable[[Path | list[Path]], str | None]):\n    \"\"\"Mark a function as a matcher.\n\n    The matcher function should return a type string if the reader can read the\n    file, or None otherwise. If the reader function is annotated with `Path`, only\n    single Path input is forwarded to the matcher function, otherwise both `Path`\n    and `list[Path]` will be considered.\n\n    Examples\n    --------\n    A reader plugin that reads only text files:\n\n    ```python\n    @my_reader.define_matcher\n    def _(path: Path):\n        if path.suffix == \".txt\":\n            return \"text\"\n        return None\n    ```\n    \"\"\"\n    # NOTE: matcher don't have to return the priority. If users want to define\n    # a plugin that has different priority for different file type, they can just\n    # split the plugin function into two.\n    if self._matcher is self._undefined_matcher:\n        raise ValueError(f\"Matcher for {self!r} is already defined.\")\n    self._matcher = matcher\n    return matcher\n</code></pre>"},{"location":"api/plugins/#himena.plugins.ReaderPlugin.match_model_type","title":"<code>match_model_type(path)</code>","text":"<p>True if the reader can read the file.</p> Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>def match_model_type(self, path: Path | list[Path]) -&gt; str | None:\n    \"\"\"True if the reader can read the file.\"\"\"\n    if self._skip_if_list and isinstance(path, list):\n        return None\n    if self._matcher is None:\n        return None\n    out = self._matcher(path)\n    if out is None or isinstance(out, str):\n        return out\n    raise TypeError(f\"Matcher {self._matcher!r} did not return a string.\")\n</code></pre>"},{"location":"api/plugins/#himena.plugins.ReaderPlugin.read","title":"<code>read(path)</code>","text":"<p>Read file(s) and return a data model.</p> Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>def read(self, path: Path | list[Path]) -&gt; WidgetDataModel:\n    \"\"\"Read file(s) and return a data model.\"\"\"\n    if isinstance(path, list):\n        out = self._func([Path(p) for p in path])\n    else:\n        out = self._func(Path(path))\n    if not isinstance(out, WidgetDataModel):\n        raise TypeError(f\"Reader plugin {self!r} did not return a WidgetDataModel.\")\n    return out\n</code></pre>"},{"location":"api/plugins/#himena.plugins.ReaderPlugin.read_and_update_source","title":"<code>read_and_update_source(source)</code>","text":"<p>Update workflow to a local-reader method if it is not set.</p> Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>def read_and_update_source(self, source: Path | list[Path]) -&gt; WidgetDataModel:\n    \"\"\"Update workflow to a local-reader method if it is not set.\"\"\"\n    model = self.read(source)\n    if len(model.workflow) == 0:\n        model = model._with_source(source=source, plugin=self.plugin)\n    return model\n</code></pre>"},{"location":"api/plugins/#himena.plugins.configure_gui","title":"<code>configure_gui(f=None, *, title=None, preview=False, auto_close=True, show_parameter_labels=True, gui_options=None, result_as='window', **kwargs)</code>","text":"<pre><code>configure_gui(\n    f: _F,\n    *,\n    title: str | None = None,\n    preview: bool = False,\n    auto_close: bool = True,\n    show_parameter_labels: bool = True,\n    gui_options: dict[str, Any] | None = None,\n    result_as: Literal[\n        \"window\", \"below\", \"right\"\n    ] = \"window\",\n    **kwargs,\n) -&gt; _F\n</code></pre><pre><code>configure_gui(\n    *,\n    title: str | None = None,\n    preview: bool = False,\n    auto_close: bool = True,\n    show_parameter_labels: bool = True,\n    gui_options: dict[str, Any] | None = None,\n    result_as: Literal[\n        \"window\", \"below\", \"right\"\n    ] = \"window\",\n    **kwargs,\n) -&gt; Callable[[_F], _F]\n</code></pre> <p>Configure the parametric GUI.</p> <p>This decorator sets the configuration options for the parametric GUI window.</p> <pre><code>@configure_gui(a={\"label\": \"A\", \"widget_type\": \"FloatSlider\"})\ndef my_func(a: float):\n    pass\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title of the parametric GUI window. If not provided, this title will be determined by the action title where this function is returned.</p> <code>None</code> <code>preview</code> <code>bool</code> <p>If true, a preview toggle switch will be added to the GUI window. When the switch is on, the function will be called and the result will be displayed. Note that <code>configure_gui</code> does not consider whether the preview is a heavy operation.</p> <code>False</code> <code>auto_close</code> <code>bool</code> <p>If true, the parametric GUI window will be closed automatically after the function is executed.</p> <code>True</code> <code>show_parameter_labels</code> <code>bool</code> <p>If true, the parameter names will be shown in the GUI window.</p> <code>True</code> <code>gui_options</code> <code>dict</code> <p>Additional GUI options to be passed to the <code>magicgui</code> decorator. Keys can also be passed as variable keyword arguments **kwargs.</p> <code>None</code> Source code in <code>src\\himena\\plugins\\_signature.py</code> <pre><code>def configure_gui(\n    f=None,\n    *,\n    title: str | None = None,\n    preview: bool = False,\n    auto_close: bool = True,\n    show_parameter_labels: bool = True,\n    gui_options: dict[str, Any] | None = None,\n    result_as: Literal[\"window\", \"below\", \"right\"] = \"window\",\n    **kwargs,\n):\n    \"\"\"Configure the parametric GUI.\n\n    This decorator sets the configuration options for the parametric GUI window.\n\n    ``` python\n    @configure_gui(a={\"label\": \"A\", \"widget_type\": \"FloatSlider\"})\n    def my_func(a: float):\n        pass\n    ```\n\n    Parameters\n    ----------\n    title : str, optional\n        The title of the parametric GUI window. If not provided, this title will be\n        determined by the action title where this function is returned.\n    preview : bool, default False\n        If true, a preview toggle switch will be added to the GUI window. When the\n        switch is on, the function will be called and the result will be displayed. Note\n        that `configure_gui` does not consider whether the preview is a heavy operation.\n    auto_close : bool, default True\n        If true, the parametric GUI window will be closed automatically after the\n        function is executed.\n    show_parameter_labels : bool, default True\n        If true, the parameter names will be shown in the GUI window.\n    gui_options : dict, optional\n        Additional GUI options to be passed to the `magicgui` decorator. Keys can also\n        be passed as variable keyword arguments **kwargs.\n    \"\"\"\n    kwargs = dict(**kwargs, **(gui_options or {}))\n\n    def _inner(f):\n        sig = inspect.signature(f)\n        new_params = sig.parameters.copy()\n        if var_kwargs_name := _get_var_kwargs_name(sig):\n            new_params.pop(var_kwargs_name)\n\n        for k, v in kwargs.items():\n            if k not in new_params:\n                if var_kwargs_name is None:\n                    raise TypeError(f\"{k!r} is not a valid parameter for {f!r}.\")\n                # This allows using **kwargs in the target function so that magicgui\n                # widget can be created for a variable number of parameters.\n                param = inspect.Parameter(name=k, kind=inspect.Parameter.KEYWORD_ONLY)\n            else:\n                param = sig.parameters[k]\n            # unwrap Annotated types\n            if not _is_annotated(param.annotation):\n                annot = _prioritize_choices(param.annotation, v)\n                param = param.replace(annotation=Annotated[annot, v])\n            else:\n                typ, meta = _split_annotated_type(param.annotation)\n                meta.update(v)\n                typ = _prioritize_choices(typ, meta)\n                param = param.replace(annotation=Annotated[typ, meta])\n            new_params[k] = param\n        # update the signature with the normalize one\n        sig = sig.replace(parameters=list(new_params.values()))\n        f.__signature__ = sig\n        f.__annotations__ = {k: v.annotation for k, v in sig.parameters.items()}\n        if sig.return_annotation is not inspect.Parameter.empty:\n            f.__annotations__[\"return\"] = sig.return_annotation\n\n        GuiConfiguration(\n            title=title,\n            preview=preview,\n            auto_close=auto_close,\n            show_parameter_labels=show_parameter_labels,\n            result_as=result_as,\n        ).set(f)\n        return f\n\n    return _inner if f is None else _inner(f)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.configure_submenu","title":"<code>configure_submenu(submenu_id, title)</code>","text":"<p>Register a title for submenu(s).</p> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>def configure_submenu(submenu_id: str | Iterable[str], title: str) -&gt; None:\n    \"\"\"Register a title for submenu(s).\"\"\"\n    if isinstance(submenu_id, str):\n        submenu_id = [submenu_id]\n    for sid in submenu_id:\n        AppActionRegistry.instance()._submenu_titles[sid] = title\n</code></pre>"},{"location":"api/plugins/#himena.plugins.install_plugins","title":"<code>install_plugins(app, plugins)</code>","text":"<p>Install plugins to the application.</p> Source code in <code>src\\himena\\plugins\\install.py</code> <pre><code>def install_plugins(app: Application, plugins: list[str]):\n    \"\"\"Install plugins to the application.\"\"\"\n    from importlib import import_module\n    from himena.plugins import AppActionRegistry\n    from himena.profile import load_app_profile\n\n    reg = AppActionRegistry.instance()\n    for name in plugins:\n        if name in reg._installed_plugins:\n            continue\n        _time_0 = timer()\n        if isinstance(name, str):\n            if name.endswith(\".py\"):\n                if not Path(name).exists():\n                    _LOGGER.error(f\"Plugin file {name} not found.\")\n                    continue\n                import runpy\n\n                runpy.run_path(name)\n            else:\n                try:\n                    import_module(name)\n                except ModuleNotFoundError:\n                    _LOGGER.error(f\"Plugin {name} not found.\")\n                except Exception as e:\n                    _LOGGER.error(f\"Error installing plugin {name}: {e}\")\n        else:\n            raise TypeError(f\"Invalid plugin type: {type(name)}\")\n        _msec = (timer() - _time_0) * 1000\n        _LOGGER.info(f\"Plugin {name} installed in {_msec:.3f} msec.\")\n    reg.install_to(app)\n    reg._installed_plugins.extend(plugins)\n    prof = load_app_profile(app.name)\n\n    for k, cfg in reg._plugin_default_configs.items():\n        prof.plugin_configs.setdefault(k, cfg.as_dict())\n\n    prof.save()\n</code></pre>"},{"location":"api/plugins/#himena.plugins.register_conversion_rule","title":"<code>register_conversion_rule(*args, **kwargs)</code>","text":"<pre><code>register_conversion_rule(\n    func: _F,\n    type_from: str,\n    type_to: str,\n    *,\n    keybindings: KeyBindingsType | None = None,\n    command_id: str | None = None,\n) -&gt; _F\n</code></pre><pre><code>register_conversion_rule(\n    type_from: str,\n    type_to: str,\n    *,\n    keybindings: KeyBindingsType | None = None,\n    command_id: str | None = None,\n) -&gt; Callable[[_F], _F]\n</code></pre> <p>Register a function as a conversion rule.</p> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>def register_conversion_rule(*args, **kwargs):\n    \"\"\"Register a function as a conversion rule.\"\"\"\n    if len(args) == 0:\n        no_func = True\n    else:\n        if isinstance(args[0], str):\n            return register_conversion_rule(None, *args, **kwargs)\n        no_func = args[0] is None\n\n    def inner(func):\n        annot = getattr(func, \"__annotations__\", {})\n        annot.setdefault(\"return\", WidgetDataModel)\n        func.__annotations__ = annot\n        action = make_conversion_rule(func, *args, **kwargs)\n        AppActionRegistry.instance().add_action(action)\n        return func\n\n    return inner if no_func else inner(args[0])\n</code></pre>"},{"location":"api/plugins/#himena.plugins.register_dock_widget_action","title":"<code>register_dock_widget_action(widget_factory=None, *, menus='plugins', title=None, area=DockArea.RIGHT, allowed_areas=None, keybindings=None, singleton=False, plugin_configs=None, command_id=None)</code>","text":"<pre><code>register_dock_widget_action(\n    widget_factory: _F,\n    *,\n    menus: str | Sequence[str] = \"plugins\",\n    title: str | None = None,\n    area: DockArea | DockAreaString = DockArea.RIGHT,\n    allowed_areas: Sequence[DockArea | DockAreaString]\n    | None = None,\n    keybindings: KeyBindingsType | None = None,\n    singleton: bool = False,\n    plugin_configs: PluginConfigType | None = None,\n    command_id: str | None = None,\n) -&gt; _F\n</code></pre><pre><code>register_dock_widget_action(\n    widget_factory: None = None,\n    *,\n    menus: str | Sequence[str] = \"plugins\",\n    title: str | None = None,\n    area: DockArea | DockAreaString = DockArea.RIGHT,\n    allowed_areas: Sequence[DockArea | DockAreaString]\n    | None = None,\n    keybindings: KeyBindingsType | None = None,\n    singleton: bool = False,\n    plugin_configs: PluginConfigType | None = None,\n    command_id: str | None = None,\n) -&gt; Callable[[_F], _F]\n</code></pre> <p>Register a widget factory as a dock widget function.</p> <p>Parameters:</p> Name Type Description Default <code>widget_factory</code> <code>callable</code> <p>Class of dock widget, or a factory function for the dock widget.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title of the dock widget.</p> <code>None</code> <code>area</code> <code>DockArea or DockAreaString</code> <p>Initial area of the dock widget.</p> <code>RIGHT</code> <code>allowed_areas</code> <code>sequence of DockArea or DockAreaString</code> <p>List of areas that is allowed for the dock widget.</p> <code>None</code> <code>keybindings</code> <code>sequence of keybinding rule</code> <p>Keybindings to trigger the dock widget.</p> <code>None</code> <code>singleton</code> <code>bool</code> <p>If true, the registered dock widget will constructed only once.</p> <code>False</code> <code>plugin_configs</code> <code>(dict, dataclass or BaseModel)</code> <p>Default configuration for the plugin. This config will be saved in the application profile and will be used to update the dock widget via the method <code>update_configs(self, cfg) -&gt; None</code>. This argument must be a dict, dataclass or pydantic.BaseModel. If a dict, the format must be like:</p> <pre><code>plugin_configs = {\n   \"config_0\": {\"value\": 0, \"tooltip\": ...},\n   \"config_1\": {\"value\": \"xyz\", \"tooltip\": ...},\n}\n</code></pre> <p>where only \"value\" is required. If a dataclass or pydantic.BaseModel, field objects will be used instead of the dict.</p> <pre><code>@dataclass\nclass MyPluginConfig:\n    config_0: int = Field(default=0, metadata={\"tooltip\": ...})\n    config_1: str = Field(default=\"xyz\", metadata={\"tooltip\": ...})\nplugin_configs = MyPluginConfig()\n</code></pre> <code>None</code> <code>command_id</code> <code>str</code> <p>Command ID. If not given, the function name will be used.</p> <code>None</code> Source code in <code>src\\himena\\plugins\\widget_plugins.py</code> <pre><code>def register_dock_widget_action(\n    widget_factory=None,\n    *,\n    menus: str | Sequence[str] = \"plugins\",\n    title: str | None = None,\n    area: DockArea | DockAreaString = DockArea.RIGHT,\n    allowed_areas: Sequence[DockArea | DockAreaString] | None = None,\n    keybindings=None,\n    singleton: bool = False,\n    plugin_configs: PluginConfigType | None = None,\n    command_id: str | None = None,\n):\n    \"\"\"\n    Register a widget factory as a dock widget function.\n\n    Parameters\n    ----------\n    widget_factory : callable, optional\n        Class of dock widget, or a factory function for the dock widget.\n    title : str, optional\n        Title of the dock widget.\n    area : DockArea or DockAreaString, optional\n        Initial area of the dock widget.\n    allowed_areas : sequence of DockArea or DockAreaString, optional\n        List of areas that is allowed for the dock widget.\n    keybindings : sequence of keybinding rule, optional\n        Keybindings to trigger the dock widget.\n    singleton : bool, default False\n        If true, the registered dock widget will constructed only once.\n    plugin_configs : dict, dataclass or pydantic.BaseModel, optional\n        Default configuration for the plugin. This config will be saved in the\n        application profile and will be used to update the dock widget via the method\n        `update_configs(self, cfg) -&gt; None`. This argument must be a dict, dataclass\n        or pydantic.BaseModel. If a dict, the format must be like:\n\n        ``` python\n        plugin_configs = {\n           \"config_0\": {\"value\": 0, \"tooltip\": ...},\n           \"config_1\": {\"value\": \"xyz\", \"tooltip\": ...},\n        }\n        ```\n\n        where only \"value\" is required. If a dataclass or pydantic.BaseModel, field\n        objects will be used instead of the dict.\n\n        ``` python\n        @dataclass\n        class MyPluginConfig:\n            config_0: int = Field(default=0, metadata={\"tooltip\": ...})\n            config_1: str = Field(default=\"xyz\", metadata={\"tooltip\": ...})\n        plugin_configs = MyPluginConfig()\n        ```\n    command_id : str, optional\n        Command ID. If not given, the function name will be used.\n    \"\"\"\n    kbs = normalize_keybindings(keybindings)\n\n    def _inner(wf: Callable):\n        _command_id = command_id_from_func(wf, command_id)\n        _callback = DockWidgetCallback(\n            wf,\n            title=title,\n            area=area,\n            allowed_areas=allowed_areas,\n            singleton=singleton,\n            uuid=uuid.uuid4(),\n            command_id=_command_id,\n        )\n        if singleton:\n            toggle_rule = ToggleRule(get_current=_callback.widget_visible)\n        else:\n            toggle_rule = None\n        action = Action(\n            id=_command_id,\n            title=_callback._title,\n            tooltip=tooltip_from_func(wf),\n            callback=_callback,\n            menus=norm_menus(menus),\n            keybindings=kbs,\n            toggled=toggle_rule,\n        )\n        reg = AppActionRegistry.instance()\n        reg.add_action(action)\n        if plugin_configs:\n            cfg_type = type(plugin_configs)\n            reg._plugin_default_configs[_command_id] = PluginConfigTuple(\n                _callback._title,\n                plugin_configs,\n                cfg_type,\n            )\n        return wf\n\n    return _inner if widget_factory is None else _inner(widget_factory)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.register_function","title":"<code>register_function(func=None, *, menus='plugins', title=None, types=None, enablement=None, keybindings=None, run_async=False, command_id=None)</code>","text":"<pre><code>register_function(\n    func: None = None,\n    *,\n    menus: str | Sequence[str] = \"plugins\",\n    title: str | None = None,\n    types: str | Sequence[str] | None = None,\n    enablement: BoolOp | None = None,\n    keybindings: Sequence[KeyBindingRule] | None = None,\n    run_async: bool = False,\n    command_id: str | None = None,\n) -&gt; None\n</code></pre><pre><code>register_function(\n    func: _F,\n    *,\n    menus: str | Sequence[str] = \"plugins\",\n    title: str | None = None,\n    types: str | Sequence[str] | None = None,\n    enablement: BoolOp | None = None,\n    keybindings: Sequence[KeyBindingRule] | None = None,\n    run_async: bool = False,\n    command_id: str | None = None,\n) -&gt; _F\n</code></pre> <p>Register a function as a callback of a plugin action.</p> <p>This function can be used either as a decorator or a simple function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>Function to register as an action.</p> <code>None</code> <code>menus</code> <code>str or sequence of str</code> <p>Menu(s) to add the action. Submenus are separated by <code>/</code>.</p> <code>\"plugins\"</code> <code>title</code> <code>str</code> <p>Title of the action. Name of the function will be used if not given.</p> <code>None</code> <code>types</code> <p>The <code>type</code> parameter(s) allowed as the WidgetDataModel. If this parameter is given, action will be grayed out if the active window does not satisfy the listed types.</p> <code>None</code> <code>enablement</code> <p>Expression that describes when the action will be enabled. As this argument is a generalized version of <code>types</code> argument, you cannot use both of them.</p> <code>None</code> <code>run_async</code> <code>bool</code> <p>If true, the function will be executed asynchronously. Note that if the function updates the GUI, running it asynchronously may cause issues.</p> <code>False</code> <code>command_id</code> <code>str</code> <p>Command ID. If not given, the function qualname will be used.</p> <code>None</code> Source code in <code>src\\himena\\plugins\\actions.py</code> <pre><code>def register_function(\n    func=None,\n    *,\n    menus=\"plugins\",\n    title=None,\n    types=None,\n    enablement=None,\n    keybindings=None,\n    run_async=False,\n    command_id=None,\n):\n    \"\"\"\n    Register a function as a callback of a plugin action.\n\n    This function can be used either as a decorator or a simple function.\n\n    Parameters\n    ----------\n    func : callable, optional\n        Function to register as an action.\n    menus : str or sequence of str, default \"plugins\"\n        Menu(s) to add the action. Submenus are separated by `/`.\n    title : str, optional\n        Title of the action. Name of the function will be used if not given.\n    types: str or sequence of str, optional\n        The `type` parameter(s) allowed as the WidgetDataModel. If this parameter\n        is given, action will be grayed out if the active window does not satisfy\n        the listed types.\n    enablement: Expr, optional\n        Expression that describes when the action will be enabled. As this argument\n        is a generalized version of `types` argument, you cannot use both of them.\n    run_async : bool, default False\n        If true, the function will be executed asynchronously. Note that if the function\n        updates the GUI, running it asynchronously may cause issues.\n    command_id : str, optional\n        Command ID. If not given, the function qualname will be used.\n    \"\"\"\n\n    def _inner(f: _F) -&gt; _F:\n        action = make_action_for_function(\n            f,\n            menus=menus,\n            title=title,\n            types=types,\n            enablement=enablement,\n            keybindings=keybindings,\n            run_async=run_async,\n            command_id=command_id,\n        )\n        AppActionRegistry.instance().add_action(action)\n        return f\n\n    return _inner if func is None else _inner(func)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.register_previewer_class","title":"<code>register_previewer_class(type_, widget_class)</code>","text":"<p>Register a widget class for previewing the given model type.</p> Source code in <code>src\\himena\\plugins\\widget_class.py</code> <pre><code>def register_previewer_class(type_: str, widget_class: type):\n    \"\"\"Register a widget class for previewing the given model type.\"\"\"\n\n    def inner(wcls):\n        import himena.qt\n\n        widget_id = get_widget_class_id(wcls)\n        if existing_class := _WIDGET_ID_TO_WIDGET_CLASS.get(widget_id):\n            raise ValueError(\n                f\"Widget class with ID {widget_id!r} already exists ({existing_class}).\"\n            )\n        _WIDGET_ID_TO_WIDGET_CLASS[widget_id] = wcls\n        himena.qt.register_widget_class(type_, wcls, priority=-10)\n        fn = OpenDataInFunction(type_, wcls)\n        AppActionRegistry.instance().add_action(fn.to_action())\n        fn = PreviewDataInFunction(type_, wcls)\n        AppActionRegistry.instance().add_action(fn.to_action())\n        return type_\n\n    return inner if widget_class is None else inner(widget_class)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.register_reader_plugin","title":"<code>register_reader_plugin(reader=None, *, priority=100)</code>","text":"<pre><code>register_reader_plugin(\n    reader: Callable[[Path | list[Path]], WidgetDataModel],\n    *,\n    priority: int = 100,\n) -&gt; ReaderPlugin\n</code></pre><pre><code>register_reader_plugin(\n    *, priority: int = 100\n) -&gt; Callable[\n    [Callable[[Path | list[Path]], WidgetDataModel]],\n    ReaderPlugin,\n]\n</code></pre> <p>Register a reader plugin function.</p> <p>Decorate a function to register it as a reader plugin. The function should take a <code>Path</code> or a list of <code>Path</code>s as input and return a WidgetDataModel.</p> <pre><code>from himena.plugins import register_reader_plugin\n\n@register_reader_plugin\ndef my_reader(path) -&gt; WidgetDataModel:\n    ...  # read file and return a WidgetDataModel\n</code></pre> <p>You will need to define a matcher function to tell whether this function can read a path using <code>define_matcher</code> method.</p> <pre><code>from himena import StandardType\n\n@my_reader.define_matcher\ndef _(path: Path):\n    if path.suffix == \".txt\":\n        return StandardType.TEXT  # StandardType.TEXT == \"text\"\n    return None\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>int</code> <p>Priority of choosing this reader when multiple readers are available. The default value 100 is higher than the himena builtin readers, so that your reader will prioritized over the default ones. If priority is less than 0, it will not be used unless users intentionally choose this plugin.</p> <code>100</code> Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>def register_reader_plugin(reader=None, *, priority=100):\n    \"\"\"Register a reader plugin function.\n\n    Decorate a function to register it as a reader plugin. The function should take a\n    `Path` or a list of `Path`s as input and return a WidgetDataModel.\n\n    ``` python\n    from himena.plugins import register_reader_plugin\n\n    @register_reader_plugin\n    def my_reader(path) -&gt; WidgetDataModel:\n        ...  # read file and return a WidgetDataModel\n    ```\n\n    You will need to define a matcher function to tell whether this function can read\n    a path using `define_matcher` method.\n\n    ```python\n    from himena import StandardType\n\n    @my_reader.define_matcher\n    def _(path: Path):\n        if path.suffix == \".txt\":\n            return StandardType.TEXT  # StandardType.TEXT == \"text\"\n        return None\n    ```\n\n    Parameters\n    ----------\n    priority : int, default 100\n        Priority of choosing this reader when multiple readers are available. The\n        default value 100 is higher than the himena builtin readers, so that your reader\n        will prioritized over the default ones. If priority is less than 0, it will not\n        be used unless users intentionally choose this plugin.\n    \"\"\"\n\n    def _inner(func):\n        if not callable(func):\n            raise ValueError(\"Reader plugin must be callable.\")\n        ins = ReaderStore().instance()\n\n        reader_plugin = ReaderPlugin(func, priority=priority)\n        ins.add_reader(reader_plugin)\n        return reader_plugin\n\n    return _inner if reader is None else _inner(reader)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.register_widget_class","title":"<code>register_widget_class(type_, widget_class=None, priority=100)</code>","text":"<pre><code>register_widget_class(\n    type_: str, widget_class: _T, priority: int = 100\n) -&gt; _T\n</code></pre><pre><code>register_widget_class(\n    type_: str, widget_class: None, priority: int = 100\n) -&gt; Callable[[_T], _T]\n</code></pre> <p>Register a frontend widget class for the given model type.</p> <p>The <code>__init__</code> method of the registered class must not take any argument. The class must implement <code>update_model</code> method to update the widget state from a WidgetDataModel.</p> <pre><code>@register_widget(\"text\")\nclass MyTextEdit(QtW.QPlainTextEdit):\n    def update_model(self, model: WidgetDataModel):\n        self.setPlainText(model.value)\n</code></pre> <p>There are other method names that can be implemented to make the widget more functional.</p> <ul> <li><code>to_model(self) -&gt; WidgetDataModel</code>:</li> <li><code>model_type(self) -&gt; str</code>:</li> <li><code>control_widget(self) -&gt; &lt;widget&gt;</code>:</li> <li><code>is_modified(self) -&gt; bool</code>:</li> <li><code>set_modified(self, modified: bool)</code>:</li> <li><code>size_hint(self) -&gt; tuple[int, int]</code>:</li> <li><code>is_editable(self) -&gt; bool</code>:</li> <li><code>set_editable(self, editable: bool)</code>:</li> <li><code>dropped_callback(self, other: WidgetDataModel)</code>:</li> <li><code>allowed_drop_types(self) -&gt; list[str]</code>:</li> <li><code>display_name(cls) -&gt; str</code>:</li> <li><code>theme_changed_callback(self, theme: Theme)</code>:</li> <li><code>widget_activated_callback(self)</code>:</li> <li><code>widget_closed_callback(self)</code>:</li> <li><code>widget_resized_callback(self, size_old, size_new)</code>:</li> </ul> Source code in <code>src\\himena\\plugins\\widget_class.py</code> <pre><code>def register_widget_class(type_, widget_class=None, priority=100):\n    \"\"\"Register a frontend widget class for the given model type.\n\n    The `__init__` method of the registered class must not take any argument. The class\n    must implement `update_model` method to update the widget state from a\n    WidgetDataModel.\n\n    ``` python\n    @register_widget(\"text\")\n    class MyTextEdit(QtW.QPlainTextEdit):\n        def update_model(self, model: WidgetDataModel):\n            self.setPlainText(model.value)\n    ```\n\n    There are other method names that can be implemented to make the widget more\n    functional.\n\n    - `to_model(self) -&gt; WidgetDataModel`:\n    - `model_type(self) -&gt; str`:\n    - `control_widget(self) -&gt; &lt;widget&gt;`:\n    - `is_modified(self) -&gt; bool`:\n    - `set_modified(self, modified: bool)`:\n    - `size_hint(self) -&gt; tuple[int, int]`:\n    - `is_editable(self) -&gt; bool`:\n    - `set_editable(self, editable: bool)`:\n    - `dropped_callback(self, other: WidgetDataModel)`:\n    - `allowed_drop_types(self) -&gt; list[str]`:\n    - `display_name(cls) -&gt; str`:\n    - `theme_changed_callback(self, theme: Theme)`:\n    - `widget_activated_callback(self)`:\n    - `widget_closed_callback(self)`:\n    - `widget_resized_callback(self, size_old, size_new)`:\n    \"\"\"\n\n    def inner(wcls):\n        import himena.qt\n\n        widget_id = get_widget_class_id(wcls)\n        if existing_class := _WIDGET_ID_TO_WIDGET_CLASS.get(widget_id):\n            raise ValueError(\n                f\"Widget class with ID {widget_id!r} already exists ({existing_class}).\"\n            )\n        _WIDGET_ID_TO_WIDGET_CLASS[widget_id] = wcls\n        himena.qt.register_widget_class(type_, wcls, priority=priority)\n        fn = OpenDataInFunction(type_, wcls)\n        AppActionRegistry.instance().add_action(fn.to_action())\n        wcls.__himena_model_type__ = type_\n        return wcls\n\n    return inner if widget_class is None else inner(widget_class)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.register_writer_plugin","title":"<code>register_writer_plugin(writer=None, *, priority=100)</code>","text":"<pre><code>register_writer_plugin(\n    writer: Callable[[WidgetDataModel, Path], Any],\n    *,\n    priority: int = 100,\n) -&gt; WriterPlugin\n</code></pre><pre><code>register_writer_plugin(\n    *, priority: int = 100\n) -&gt; Callable[\n    [Callable[[WidgetDataModel, Path], Any]], WriterPlugin\n]\n</code></pre> <p>Register a writer plugin function.</p> <p>Decorate a function to register it as a writer plugin. The function should take a <code>Path</code> as a save path and a <code>WidgetDataModel</code>.</p> <pre><code>from himena.plugins import register_writer_plugin\n\n@register_writer_plugin\ndef my_writer(path, model) -&gt; None:\n    ...  # read file and return a WidgetDataModel\n</code></pre> <p>You will need to define a matcher function to tell whether this function can write a data model to the specified path using <code>define_matcher</code> method. Unlike reader plugins, matchers should return bool.</p> <pre><code>from himena import StandardType, WidgetDataModel\n\n@my_writer.define_matcher\ndef _(path: Path, model: WidgetDataModel):\n    if path.suffix == \".txt\":\n        return True\n    return False\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>int</code> <p>Priority of choosing this writer when multiple writers are available. The default value 100 is higher than the himena builtin writers, so that your writer will prioritized over the default ones. If priority is less than 0, it will not be used unless users intentionally choose this plugin.</p> <code>100</code> Source code in <code>src\\himena\\plugins\\io.py</code> <pre><code>def register_writer_plugin(writer=None, *, priority=100):\n    \"\"\"Register a writer plugin function.\n\n    Decorate a function to register it as a writer plugin. The function should take a\n    `Path` as a save path and a `WidgetDataModel`.\n\n    ``` python\n    from himena.plugins import register_writer_plugin\n\n    @register_writer_plugin\n    def my_writer(path, model) -&gt; None:\n        ...  # read file and return a WidgetDataModel\n    ```\n\n    You will need to define a matcher function to tell whether this function can write\n    a data model to the specified path using `define_matcher` method. Unlike reader\n    plugins, matchers should return bool.\n\n    ```python\n    from himena import StandardType, WidgetDataModel\n\n    @my_writer.define_matcher\n    def _(path: Path, model: WidgetDataModel):\n        if path.suffix == \".txt\":\n            return True\n        return False\n    ```\n\n    Parameters\n    ----------\n    priority : int, default 100\n        Priority of choosing this writer when multiple writers are available. The\n        default value 100 is higher than the himena builtin writers, so that your writer\n        will prioritized over the default ones. If priority is less than 0, it will not\n        be used unless users intentionally choose this plugin.\n    \"\"\"\n\n    def _inner(func):\n        if not callable(func):\n            raise ValueError(\"Writer plugin must be callable.\")\n        ins = WriterStore().instance()\n\n        writer_plugin = WriterPlugin(func, priority=priority)\n        ins.add_writer(writer_plugin)\n        return writer_plugin\n\n    return _inner if writer is None else _inner(writer)\n</code></pre>"},{"location":"api/plugins/#himena.plugins.validate_protocol","title":"<code>validate_protocol(f)</code>","text":"<p>Check if the method is allowed as a himena protocol.</p> Source code in <code>src\\himena\\plugins\\_checker.py</code> <pre><code>def validate_protocol(f: _T) -&gt; _T:\n    \"\"\"Check if the method is allowed as a himena protocol.\"\"\"\n    if f.__name__ not in _ALLOWED_METHODS:\n        raise ValueError(f\"Method {f} is not an allowed protocol name.\")\n    return f\n</code></pre>"},{"location":"api/plugins/#himena.plugins.widget_classes","title":"<code>widget_classes()</code>","text":"<p>Get the mapping of widget ID to widget class.</p> Source code in <code>src\\himena\\plugins\\widget_class.py</code> <pre><code>def widget_classes() -&gt; MappingProxyType[str, type]:\n    \"\"\"Get the mapping of widget ID to widget class.\"\"\"\n    from himena.qt.registry._api import _APP_TYPE_TO_QWIDGET\n\n    out = {}\n    for widget_list in _APP_TYPE_TO_QWIDGET.values():\n        for item in widget_list:\n            out[item.type] = item.widget_class\n    return MappingProxyType(out)\n</code></pre>"},{"location":"api/profile/","title":"himena.profile","text":""},{"location":"api/profile/#himena.profile.AppProfile","title":"<code>AppProfile</code>","text":"<p>Model of a profile.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the profile.</p> <code>'default'</code> <code>plugins</code> <code>list[str]</code> <p>List of plugins to load.</p> <code>['himena_builtins.qt.console', 'himena_builtins.qt.explorer', 'himena_builtins.qt.history', 'himena_builtins.qt.output', 'himena_builtins.qt.plot', 'himena_builtins.qt.widgets', 'himena_builtins.tools', 'himena_builtins.io', 'himena_builtins.new']</code> <code>theme</code> <code>str</code> <p>Theme to use.</p> <code>'light-green'</code> <code>startup_commands</code> <code>list[tuple[str, Optional[dict[str, Any]]]]</code> <p>Startup commands that will be executed when the app starts.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\profile.py</code> <pre><code>class AppProfile(BaseModel):\n    \"\"\"Model of a profile.\"\"\"\n\n    name: str = Field(\n        default=\"default\", description=\"Name of the profile.\", frozen=True\n    )\n    plugins: list[str] = Field(\n        default_factory=_default_plugins, description=\"List of plugins to load.\"\n    )\n    theme: str = Field(default=\"light-green\", description=\"Theme to use.\")\n    startup_commands: list[tuple[str, dict[str, Any] | None]] = Field(\n        default_factory=list,\n        description=\"Startup commands that will be executed when the app starts.\",\n    )\n    plugin_configs: dict[str, dict[str, Any]] = Field(default_factory=dict)\n\n    @classmethod\n    def from_json(cls, path) -&gt; \"AppProfile\":\n        \"\"\"Construct an AppProfile from a json file.\"\"\"\n        with open(path) as f:\n            data = json.load(f)\n        return cls(**data)\n\n    @classmethod\n    def default(cls, save: bool = False) -&gt; \"AppProfile\":\n        \"\"\"Return the default profile.\"\"\"\n        prof = AppProfile()\n        if save and not (profile_dir() / f\"{prof.name}.json\").exists():\n            prof.save()\n        return prof\n\n    def save(self, path: str | Path | None = None) -&gt; None:\n        \"\"\"Save profile as a json file.\"\"\"\n        if path is None:\n            path = profile_dir() / f\"{self.name}.json\"\n        with open(path, \"w\") as f:\n            json.dump(self.model_dump(), f, indent=4)\n        return None\n\n    def with_name(self, name: str) -&gt; \"AppProfile\":\n        \"\"\"Return a new profile with a new name.\"\"\"\n        return self.model_copy(update={\"name\": name})\n\n    def with_plugins(self, plugins: list[str]) -&gt; \"AppProfile\":\n        \"\"\"Return a new profile with new plugins.\"\"\"\n        return self.model_copy(update={\"plugins\": plugins})\n\n    def with_plugin_configs(self, configs: dict[str, dict[str, Any]]) -&gt; \"AppProfile\":\n        \"\"\"Return a new profile with new plugin configs.\"\"\"\n        return self.model_copy(update={\"plugin_configs\": configs})\n\n    def update_plugin_config(self, plugin_id: str, **kwargs) -&gt; None:\n        \"\"\"Update the config of the plugin specified by `plugin_id`\"\"\"\n        from himena.plugins.actions import AppActionRegistry\n        from himena.plugins.widget_plugins import WidgetCallbackBase\n\n        reg = AppActionRegistry.instance()\n        configs = self.plugin_configs.copy()\n        # NOTE: during development, keys of cur_config and configs[plugin_id] may\n        # differ. `cur_config` has all the keys that should exist in the current\n        # implementation.\n        cur_config = reg._plugin_default_configs[plugin_id].as_dict()\n        if plugin_id in configs:\n            # Profile already has the plugin config\n            for ckey, cval in configs[plugin_id].items():\n                if ckey in cur_config:\n                    cur_config[ckey] = cval\n        for k, v in kwargs.items():\n            if k in cur_config:\n                cur_config[k][\"value\"] = v\n        configs[plugin_id] = cur_config\n        self.with_plugin_configs(configs).save()\n\n        # update existing dock widgets with the new config\n        params = {}\n        for key, opt in cur_config.items():\n            params[key] = opt[\"value\"]\n        if cb := WidgetCallbackBase.instance_for_command_id(plugin_id):\n            for dock in cb._all_widgets:\n                # the internal widget should always has the method \"update_configs\"\n                dock.update_configs(params)\n\n    @field_validator(\"name\")\n    def _validate_name(cls, value):\n        # check if value is a valid file name\n        if not all(c in ALLOWED_LETTERS for c in value):\n            raise ValueError(f\"Invalid profile name: {value}\")\n        return value\n</code></pre>"},{"location":"api/profile/#himena.profile.AppProfile.default","title":"<code>default(save=False)</code>  <code>classmethod</code>","text":"<p>Return the default profile.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>@classmethod\ndef default(cls, save: bool = False) -&gt; \"AppProfile\":\n    \"\"\"Return the default profile.\"\"\"\n    prof = AppProfile()\n    if save and not (profile_dir() / f\"{prof.name}.json\").exists():\n        prof.save()\n    return prof\n</code></pre>"},{"location":"api/profile/#himena.profile.AppProfile.from_json","title":"<code>from_json(path)</code>  <code>classmethod</code>","text":"<p>Construct an AppProfile from a json file.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>@classmethod\ndef from_json(cls, path) -&gt; \"AppProfile\":\n    \"\"\"Construct an AppProfile from a json file.\"\"\"\n    with open(path) as f:\n        data = json.load(f)\n    return cls(**data)\n</code></pre>"},{"location":"api/profile/#himena.profile.AppProfile.save","title":"<code>save(path=None)</code>","text":"<p>Save profile as a json file.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def save(self, path: str | Path | None = None) -&gt; None:\n    \"\"\"Save profile as a json file.\"\"\"\n    if path is None:\n        path = profile_dir() / f\"{self.name}.json\"\n    with open(path, \"w\") as f:\n        json.dump(self.model_dump(), f, indent=4)\n    return None\n</code></pre>"},{"location":"api/profile/#himena.profile.AppProfile.update_plugin_config","title":"<code>update_plugin_config(plugin_id, **kwargs)</code>","text":"<p>Update the config of the plugin specified by <code>plugin_id</code></p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def update_plugin_config(self, plugin_id: str, **kwargs) -&gt; None:\n    \"\"\"Update the config of the plugin specified by `plugin_id`\"\"\"\n    from himena.plugins.actions import AppActionRegistry\n    from himena.plugins.widget_plugins import WidgetCallbackBase\n\n    reg = AppActionRegistry.instance()\n    configs = self.plugin_configs.copy()\n    # NOTE: during development, keys of cur_config and configs[plugin_id] may\n    # differ. `cur_config` has all the keys that should exist in the current\n    # implementation.\n    cur_config = reg._plugin_default_configs[plugin_id].as_dict()\n    if plugin_id in configs:\n        # Profile already has the plugin config\n        for ckey, cval in configs[plugin_id].items():\n            if ckey in cur_config:\n                cur_config[ckey] = cval\n    for k, v in kwargs.items():\n        if k in cur_config:\n            cur_config[k][\"value\"] = v\n    configs[plugin_id] = cur_config\n    self.with_plugin_configs(configs).save()\n\n    # update existing dock widgets with the new config\n    params = {}\n    for key, opt in cur_config.items():\n        params[key] = opt[\"value\"]\n    if cb := WidgetCallbackBase.instance_for_command_id(plugin_id):\n        for dock in cb._all_widgets:\n            # the internal widget should always has the method \"update_configs\"\n            dock.update_configs(params)\n</code></pre>"},{"location":"api/profile/#himena.profile.AppProfile.with_name","title":"<code>with_name(name)</code>","text":"<p>Return a new profile with a new name.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def with_name(self, name: str) -&gt; \"AppProfile\":\n    \"\"\"Return a new profile with a new name.\"\"\"\n    return self.model_copy(update={\"name\": name})\n</code></pre>"},{"location":"api/profile/#himena.profile.AppProfile.with_plugin_configs","title":"<code>with_plugin_configs(configs)</code>","text":"<p>Return a new profile with new plugin configs.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def with_plugin_configs(self, configs: dict[str, dict[str, Any]]) -&gt; \"AppProfile\":\n    \"\"\"Return a new profile with new plugin configs.\"\"\"\n    return self.model_copy(update={\"plugin_configs\": configs})\n</code></pre>"},{"location":"api/profile/#himena.profile.AppProfile.with_plugins","title":"<code>with_plugins(plugins)</code>","text":"<p>Return a new profile with new plugins.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def with_plugins(self, plugins: list[str]) -&gt; \"AppProfile\":\n    \"\"\"Return a new profile with new plugins.\"\"\"\n    return self.model_copy(update={\"plugins\": plugins})\n</code></pre>"},{"location":"api/profile/#himena.profile.data_dir","title":"<code>data_dir()</code>","text":"<p>Get the user data directory.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def data_dir() -&gt; Path:\n    \"\"\"Get the user data directory.\"\"\"\n    if not USER_DATA_DIR.exists():\n        USER_DATA_DIR.mkdir(parents=True)\n    return USER_DATA_DIR\n</code></pre>"},{"location":"api/profile/#himena.profile.new_app_profile","title":"<code>new_app_profile(name)</code>","text":"<p>Create a new profile.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def new_app_profile(name: str) -&gt; None:\n    \"\"\"Create a new profile.\"\"\"\n    path = profile_dir() / f\"{name}.json\"\n    if path.exists():\n        raise ValueError(f\"Profile {name!r} already exists.\")\n    profile = AppProfile.default().with_name(name)\n    return profile.save(path)\n</code></pre>"},{"location":"api/profile/#himena.profile.patch_user_data_dir","title":"<code>patch_user_data_dir(path)</code>","text":"<p>Change the user data directory to avoid pytest updates the local state.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>@contextmanager\ndef patch_user_data_dir(path: str | Path):\n    \"\"\"Change the user data directory to avoid pytest updates the local state.\"\"\"\n    global USER_DATA_DIR\n    old = USER_DATA_DIR\n    USER_DATA_DIR = Path(path)\n    try:\n        yield\n    finally:\n        USER_DATA_DIR = old\n</code></pre>"},{"location":"api/profile/#himena.profile.remove_app_profile","title":"<code>remove_app_profile(name)</code>","text":"<p>Remove an existing profile.</p> Source code in <code>src\\himena\\profile.py</code> <pre><code>def remove_app_profile(name: str) -&gt; None:\n    \"\"\"Remove an existing profile.\"\"\"\n    path = profile_dir() / f\"{name}.json\"\n    return path.unlink()\n</code></pre>"},{"location":"api/types/","title":"himena.types","text":""},{"location":"api/types/#himena.types.Parametric","title":"<code>Parametric = NewType('Parametric', Any)</code>  <code>module-attribute</code>","text":"<p>Callback for a parametric function.</p> <p>This type can be interpreted by the injection store processor. For example, in the following code, <code>my_plugin_function</code> will be converted into a parametric widget with inputs <code>a</code> and <code>b</code>..</p> <pre><code>from himena.plugin import register_function\n@register_function(...)\ndef my_plugin_function(...) -&gt; Parametric:\n    def callback_func(a: int, b: str) -&gt; WidgetDataModel:\n        ...\n    return my_plugin_function\n</code></pre>"},{"location":"api/types/#himena.types.WidgetConstructor","title":"<code>WidgetConstructor = NewType('WidgetConstructor', object)</code>  <code>module-attribute</code>","text":"<p>This type is used for the return annotation.</p> <pre><code>from himena.plugin import register_function\n@register_function(...)\ndef my_plugin_function() -&gt; WidgetConstructor:\n    return MyWidget\n</code></pre>"},{"location":"api/types/#himena.types.WidgetType","title":"<code>WidgetType = NewType('WidgetType', object)</code>  <code>module-attribute</code>","text":"<p>This type is used for the return annotation.</p> <pre><code>from himena.plugin import register_function\n@register_function(...)\ndef my_plugin_function() -&gt; WidgetType:\n    return MyWidget()\n</code></pre>"},{"location":"api/types/#himena.types.BackendInstructions","title":"<code>BackendInstructions</code>","text":"<p>Instructions for the backend that are only relevant to user interface.</p> <p>Parameters:</p> Name Type Description Default <code>animate</code> <code>bool</code> <p>Whether to animate</p> <code>True</code> <code>confirm</code> <code>bool</code> <p>Whether to show a confirmation dialog</p> <code>True</code> <code>choose_one_dialog_response</code> <code>Callable[list, Any] | None</code> <p>If provided, choose-one dialog will be skipped and this function will be called to get the response.</p> <code>None</code> <code>file_dialog_response</code> <code>Callable[list, Any] | None</code> <p>If provided, file dialog will be skipped and this function will be called to get the response.</p> <code>None</code> <code>gui_execution</code> <code>bool</code> <code>True</code> <code>process_model_output</code> <code>bool</code> <code>True</code> <code>unwrap_future</code> <code>bool</code> <code>False</code> Source code in <code>src\\himena\\types.py</code> <pre><code>class BackendInstructions(BaseModel):\n    \"\"\"Instructions for the backend that are only relevant to user interface.\"\"\"\n\n    model_config = PYDANTIC_CONFIG_STRICT\n\n    animate: bool = Field(\n        default=True,\n        description=\"Whether to animate\",\n        frozen=True,\n    )\n    confirm: bool = Field(\n        default=True,\n        description=\"Whether to show a confirmation dialog\",\n        frozen=True,\n    )\n    choose_one_dialog_response: Callable[[], Any] | None = Field(\n        default=None,\n        description=\"If provided, choose-one dialog will be skipped and this function \"\n        \"will be called to get the response.\",\n        frozen=True,\n    )\n    file_dialog_response: Callable[[], Any] | None = Field(\n        default=None,\n        description=\"If provided, file dialog will be skipped and this function will \"\n        \"be called to get the response.\",\n        frozen=True,\n    )\n    gui_execution: bool = Field(default=True)\n    process_model_output: bool = Field(default=True)\n    unwrap_future: bool = Field(default=False)\n\n    def updated(self, **kwargs) -&gt; \"BackendInstructions\":\n        return self.model_copy(update=kwargs)\n</code></pre>"},{"location":"api/types/#himena.types.ClipboardDataModel","title":"<code>ClipboardDataModel</code>","text":"<p>Data model for a clipboard data.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>Text in the clipboard if exists.</p> <code>None</code> <code>html</code> <code>str | None</code> <p>HTML in the clipboard if exists.</p> <code>None</code> <code>image</code> <code>Any | None</code> <p>Image in the clipboard if exists.</p> <code>None</code> <code>files</code> <code>list[Path]</code> <p>List of file paths in the clipboard if exists.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\types.py</code> <pre><code>class ClipboardDataModel(BaseModel):\n    \"\"\"Data model for a clipboard data.\"\"\"\n\n    model_config = PYDANTIC_CONFIG_STRICT\n\n    text: str | None = Field(\n        default=None,\n        description=\"Text in the clipboard if exists.\",\n    )\n    html: str | None = Field(\n        default=None,\n        description=\"HTML in the clipboard if exists.\",\n    )\n    image: Any | None = Field(\n        default=None,\n        description=\"Image in the clipboard if exists.\",\n    )\n    files: list[Path] = Field(\n        default_factory=list,\n        description=\"List of file paths in the clipboard if exists.\",\n    )\n</code></pre>"},{"location":"api/types/#himena.types.DockArea","title":"<code>DockArea</code>","text":"<p>Area of the dock widget.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>class DockArea(StrEnum):\n    \"\"\"Area of the dock widget.\"\"\"\n\n    TOP = \"top\"\n    BOTTOM = \"bottom\"\n    LEFT = \"left\"\n    RIGHT = \"right\"\n</code></pre>"},{"location":"api/types/#himena.types.DragDataModel","title":"<code>DragDataModel</code>","text":"<p>Parameters:</p> Name Type Description Default <code>getter</code> <code>Callable[list, WidgetDataModel] | WidgetDataModel</code> <p>Getter function to get the data model.</p> required <code>type</code> <code>str | None</code> <p>Type of the internal data.</p> <code>None</code> Source code in <code>src\\himena\\types.py</code> <pre><code>class DragDataModel(BaseModel):\n    model_config = PYDANTIC_CONFIG_STRICT\n    getter: Callable[[], WidgetDataModel] | WidgetDataModel = Field(\n        ..., description=\"Getter function to get the data model.\"\n    )\n    type: str | None = Field(None, description=\"Type of the internal data.\")\n\n    def inferred_type(self) -&gt; str:\n        if self.type is not None:\n            return self.type\n        if callable(self.getter):\n            model = self.getter()\n        else:\n            model = self.getter\n        return model.type\n\n    def data_model(self) -&gt; WidgetDataModel:\n        if isinstance(self.getter, WidgetDataModel):\n            model = self.getter\n        else:\n            model = self.getter()\n        return model\n\n    def widget_accepts_me(self, widget: Any) -&gt; bool:\n        \"\"\"Return true if the widget accepts this data model to be dropped.\"\"\"\n        if hasattr(widget, \"allowed_drop_types\"):\n            types = widget.allowed_drop_types()\n            if self.type is None:\n                return True  # not specified. Just allow it.\n            if self.type in types:\n                return True\n        elif hasattr(widget, \"dropped_callback\"):\n            return True\n        return False\n</code></pre>"},{"location":"api/types/#himena.types.DragDataModel.widget_accepts_me","title":"<code>widget_accepts_me(widget)</code>","text":"<p>Return true if the widget accepts this data model to be dropped.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def widget_accepts_me(self, widget: Any) -&gt; bool:\n    \"\"\"Return true if the widget accepts this data model to be dropped.\"\"\"\n    if hasattr(widget, \"allowed_drop_types\"):\n        types = widget.allowed_drop_types()\n        if self.type is None:\n            return True  # not specified. Just allow it.\n        if self.type in types:\n            return True\n    elif hasattr(widget, \"dropped_callback\"):\n        return True\n    return False\n</code></pre>"},{"location":"api/types/#himena.types.DropResult","title":"<code>DropResult</code>","text":"<p>Model that can be returned by <code>dropped_callback</code> protocol.</p> <p>Parameters:</p> Name Type Description Default <code>delete_input</code> <code>bool</code> <code>False</code> <code>outputs</code> <code>WidgetDataModel | list[WidgetDataModel] | None</code> <code>None</code> <p>Attributes:</p> Name Type Description <code>delete_input</code> <code>bool</code> <p>Whether to delete the input data if drop succeeded.</p> <code>outputs</code> <code>WidgetDataModel | list[WidgetDataModel] | None</code> <p>If given, the output data will be added to the GUI.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>class DropResult(BaseModel):\n    \"\"\"Model that can be returned by `dropped_callback` protocol.\n\n    Attributes\n    ----------\n    delete_input : bool\n        Whether to delete the input data if drop succeeded.\n    outputs : WidgetDataModel | list[WidgetDataModel] | None\n        If given, the output data will be added to the GUI.\n    \"\"\"\n\n    delete_input: bool = False\n    outputs: WidgetDataModel | list[WidgetDataModel] | None = Field(None)\n</code></pre>"},{"location":"api/types/#himena.types.FutureInfo","title":"<code>FutureInfo</code>  <code>dataclass</code>","text":"<p>FutureInfo(type_hint: Any, track: himena.types.ModelTrack | None = None, kwargs: dict[str, typing.Any] = , top_left: tuple[int, int] | None = None, size: Optional[himena.types.Size[int]] = None) <p>Parameters:</p> Name Type Description Default <code>type_hint</code> <code>Any</code> required <code>track</code> <code>ModelTrack | None</code> <code>None</code> <code>top_left</code> <code>tuple[int, int] | None</code> <code>None</code> <code>size</code> <code>Size[int] | None</code> <code>None</code> Source code in <code>src\\himena\\types.py</code> <pre><code>@dataclass(frozen=True)\nclass FutureInfo(_HasDynamicAttribute):\n    _ATTR_NAME: ClassVar[str] = \"__himena_future_info__\"\n\n    type_hint: Any\n    track: ModelTrack | None = None\n    kwargs: dict[str, Any] = field(default_factory=dict)\n    top_left: tuple[int, int] | None = None\n    size: Size[int] | None = None\n\n    def resolve_type_hint(self, ns: dict[str, Any]) -&gt; \"FutureInfo\":\n        if isinstance(self.type_hint, str):\n            typ = ns.get(self.type_hint)\n            if typ is None:\n                raise ValueError(f\"Could not resolve the type hint: {self.type_hint}\")\n            type_hint = typ\n        else:\n            type_hint = self.type_hint\n        return FutureInfo(\n            type_hint=type_hint,\n            track=self.track,\n            kwargs=self.kwargs,\n            top_left=self.top_left,\n            size=self.size,\n        )\n</code></pre>"},{"location":"api/types/#himena.types.GenericModel","title":"<code>GenericModel</code>","text":"Source code in <code>src\\himena\\types.py</code> <pre><code>class GenericModel(BaseModel):\n    def __class_getitem__(cls, item):\n        return cls\n</code></pre>"},{"location":"api/types/#himena.types.GuiConfiguration","title":"<code>GuiConfiguration</code>  <code>dataclass</code>","text":"<p>Configuration for parametric widget (interpreted by the injection processor)</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str | None</code> <code>None</code> <code>preview</code> <code>bool</code> <code>False</code> <code>auto_close</code> <code>bool</code> <code>True</code> <code>show_parameter_labels</code> <code>bool</code> <code>True</code> <code>run_async</code> <code>bool</code> <code>False</code> <code>result_as</code> <code>Literal[str, str, str]</code> <code>'window'</code> Source code in <code>src\\himena\\types.py</code> <pre><code>@dataclass\nclass GuiConfiguration(_HasDynamicAttribute):\n    \"\"\"Configuration for parametric widget (interpreted by the injection processor)\"\"\"\n\n    _ATTR_NAME: ClassVar[str] = \"__himena_gui_config__\"\n\n    title: str | None = None\n    preview: bool = False\n    auto_close: bool = True\n    show_parameter_labels: bool = True\n    run_async: bool = False\n    result_as: Literal[\"window\", \"below\", \"right\"] = \"window\"\n\n    def asdict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the configuration as a dictionary.\"\"\"\n        return asdict(self)\n</code></pre>"},{"location":"api/types/#himena.types.GuiConfiguration.asdict","title":"<code>asdict()</code>","text":"<p>Return the configuration as a dictionary.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def asdict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the configuration as a dictionary.\"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"api/types/#himena.types.Margins","title":"<code>Margins</code>  <code>dataclass</code>","text":"<p>Margins(left: ~_V, top: ~_V, right: ~_V, bottom: ~_V)</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>~_V</code> required <code>top</code> <code>~_V</code> required <code>right</code> <code>~_V</code> required <code>bottom</code> <code>~_V</code> required Source code in <code>src\\himena\\types.py</code> <pre><code>@dataclass(frozen=True)\nclass Margins(Generic[_V]):\n    left: _V\n    top: _V\n    right: _V\n    bottom: _V\n\n    def __iter__(self):\n        \"\"\"Iterate over the field to make this class tuple-like.\"\"\"\n        return iter((self.left, self.top, self.right, self.bottom))\n\n    @classmethod\n    def from_rects(cls, inner: Rect[_V], outer: Rect[_V]) -&gt; \"Margins[_V]\":\n        \"\"\"Calculate the margins from the inner and outer rectangles.\"\"\"\n        return cls(\n            inner.left - outer.left,\n            inner.top - outer.top,\n            outer.right - inner.right,\n            outer.bottom - inner.bottom,\n        )\n</code></pre>"},{"location":"api/types/#himena.types.Margins.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the field to make this class tuple-like.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over the field to make this class tuple-like.\"\"\"\n    return iter((self.left, self.top, self.right, self.bottom))\n</code></pre>"},{"location":"api/types/#himena.types.Margins.from_rects","title":"<code>from_rects(inner, outer)</code>  <code>classmethod</code>","text":"<p>Calculate the margins from the inner and outer rectangles.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>@classmethod\ndef from_rects(cls, inner: Rect[_V], outer: Rect[_V]) -&gt; \"Margins[_V]\":\n    \"\"\"Calculate the margins from the inner and outer rectangles.\"\"\"\n    return cls(\n        inner.left - outer.left,\n        inner.top - outer.top,\n        outer.right - inner.right,\n        outer.bottom - inner.bottom,\n    )\n</code></pre>"},{"location":"api/types/#himena.types.ModelTrack","title":"<code>ModelTrack</code>  <code>dataclass</code>","text":"<p>Model to track how model is created.</p> <p>Parameters:</p> Name Type Description Default <code>command_id</code> <code>str</code> required <code>contexts</code> <code>list</code> <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p> <code>&lt;dynamic&gt;</code> <code>workflow</code> <code>Workflow</code> <p>Container of WorkflowStep instances.</p> <p>The data structure of a workflow is a directed acyclic graph. Each node is a WorkflowStep instance, and the edges are defined inside each CommandExecution instance. Each node is tagged with a unique ID named <code>id</code>, which is used as a mathematical identifier for the node.</p> <code>&lt;dynamic&gt;</code> <code>time_start</code> <code>float</code> <code>0.0</code> Source code in <code>src\\himena\\types.py</code> <pre><code>@dataclass(frozen=True)\nclass ModelTrack(_HasDynamicAttribute):\n    \"\"\"Model to track how model is created.\"\"\"\n\n    _ATTR_NAME: ClassVar[str] = \"__himena_model_track__\"\n\n    command_id: str\n    contexts: list = field(default_factory=list)\n    workflow: Workflow = field(default_factory=Workflow)\n    time_start: float = field(default=0.0)\n\n    def to_workflow(self, parameters: dict[str, Any]) -&gt; Workflow:\n        params = []\n        more_workflows: list[Workflow] = []\n        for k, v in parameters.items():\n            if k == \"is_previewing\":\n                continue\n            param, wf = parse_parameter(k, v)\n            params.append(param)\n            more_workflows.append(wf)\n        workflow = Workflow.concat([self.workflow] + more_workflows)\n        return workflow.with_step(\n            CommandExecution(\n                command_id=self.command_id,\n                contexts=self.contexts,\n                parameters=params,\n                execution_time=timeit.default_timer() - self.time_start,\n            )\n        )\n</code></pre>"},{"location":"api/types/#himena.types.NewWidgetBehavior","title":"<code>NewWidgetBehavior</code>","text":"<p>Behavior of adding a widget.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>class NewWidgetBehavior(StrEnum):\n    \"\"\"Behavior of adding a widget.\"\"\"\n\n    TAB = \"tab\"\n    WINDOW = \"window\"\n</code></pre>"},{"location":"api/types/#himena.types.ParametricWidgetProtocol","title":"<code>ParametricWidgetProtocol</code>","text":"<p>Protocol used for return annotation of a parametric widget.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>class ParametricWidgetProtocol:\n    \"\"\"Protocol used for return annotation of a parametric widget.\"\"\"\n\n    def __new__(cls, *args, **kwargs) -&gt; None:\n        if cls is ParametricWidgetProtocol:\n            raise TypeError(\"ParametricWidgetProtocol cannot be instantiated.\")\n        return super().__new__(cls)\n\n    def get_output(self, *args, **kwargs) -&gt; Any:\n        raise NotImplementedError\n</code></pre>"},{"location":"api/types/#himena.types.Rect","title":"<code>Rect</code>  <code>dataclass</code>","text":"<p>Rectangle use for any place.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>~_V</code> required <code>top</code> <code>~_V</code> required <code>width</code> <code>~_V</code> required <code>height</code> <code>~_V</code> required Source code in <code>src\\himena\\types.py</code> <pre><code>@dataclass(frozen=True)\nclass Rect(Generic[_V]):\n    \"\"\"Rectangle use for any place.\"\"\"\n\n    left: _V\n    top: _V\n    width: _V\n    height: _V\n\n    @property\n    def right(self):\n        return self.left + self.width\n\n    @property\n    def bottom(self):\n        return self.top + self.height\n\n    def with_left(self, left: _V) -&gt; \"Rect[_V]\":\n        return Rect(left, self.top, self.width, self.height)\n\n    def with_top(self, top: _V) -&gt; \"Rect[_V]\":\n        return Rect(self.left, top, self.width, self.height)\n\n    def with_width(self, width: _V) -&gt; \"Rect[_V]\":\n        return Rect(self.left, self.top, width, self.height)\n\n    def with_height(self, height: _V) -&gt; \"Rect[_V]\":\n        return Rect(self.left, self.top, self.width, height)\n\n    def with_right(self, right: _V) -&gt; \"Rect[_V]\":\n        return Rect(right - self.width, self.top, self.width, self.height)\n\n    def with_bottom(self, bottom: _V) -&gt; \"Rect[_V]\":\n        return Rect(self.left, bottom - self.height, self.width, self.height)\n\n    def __iter__(self):\n        \"\"\"Iterate over the field to make this class tuple-like.\"\"\"\n        return iter((self.left, self.top, self.width, self.height))\n\n    def size(self) -&gt; Size[_V]:\n        return Size(self.width, self.height)\n\n    def adjust_to_int(\n        self,\n        how: Literal[\"inner\", \"outer\"] = \"inner\",\n    ) -&gt; \"Rect[int]\":\n        right = self.right\n        bottom = self.bottom\n        if how == \"inner\":\n            left = int(math.ceil(self.left))\n            top = int(math.ceil(self.top))\n            right = int(math.floor(right))\n            bottom = int(math.floor(bottom))\n        else:\n            left = int(math.floor(self.left))\n            top = int(math.floor(self.top))\n            right = int(math.ceil(right))\n            bottom = int(math.ceil(bottom))\n        return Rect(left, top, right - left, bottom - top)\n\n    def limit_to(self, xmax: _T, ymax: _T) -&gt; \"Rect[_T]\":\n        \"\"\"Limit the size of the Rect to the given maximum size.\"\"\"\n        left = max(self.left, 0)\n        top = max(self.top, 0)\n        right = min(self.right, xmax)\n        bottom = min(self.bottom, ymax)\n        return Rect(left, top, right - left, bottom - top)\n\n    def move_top_left(self, left: _V, top: _V) -&gt; \"Rect[_V]\":\n        return Rect(left, top, self.width, self.height)\n\n    def move_top_right(self, right: _V, top: _V) -&gt; \"Rect[_V]\":\n        return Rect(right - self.width, top, self.width, self.height)\n\n    def move_bottom_left(self, left: _V, bottom: _V) -&gt; \"Rect[_V]\":\n        return Rect(left, bottom - self.height, self.width, self.height)\n\n    def move_bottom_right(self, right: _V, bottom: _V) -&gt; \"Rect[_V]\":\n        return Rect(right - self.width, bottom - self.height, self.width, self.height)\n</code></pre>"},{"location":"api/types/#himena.types.Rect.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the field to make this class tuple-like.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over the field to make this class tuple-like.\"\"\"\n    return iter((self.left, self.top, self.width, self.height))\n</code></pre>"},{"location":"api/types/#himena.types.Rect.limit_to","title":"<code>limit_to(xmax, ymax)</code>","text":"<p>Limit the size of the Rect to the given maximum size.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def limit_to(self, xmax: _T, ymax: _T) -&gt; \"Rect[_T]\":\n    \"\"\"Limit the size of the Rect to the given maximum size.\"\"\"\n    left = max(self.left, 0)\n    top = max(self.top, 0)\n    right = min(self.right, xmax)\n    bottom = min(self.bottom, ymax)\n    return Rect(left, top, right - left, bottom - top)\n</code></pre>"},{"location":"api/types/#himena.types.Size","title":"<code>Size</code>  <code>dataclass</code>","text":"<p>Size use for any place.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>~_V</code> required <code>height</code> <code>~_V</code> required Source code in <code>src\\himena\\types.py</code> <pre><code>@dataclass(frozen=True)\nclass Size(Generic[_V]):\n    \"\"\"Size use for any place.\"\"\"\n\n    width: _V\n    height: _V\n\n    def __iter__(self):\n        \"\"\"Iterate over the field to make this class tuple-like.\"\"\"\n        return iter((self.width, self.height))\n\n    def __getitem__(self, index: int):\n        if index == 0:\n            return self.width\n        elif index == 1:\n            return self.height\n        raise IndexError(f\"Index {index!r} out of range.\")\n\n    def with_width(self, width: _V) -&gt; \"Size[_V]\":\n        return Size(width, self.height)\n\n    def with_height(self, height: _V) -&gt; \"Size[_V]\":\n        return Size(self.width, height)\n</code></pre>"},{"location":"api/types/#himena.types.Size.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the field to make this class tuple-like.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over the field to make this class tuple-like.\"\"\"\n    return iter((self.width, self.height))\n</code></pre>"},{"location":"api/types/#himena.types.WidgetClassTuple","title":"<code>WidgetClassTuple</code>","text":"<p>Class for storing registered widget class.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <code>None</code> <code>widget_class</code> <code>ForwardRef(type | Callable)</code> <code>None</code> <code>priority</code> <code>int</code> <code>100</code> <code>widget_id</code> <code>str | None</code> <code>None</code> Source code in <code>src\\himena\\types.py</code> <pre><code>class WidgetClassTuple(NamedTuple):\n    \"\"\"Class for storing registered widget class.\"\"\"\n\n    type: str\n    widget_class: \"type | Callable\"  # factory function\n    priority: int = 100\n    widget_id: str | None = None\n</code></pre>"},{"location":"api/types/#himena.types.WidgetDataModel","title":"<code>WidgetDataModel</code>","text":"<p>A data model that represents a widget containing an internal data.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>~_T</code> <p>Internal value.</p> required <code>type</code> <code>str</code> <p>Type of the internal data.</p> required <code>title</code> <code>str | None</code> <p>Default title for the widget.</p> <code>None</code> <code>extension_default</code> <code>str | None</code> <p>Default file extension for saving.</p> <code>None</code> <code>extensions</code> <code>list[str]</code> <p>List of allowed file extensions.</p> <code>&lt;dynamic&gt;</code> <code>metadata</code> <code>object | None</code> <p>Metadata that may be used for storing additional information of the internal data or describing the state of the widget.</p> <code>None</code> <code>workflow</code> <code>Workflow</code> <p>Container of WorkflowStep instances.</p> <p>The data structure of a workflow is a directed acyclic graph. Each node is a WorkflowStep instance, and the edges are defined inside each CommandExecution instance. Each node is tagged with a unique ID named <code>id</code>, which is used as a mathematical identifier for the node.</p> <code>&lt;dynamic&gt;</code> <code>force_open_with</code> <code>str | None</code> <p>Force open with a specific plugin if given.</p> <code>None</code> <code>save_behavior_override</code> <code>SaveBehavior | None</code> <p>Override the default save behavior.</p> <code>None</code> <code>editable</code> <code>bool</code> <p>Whether the widget is editable.</p> <code>True</code> <code>window_rect_override</code> <code>Callable[list, WindowRect] | None</code> <code>None</code> <p>Attributes:</p> Name Type Description <code>value</code> <code>Any</code> <p>Internal value.</p> <code>type</code> <code>(str, optional)</code> <p>Type of the internal data. Type hierarchy is separated by dots. For example, \"text.plain\" is a subtype of \"text\".</p> <code>title</code> <code>(str, optional)</code> <p>Title for the widget. If not given, the title will be generated from the source path when this model is added to the GUI.</p> <code>extension_default</code> <code>(str, optional)</code> <p>Default file extension for saving. This is used when the user saves the data without specifying the file extension.</p> <code>extensions</code> <code>(list[str], optional)</code> <p>List of allowed file extensions to save this data.</p> <code>metadata</code> <code>(Any, optional)</code> <p>Metadata that may be used for storing additional information of the internal data or describing the state of the widget.</p> <code>workflow</code> <code>(WorkflowList, optional)</code> <p>History of how this data is created.</p> <code>force_open_with</code> <code>(str, optional)</code> <p>Force open with a specific plugin if given.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>class WidgetDataModel(GenericModel[_T]):\n    \"\"\"\n    A data model that represents a widget containing an internal data.\n\n    Attributes\n    ----------\n    value : Any\n        Internal value.\n    type : str, optional\n        Type of the internal data. Type hierarchy is separated by dots. For example,\n        \"text.plain\" is a subtype of \"text\".\n    title : str, optional\n        Title for the widget. If not given, the title will be generated from the source\n        path when this model is added to the GUI.\n    extension_default : str, optional\n        Default file extension for saving. This is used when the user saves the data\n        without specifying the file extension.\n    extensions : list[str], optional\n        List of allowed file extensions to save this data.\n    metadata : Any, optional\n        Metadata that may be used for storing additional information of the internal\n        data or describing the state of the widget.\n    workflow : WorkflowList, optional\n        History of how this data is created.\n    force_open_with : str, optional\n        Force open with a specific plugin if given.\n    \"\"\"\n\n    model_config = PYDANTIC_CONFIG_STRICT\n\n    value: _T = Field(..., description=\"Internal value.\")\n    type: str = Field(..., description=\"Type of the internal data.\")\n    title: str | None = Field(\n        default=None,\n        description=\"Default title for the widget.\",\n    )\n    extension_default: str | None = Field(\n        default=None,\n        description=\"Default file extension for saving.\",\n    )\n    extensions: list[str] = Field(\n        default_factory=list,\n        description=\"List of allowed file extensions.\",\n    )\n    metadata: object | None = Field(\n        default=None,\n        description=\"Metadata that may be used for storing additional information of \"\n        \"the internal data or describing the state of the widget.\",\n    )  # fmt: skip\n    workflow: Workflow = Field(default_factory=Workflow)\n    force_open_with: str | None = Field(\n        default=None,\n        description=\"Force open with a specific plugin if given.\",\n    )\n    save_behavior_override: SaveBehavior | None = Field(\n        default=None,\n        description=\"Override the default save behavior.\",\n    )\n    editable: bool = Field(True, description=\"Whether the widget is editable.\")\n    window_rect_override: Callable[[\"Size\"], \"WindowRect\"] | None = Field(None)\n\n    def with_value(\n        self,\n        value: _U,\n        type: str | None = None,\n        *,\n        title: str | None = None,\n        metadata: object | None = _void,\n        save_behavior_override: SaveBehavior | _Void | None = _void,\n    ) -&gt; \"WidgetDataModel[_U]\":\n        \"\"\"Return a model with the new value.\"\"\"\n        update = {\"value\": value}\n        if type is not None:\n            update[\"type\"] = type\n        if metadata is not _void:\n            update[\"metadata\"] = metadata\n        if title is not None:\n            update[\"title\"] = title\n        if save_behavior_override is not _void:\n            update[\"save_behavior_override\"] = save_behavior_override\n        update.update(\n            workflow=Workflow(),\n            force_open_with=None,\n        )  # these parameters must be reset\n        return self.model_copy(update=update)\n\n    def astype(self, new_type: str):\n        update = {\"type\": new_type}\n        return self.model_copy(update=update)\n\n    def _with_source(\n        self,\n        source: str | Path | list[str | Path],\n        plugin: \"PluginInfo | None\" = None,\n    ) -&gt; \"WidgetDataModel[_T]\":\n        \"\"\"Return a new instance with the source path.\"\"\"\n        if plugin is None:\n            plugin_name = None\n        else:\n            plugin_name = plugin.to_str()\n        if isinstance(source, list):\n            path = [Path(s).resolve() for s in source]\n        else:\n            path = Path(source).resolve()\n        wf = LocalReaderMethod(\n            path=path, plugin=plugin_name, output_model_type=self.type\n        ).construct_workflow()\n        to_update = {\"workflow\": wf}\n        if self.title is None:\n            if isinstance(path, list):\n                to_update.update({\"title\": \"File group\"})\n            else:\n                to_update.update({\"title\": path.name})\n        return self.model_copy(update=to_update)\n\n    def with_open_plugin(\n        self,\n        open_with: str,\n        *,\n        workflow: Workflow | _Void | None = _void,\n        save_behavior_override: SaveBehavior | _Void | None = _void,\n    ) -&gt; \"WidgetDataModel[_T]\":\n        update = {\"force_open_with\": open_with}\n        if workflow is not _void:\n            update[\"workflow\"] = workflow\n        if save_behavior_override is not _void:\n            update[\"save_behavior_override\"] = save_behavior_override\n        return self.model_copy(update=update)\n\n    def with_metadata(\n        self,\n        metadata: Any,\n    ) -&gt; \"WidgetDataModel[_T]\":\n        \"\"\"Return a new instance with the given metadata.\"\"\"\n        update = {\"metadata\": metadata}\n        return self.model_copy(update=update)\n\n    def write_to_directory(\n        self,\n        directory: str | Path,\n        *,\n        plugin: str | None = None,\n    ) -&gt; Path:\n        from himena import _providers\n\n        ins = _providers.WriterStore.instance()\n        title = self.title or \"Untitled\"\n        path = Path(directory) / title\n        if path.suffix == \"\":\n            if ext := self.extension_default:\n                path = path.with_suffix(ext)\n            elif exts := self.extensions:\n                path = path.with_suffix(exts[0])\n            else:\n                raise ValueError(\"Could not determine the file extension.\")\n        ins.run(self, path, min_priority=0, plugin=plugin)\n        return path\n\n    @property\n    def source(self) -&gt; Path | list[Path] | None:\n        \"\"\"The direct source path of the data.\"\"\"\n        if isinstance(step := self.workflow.last(), LocalReaderMethod):\n            return step.path\n        return None\n\n    def is_subtype_of(self, supertype: str) -&gt; bool:\n        \"\"\"Check if the type is a subtype of the given type.\"\"\"\n        return is_subtype(self.type, supertype)\n\n    def with_title_numbering(self, copy: bool = False) -&gt; \"WidgetDataModel[_T]\":\n        \"\"\"Add [n] suffix to the title.\"\"\"\n        title = self.title\n        if title is None:\n            title = \"Untitled\"\n        if \".\" in title:\n            stem, ext = title.rsplit(\".\", 1)\n            ext = f\".{ext}\"\n        else:\n            stem = title\n            ext = \"\"\n        if (\n            (last_part := stem.rsplit(\" \", 1)[-1]).startswith(\"[\")\n            and last_part.endswith(\"]\")\n            and last_part[1:-1].isdigit()\n        ):\n            nth = int(last_part[1:-1])\n            stem = stem.rsplit(\" \", 1)[0] + f\" [{nth + 1}]\"\n        else:\n            stem = stem + \" [1]\"\n        new_title = stem + ext\n        if copy:\n            return self.model_copy(update={\"title\": new_title})\n        else:\n            self.title = new_title\n            return self\n\n    @field_validator(\"extension_default\", mode=\"after\")\n    def _validate_extension_default(cls, v: str, values):\n        if v is None:\n            return None\n        if not v.startswith(\".\"):\n            return f\".{v}\"\n        return v\n\n    @field_validator(\"extensions\", mode=\"before\")\n    def _validate_extensions(cls, v):\n        if isinstance(v, str):\n            v = [v]\n        if not all(isinstance(ext, str) for ext in v):\n            raise TypeError(f\"Invalid type for `extensions`: {type(v)}\")\n        return [s if s.startswith(\".\") else f\".{s}\" for s in v]\n\n    def __repr__(self):\n        value_repr = f\"&lt;{type(self.value).__name__}&gt;\"\n        if isinstance(source := self.source, Path):\n            source_repr = source.as_posix()\n        elif isinstance(source, list):\n            if len(source) &gt; 0:\n                source_repr = f\"[{source[0].as_posix()}, ...]\"\n            else:\n                source_repr = \"[]\"\n        else:\n            source_repr = None\n        return (\n            f\"{self.__class__.__name__}(value={value_repr}, source={source_repr}, \"\n            f\"type={self.type!r}, title={self.title!r})\"\n        )\n</code></pre>"},{"location":"api/types/#himena.types.WidgetDataModel.source","title":"<code>source</code>  <code>property</code>","text":"<p>The direct source path of the data.</p>"},{"location":"api/types/#himena.types.WidgetDataModel.is_subtype_of","title":"<code>is_subtype_of(supertype)</code>","text":"<p>Check if the type is a subtype of the given type.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def is_subtype_of(self, supertype: str) -&gt; bool:\n    \"\"\"Check if the type is a subtype of the given type.\"\"\"\n    return is_subtype(self.type, supertype)\n</code></pre>"},{"location":"api/types/#himena.types.WidgetDataModel.with_metadata","title":"<code>with_metadata(metadata)</code>","text":"<p>Return a new instance with the given metadata.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def with_metadata(\n    self,\n    metadata: Any,\n) -&gt; \"WidgetDataModel[_T]\":\n    \"\"\"Return a new instance with the given metadata.\"\"\"\n    update = {\"metadata\": metadata}\n    return self.model_copy(update=update)\n</code></pre>"},{"location":"api/types/#himena.types.WidgetDataModel.with_title_numbering","title":"<code>with_title_numbering(copy=False)</code>","text":"<p>Add [n] suffix to the title.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def with_title_numbering(self, copy: bool = False) -&gt; \"WidgetDataModel[_T]\":\n    \"\"\"Add [n] suffix to the title.\"\"\"\n    title = self.title\n    if title is None:\n        title = \"Untitled\"\n    if \".\" in title:\n        stem, ext = title.rsplit(\".\", 1)\n        ext = f\".{ext}\"\n    else:\n        stem = title\n        ext = \"\"\n    if (\n        (last_part := stem.rsplit(\" \", 1)[-1]).startswith(\"[\")\n        and last_part.endswith(\"]\")\n        and last_part[1:-1].isdigit()\n    ):\n        nth = int(last_part[1:-1])\n        stem = stem.rsplit(\" \", 1)[0] + f\" [{nth + 1}]\"\n    else:\n        stem = stem + \" [1]\"\n    new_title = stem + ext\n    if copy:\n        return self.model_copy(update={\"title\": new_title})\n    else:\n        self.title = new_title\n        return self\n</code></pre>"},{"location":"api/types/#himena.types.WidgetDataModel.with_value","title":"<code>with_value(value, type=None, *, title=None, metadata=_void, save_behavior_override=_void)</code>","text":"<p>Return a model with the new value.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>def with_value(\n    self,\n    value: _U,\n    type: str | None = None,\n    *,\n    title: str | None = None,\n    metadata: object | None = _void,\n    save_behavior_override: SaveBehavior | _Void | None = _void,\n) -&gt; \"WidgetDataModel[_U]\":\n    \"\"\"Return a model with the new value.\"\"\"\n    update = {\"value\": value}\n    if type is not None:\n        update[\"type\"] = type\n    if metadata is not _void:\n        update[\"metadata\"] = metadata\n    if title is not None:\n        update[\"title\"] = title\n    if save_behavior_override is not _void:\n        update[\"save_behavior_override\"] = save_behavior_override\n    update.update(\n        workflow=Workflow(),\n        force_open_with=None,\n    )  # these parameters must be reset\n    return self.model_copy(update=update)\n</code></pre>"},{"location":"api/types/#himena.types.WindowRect","title":"<code>WindowRect</code>  <code>dataclass</code>","text":"<p>Rectangle of a window.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>~_V</code> required <code>top</code> <code>~_V</code> required <code>width</code> <code>~_V</code> required <code>height</code> <code>~_V</code> required Source code in <code>src\\himena\\types.py</code> <pre><code>@dataclass(frozen=True)\nclass WindowRect(Rect[int]):\n    \"\"\"Rectangle of a window.\"\"\"\n\n    @classmethod\n    def from_tuple(cls, left, top, width, height) -&gt; \"WindowRect\":\n        return cls(int(left), int(top), int(width), int(height))\n\n    def align_left(self, area_size: Size[int]) -&gt; \"WindowRect\":\n        return WindowRect(0, self.top, self.width, self.height)\n\n    def align_right(self, area_size: Size[int]) -&gt; \"WindowRect\":\n        w0, _ = area_size\n        return WindowRect(w0 - self.width, self.top, self.width, self.height)\n\n    def align_top(self, area_size: Size[int]) -&gt; \"WindowRect\":\n        return WindowRect(self.left, 0, self.width, self.height)\n\n    def align_bottom(self, area_size: Size[int]) -&gt; \"WindowRect\":\n        _, h0 = area_size\n        return WindowRect(self.left, h0 - self.height, self.width, self.height)\n\n    def align_center(self, area_size: Size[int]) -&gt; \"WindowRect\":\n        w0, h0 = area_size\n        return WindowRect(\n            (w0 - self.width) / 2,\n            (h0 - self.height) / 2,\n            self.width,\n            self.height,\n        )\n\n    def resize_relative(self, wratio: float, hratio: float) -&gt; \"WindowRect\":\n        if wratio &lt;= 0 or hratio &lt;= 0:\n            raise ValueError(\"Ratios must be positive.\")\n        return WindowRect(\n            self.left,\n            self.top,\n            round(self.width * wratio),\n            round(self.height * hratio),\n        )\n</code></pre>"},{"location":"api/types/#himena.types.WindowState","title":"<code>WindowState</code>","text":"<p>State of the sub window.</p> Source code in <code>src\\himena\\types.py</code> <pre><code>class WindowState(StrEnum):\n    \"\"\"State of the sub window.\"\"\"\n\n    MIN = \"min\"\n    MAX = \"max\"\n    NORMAL = \"normal\"\n    FULL = \"full\"\n</code></pre>"},{"location":"api/standards/model_meta/","title":"himena.standards.model_meta","text":""},{"location":"api/standards/model_meta/#himena.standards.model_meta.ArrayAxis","title":"<code>ArrayAxis</code>","text":"<p>An axis in an array.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the axis.</p> required <code>scale</code> <code>float</code> <p>Pixel scale of the axis.</p> <code>1.0</code> <code>origin</code> <code>float</code> <p>Offset of the axis.</p> <code>0.0</code> <code>unit</code> <code>str</code> <p>Unit of the axis spacing.</p> <code>''</code> <code>labels</code> <code>list[str]</code> <p>Category labels of the axis.</p> <code>&lt;dynamic&gt;</code> <code>default_label_format</code> <code>str</code> <p>Default format of the labels.</p> <code>'{:s}'</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class ArrayAxis(BaseModel):\n    \"\"\"An axis in an array.\"\"\"\n\n    name: str = Field(..., description=\"Name of the axis.\")\n    scale: float = Field(default=1.0, description=\"Pixel scale of the axis.\")\n    origin: float = Field(default=0.0, description=\"Offset of the axis.\")\n    unit: str = Field(\"\", description=\"Unit of the axis spacing.\")\n    labels: list[str] = Field(\n        default_factory=list, description=\"Category labels of the axis.\"\n    )\n    default_label_format: str = Field(\n        \"{:s}\", description=\"Default format of the labels.\"\n    )\n\n    @field_validator(\"name\", mode=\"before\")\n    def _name_to_str(cls, v):\n        return str(v)\n\n    def get_label(self, index: int) -&gt; str:\n        \"\"\"Return the label of the axis at the given index.\"\"\"\n        if index &lt; 0:\n            raise ValueError(\"Index must be non-negative.\")\n        try:\n            return self.labels[index]\n        except IndexError:\n            return self.default_label_format.format(str(index))\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ArrayAxis.get_label","title":"<code>get_label(index)</code>","text":"<p>Return the label of the axis at the given index.</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>def get_label(self, index: int) -&gt; str:\n    \"\"\"Return the label of the axis at the given index.\"\"\"\n    if index &lt; 0:\n        raise ValueError(\"Index must be non-negative.\")\n    try:\n        return self.labels[index]\n    except IndexError:\n        return self.default_label_format.format(str(index))\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ArrayMeta","title":"<code>ArrayMeta</code>","text":"<p>Preset for describing an array metadata.</p> <p>Parameters:</p> Name Type Description Default <code>axes</code> <code>list[ArrayAxis] | None</code> <p>Axes of the array.</p> <code>None</code> <code>current_indices</code> <code>tuple[Optional[int], ...] | None</code> <p>Current slice indices to render the array in GUI.</p> <code>None</code> <code>selections</code> <code>list[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Selections of the array. This attribute should be any sliceable objects that can passed to the backend array object.</p> <code>&lt;dynamic&gt;</code> <code>unit</code> <code>str | None</code> <p>Unit of the array values.</p> <code>None</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class ArrayMeta(BaseMetadata):\n    \"\"\"Preset for describing an array metadata.\"\"\"\n\n    axes: list[ArrayAxis] | None = Field(None, description=\"Axes of the array.\")\n    current_indices: tuple[int | None, ...] | None = Field(\n        None, description=\"Current slice indices to render the array in GUI.\"\n    )\n    selections: list[tuple[tuple[int, int], tuple[int, int]]] = Field(\n        default_factory=list,\n        description=\"Selections of the array. This attribute should be any sliceable \"\n        \"objects that can passed to the backend array object.\",\n    )\n    unit: str | None = Field(\n        None,\n        description=\"Unit of the array values.\",\n    )\n\n    def without_selections(self) -&gt; \"ArrayMeta\":\n        \"\"\"Make a copy of the metadata without selections.\"\"\"\n        return self.model_copy(update={\"selections\": []})\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ArrayMeta.without_selections","title":"<code>without_selections()</code>","text":"<p>Make a copy of the metadata without selections.</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>def without_selections(self) -&gt; \"ArrayMeta\":\n    \"\"\"Make a copy of the metadata without selections.\"\"\"\n    return self.model_copy(update={\"selections\": []})\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.BaseMetadata","title":"<code>BaseMetadata</code>","text":"<p>The base class for a model metadata.</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class BaseMetadata(BaseModel):\n    \"\"\"The base class for a model metadata.\"\"\"\n\n    @classmethod\n    def from_metadata(cls, dir_path: Path) -&gt; \"TextMeta\":\n        return cls.model_validate_json(dir_path.joinpath(_META_NAME).read_text())\n\n    def write_metadata(self, dir_path: Path) -&gt; None:\n        dir_path.joinpath(_META_NAME).write_text(self.model_dump_json())\n\n    def _class_info(self) -&gt; dict:\n        return {\"name\": self.__class__.__name__, \"module\": self.__class__.__module__}\n\n    def _repr_pretty_(self, p, cycle):\n        \"\"\"Pretty print the metadata.\"\"\"\n        lines = [f\"{self.__class__.__name__}(\"]\n        for key, value in self.__repr_args__():\n            lines.append(f\"  {key}={value!r},\")\n        lines.append(\")\")\n        p.text(\"\\n\".join(lines))\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.DataFrameMeta","title":"<code>DataFrameMeta</code>","text":"<p>Preset for describing the metadata for a \"dataframe\" type.</p> <p>Parameters:</p> Name Type Description Default <code>current_position</code> <code>list[int] | None</code> <p>Current index position of (row, column) in the table.</p> <code>None</code> <code>selections</code> <code>list[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Table selections in the format of ((row_start, row_end), (col_start, col_end)), where the end index is exclusive, as is always the case for the Python indexing.</p> <code>&lt;dynamic&gt;</code> <code>separator</code> <code>str | None</code> <p>Separator of the table.</p> <code>None</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class DataFrameMeta(TableMeta):\n    \"\"\"Preset for describing the metadata for a \"dataframe\" type.\"\"\"\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.DataFramePlotMeta","title":"<code>DataFramePlotMeta</code>","text":"<p>Preset for describing the metadata for a \"dataframe.plot\" type.</p> <p>Parameters:</p> Name Type Description Default <code>current_position</code> <code>list[int] | None</code> <p>Current index position of (row, column) in the table.</p> <code>None</code> <code>selections</code> <code>list[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Table selections in the format of ((row_start, row_end), (col_start, col_end)), where the end index is exclusive, as is always the case for the Python indexing.</p> <code>&lt;dynamic&gt;</code> <code>separator</code> <code>str | None</code> <p>Separator of the table.</p> <code>None</code> <code>plot_type</code> <code>Literal[str, str]</code> <p>Type of the plot.</p> <code>'line'</code> <code>plot_color_cycle</code> <code>list[str] | None</code> <p>Color cycle of the plot.</p> <code>None</code> <code>plot_background_color</code> <code>str | None</code> <p>Background color of the plot.</p> <code>'#FFFFFF'</code> <code>rois</code> <code>RoiListModel | Callable[list, RoiListModel]</code> <p>Regions of interest.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class DataFramePlotMeta(DataFrameMeta):\n    \"\"\"Preset for describing the metadata for a \"dataframe.plot\" type.\"\"\"\n\n    model_config = {\"arbitrary_types_allowed\": True}\n\n    plot_type: Literal[\"line\", \"scatter\"] = Field(\n        \"line\", description=\"Type of the plot.\"\n    )\n    plot_color_cycle: list[str] | None = Field(\n        None, description=\"Color cycle of the plot.\"\n    )\n    plot_background_color: str | None = Field(\n        \"#FFFFFF\", description=\"Background color of the plot.\"\n    )\n    rois: roi.RoiListModel | Callable[[], roi.RoiListModel] = Field(\n        default_factory=roi.RoiListModel, description=\"Regions of interest.\"\n    )\n\n    @classmethod\n    def from_metadata(cls, dir_path: Path) -&gt; \"DataFramePlotMeta\":\n        self = cls.model_validate_json(dir_path.joinpath(_META_NAME).read_text())\n        if (rois_path := dir_path.joinpath(\"rois.roi.json\")).exists():\n            self.rois = roi.RoiListModel.model_validate_json(rois_path.read_text())\n        return self\n\n    def unwrap_rois(self) -&gt; roi.RoiListModel:\n        \"\"\"Unwrap the lazy-evaluation of the ROIs.\"\"\"\n        if isinstance(self.rois, roi.RoiListModel):\n            return self.rois\n        self.rois = self.rois()\n        return self.rois\n\n    def write_metadata(self, dir_path: Path) -&gt; None:\n        dir_path.joinpath(_META_NAME).write_text(self.model_dump_json(exclude={\"rois\"}))\n        rois = self.unwrap_rois()\n        if len(rois) &gt; 0:\n            with dir_path.joinpath(\"rois.roi.json\").open(\"w\") as f:\n                json.dump(rois.model_dump_typed(), f)\n        return None\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.DataFramePlotMeta.unwrap_rois","title":"<code>unwrap_rois()</code>","text":"<p>Unwrap the lazy-evaluation of the ROIs.</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>def unwrap_rois(self) -&gt; roi.RoiListModel:\n    \"\"\"Unwrap the lazy-evaluation of the ROIs.\"\"\"\n    if isinstance(self.rois, roi.RoiListModel):\n        return self.rois\n    self.rois = self.rois()\n    return self.rois\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.DictMeta","title":"<code>DictMeta</code>","text":"<p>Parameters:</p> Name Type Description Default <code>current_tab</code> <code>str | None</code> <p>Current tab name.</p> <code>None</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class DictMeta(BaseMetadata):\n    current_tab: str | None = Field(None, description=\"Current tab name.\")\n    child_meta: dict[str, BaseMetadata] = Field(\n        default_factory=dict, description=\"Metadata of the child models.\"\n    )\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.FunctionMeta","title":"<code>FunctionMeta</code>","text":"<p>Preset for describing the metadata for a \"function\" type.</p> <p>Parameters:</p> Name Type Description Default <code>source_code</code> <code>str | None</code> <p>Source code of the function.</p> <code>None</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class FunctionMeta(BaseMetadata):\n    \"\"\"Preset for describing the metadata for a \"function\" type.\"\"\"\n\n    source_code: str | None = Field(None, description=\"Source code of the function.\")\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageChannel","title":"<code>ImageChannel</code>","text":"<p>A channel in an image file.</p> <p>Parameters:</p> Name Type Description Default <code>colormap</code> <code>str | None</code> <p>Color map of the channel.</p> <code>None</code> <code>contrast_limits</code> <code>tuple[float, float] | None</code> <p>Contrast limits of the channel.</p> <code>None</code> <code>visible</code> <code>bool</code> <p>Whether the channel is visible.</p> <code>True</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class ImageChannel(BaseModel):\n    \"\"\"A channel in an image file.\"\"\"\n\n    colormap: str | None = Field(None, description=\"Color map of the channel.\")\n    contrast_limits: tuple[float, float] | None = Field(\n        None, description=\"Contrast limits of the channel.\"\n    )\n    visible: bool = Field(True, description=\"Whether the channel is visible.\")\n\n    @classmethod\n    def default(cls) -&gt; \"ImageChannel\":\n        \"\"\"Return a default channel (also used for mono-channel images).\"\"\"\n        return cls(name=None, colormap=\"gray\", contrast_limits=None)\n\n    def with_colormap(self, colormap: str) -&gt; \"ImageChannel\":\n        \"\"\"Set the colormap of the channel.\"\"\"\n        return self.model_copy(update={\"colormap\": colormap})\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageChannel.default","title":"<code>default()</code>  <code>classmethod</code>","text":"<p>Return a default channel (also used for mono-channel images).</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>@classmethod\ndef default(cls) -&gt; \"ImageChannel\":\n    \"\"\"Return a default channel (also used for mono-channel images).\"\"\"\n    return cls(name=None, colormap=\"gray\", contrast_limits=None)\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageChannel.with_colormap","title":"<code>with_colormap(colormap)</code>","text":"<p>Set the colormap of the channel.</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>def with_colormap(self, colormap: str) -&gt; \"ImageChannel\":\n    \"\"\"Set the colormap of the channel.\"\"\"\n    return self.model_copy(update={\"colormap\": colormap})\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageMeta","title":"<code>ImageMeta</code>","text":"<p>Preset for describing an image file metadata.</p> <p>Parameters:</p> Name Type Description Default <code>axes</code> <code>list[ArrayAxis] | None</code> <p>Axes of the array.</p> <code>None</code> <code>current_indices</code> <code>tuple[Optional[int], ...] | None</code> <p>Current slice indices to render the array in GUI.</p> <code>None</code> <code>selections</code> <code>list[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Selections of the array. This attribute should be any sliceable objects that can passed to the backend array object.</p> <code>&lt;dynamic&gt;</code> <code>unit</code> <code>str | None</code> <p>Unit of the array values.</p> <code>None</code> <code>channels</code> <code>list[ImageChannel]</code> <p>Channels of the image. At least one channel is required.</p> <code>[ImageChannel(colormap='gray', contrast_limits=None, visible=True)]</code> <code>channel_axis</code> <code>int | None</code> <p>Channel axis of the image.</p> <code>None</code> <code>is_rgb</code> <code>bool</code> <p>Whether the image is RGB.</p> <code>False</code> <code>current_roi</code> <code>RoiModel | None</code> <p>Current region of interest.</p> <code>None</code> <code>rois</code> <code>RoiListModel | Callable[list, RoiListModel]</code> <p>Regions of interest.</p> <code>&lt;dynamic&gt;</code> <code>interpolation</code> <code>str | None</code> <p>Interpolation method.</p> <code>None</code> <code>skip_image_rerendering</code> <code>bool</code> <p>Skip image rerendering when the model is passed to the <code>update_model</code> method. This field is only used when a function does not touch the image data itself.</p> <code>False</code> <code>more_metadata</code> <code>Any | None</code> <p>More metadata if exists.</p> <code>None</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class ImageMeta(ArrayMeta):\n    \"\"\"Preset for describing an image file metadata.\"\"\"\n\n    model_config = {\"arbitrary_types_allowed\": True}\n\n    channels: list[ImageChannel] = Field(\n        default_factory=lambda: [ImageChannel.default()],\n        description=\"Channels of the image. At least one channel is required.\",\n    )\n    channel_axis: int | None = Field(None, description=\"Channel axis of the image.\")\n    is_rgb: bool = Field(False, description=\"Whether the image is RGB.\")\n    current_roi: roi.RoiModel | None = Field(\n        None, description=\"Current region of interest.\"\n    )\n    rois: roi.RoiListModel | Callable[[], roi.RoiListModel] = Field(\n        default_factory=roi.RoiListModel, description=\"Regions of interest.\"\n    )\n    interpolation: str | None = Field(\n        default=None,\n        description=\"Interpolation method.\",\n    )\n    skip_image_rerendering: bool = Field(\n        default=False,\n        description=\"Skip image rerendering when the model is passed to the `update_model` method. This field is only used when a function does not touch the image data itself.\",\n    )\n    more_metadata: Any | None = Field(None, description=\"More metadata if exists.\")\n\n    def without_rois(self) -&gt; \"ImageMeta\":\n        return self.model_copy(update={\"rois\": roi.RoiListModel(), \"current_roi\": None})\n\n    def get_one_axis(self, index: int, value: int) -&gt; \"ImageMeta\":\n        \"\"\"Drop an axis by index for the array slicing arr[..., value, ...].\"\"\"\n        if index &lt; 0:\n            index += len(self.axes)\n        if index &lt; 0 or index &gt;= len(self.axes):\n            raise IndexError(f\"Invalid axis index: {index}.\")\n        axes = self.axes.copy()\n        del axes[index]\n        update = {\"axes\": axes, \"rois\": self.unwrap_rois().take_axis(index, value)}\n        if (caxis := self.channel_axis) == index:\n            update[\"channels\"] = [self.channels[value]]\n            update[\"channel_axis\"] = None\n            update[\"is_rgb\"] = False\n        elif caxis is not None:\n            update[\"channel_axis\"] = caxis - 1 if caxis &gt; index else caxis\n        return self.model_copy(update=update)\n\n    def unwrap_rois(self) -&gt; roi.RoiListModel:\n        \"\"\"Unwrap the lazy-evaluation of the ROIs.\"\"\"\n        if isinstance(self.rois, roi.RoiListModel):\n            return self.rois\n        self.rois = self.rois()\n        return self.rois\n\n    @field_validator(\"axes\", mode=\"before\")\n    def _strings_to_axes(cls, v, values: \"ValidationInfo\"):\n        if v is None:\n            return None\n        out: list[ArrayAxis] = []\n        for axis in v:\n            if isinstance(axis, str):\n                axis = ArrayAxis(name=axis)\n            elif isinstance(axis, dict):\n                axis = ArrayAxis(**axis)\n            out.append(axis)\n        return out\n\n    @field_validator(\"channel_axis\")\n    def _is_rgb_and_channels_exclusive(cls, v, values: \"ValidationInfo\"):\n        if values.data.get(\"is_rgb\") and v is not None:\n            raise ValueError(\"Channel axis must be None for RGB images.\")\n        if v is None and len(values.data[\"channels\"]) &gt; 1:\n            raise ValueError(\"Channel axis is required for multi-channel images.\")\n        return v\n\n    @field_validator(\"channels\")\n    def _channels_not_empty(cls, v, values: \"ValidationInfo\"):\n        if not v:\n            raise ValueError(\"At least one channel is required.\")\n        return v\n\n    @property\n    def contrast_limits(self) -&gt; tuple[float, float] | None:\n        \"\"\"Return the contrast limits of the first visible channel.\"\"\"\n        return self.channels[0].contrast_limits\n\n    @contrast_limits.setter\n    def contrast_limits(self, value: tuple[float, float] | None):\n        \"\"\"Set the contrast limits of all channels.\"\"\"\n        for channel in self.channels:\n            channel.contrast_limits = value\n\n    @property\n    def colormap(self) -&gt; Any | None:\n        \"\"\"Return the colormap of the first visible channel.\"\"\"\n        return self.channels[0].colormap\n\n    @colormap.setter\n    def colormap(self, value: Any | None):\n        \"\"\"Set the colormap of all channels.\"\"\"\n        for channel in self.channels:\n            channel.colormap = value\n\n    @classmethod\n    def from_metadata(cls, dir_path: Path) -&gt; \"ImageMeta\":\n        self = cls.model_validate_json(dir_path.joinpath(_META_NAME).read_text())\n        if (rois_path := dir_path.joinpath(\"rois.roi.json\")).exists():\n            self.rois = roi.RoiListModel.model_validate_json(rois_path.read_text())\n        if (cur_roi_path := dir_path.joinpath(\"current_roi.json\")).exists():\n            roi_js = json.loads(cur_roi_path.read_text())\n            self.current_roi = roi.RoiModel.construct(roi_js.pop(\"type\"), roi_js)\n        if (more_meta_path := dir_path.joinpath(\"more_meta.json\")).exists():\n            with more_meta_path.open() as f:\n                self.more_metadata = json.load(f)\n        return self\n\n    def write_metadata(self, dir_path: Path) -&gt; None:\n        dir_path.joinpath(_META_NAME).write_text(\n            self.model_dump_json(\n                exclude={\"current_roi\", \"rois\", \"labels\", \"more_metadata\"}\n            )\n        )\n        rois = self.unwrap_rois()\n        if cur_roi := self.current_roi:\n            with dir_path.joinpath(\"current_roi.json\").open(\"w\") as f:\n                json.dump(cur_roi.model_dump_typed(), f)\n        if len(rois) &gt; 0:\n            with dir_path.joinpath(\"rois.roi.json\").open(\"w\") as f:\n                json.dump(rois.model_dump_typed(), f)\n        if (more_metadata := self.more_metadata) is not None:\n            try:\n                with dir_path.joinpath(\"more_meta.json\").open(\"w\") as f:\n                    json.dump(more_metadata, f)\n            except Exception as e:\n                warnings.warn(\n                    f\"Failed to save `more_metadata`: {e}\",\n                    UserWarning,\n                    stacklevel=2,\n                )\n        return None\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageMeta.colormap","title":"<code>colormap</code>  <code>property</code> <code>writable</code>","text":"<p>Return the colormap of the first visible channel.</p>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageMeta.contrast_limits","title":"<code>contrast_limits</code>  <code>property</code> <code>writable</code>","text":"<p>Return the contrast limits of the first visible channel.</p>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageMeta.get_one_axis","title":"<code>get_one_axis(index, value)</code>","text":"<p>Drop an axis by index for the array slicing arr[..., value, ...].</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>def get_one_axis(self, index: int, value: int) -&gt; \"ImageMeta\":\n    \"\"\"Drop an axis by index for the array slicing arr[..., value, ...].\"\"\"\n    if index &lt; 0:\n        index += len(self.axes)\n    if index &lt; 0 or index &gt;= len(self.axes):\n        raise IndexError(f\"Invalid axis index: {index}.\")\n    axes = self.axes.copy()\n    del axes[index]\n    update = {\"axes\": axes, \"rois\": self.unwrap_rois().take_axis(index, value)}\n    if (caxis := self.channel_axis) == index:\n        update[\"channels\"] = [self.channels[value]]\n        update[\"channel_axis\"] = None\n        update[\"is_rgb\"] = False\n    elif caxis is not None:\n        update[\"channel_axis\"] = caxis - 1 if caxis &gt; index else caxis\n    return self.model_copy(update=update)\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageMeta.unwrap_rois","title":"<code>unwrap_rois()</code>","text":"<p>Unwrap the lazy-evaluation of the ROIs.</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>def unwrap_rois(self) -&gt; roi.RoiListModel:\n    \"\"\"Unwrap the lazy-evaluation of the ROIs.\"\"\"\n    if isinstance(self.rois, roi.RoiListModel):\n        return self.rois\n    self.rois = self.rois()\n    return self.rois\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.ImageRoisMeta","title":"<code>ImageRoisMeta</code>","text":"<p>Preset for describing an image-rois metadata.</p> <p>Parameters:</p> Name Type Description Default <code>axes</code> <code>list[ArrayAxis] | None</code> <p>Axes of the ROIs.</p> <code>None</code> <code>selections</code> <code>list[int]</code> <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class ImageRoisMeta(BaseMetadata):\n    \"\"\"Preset for describing an image-rois metadata.\"\"\"\n\n    axes: list[ArrayAxis] | None = Field(None, description=\"Axes of the ROIs.\")\n    selections: list[int] = Field(default_factory=list)\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.TableMeta","title":"<code>TableMeta</code>","text":"<p>Preset for describing the metadata for a \"table\" type.</p> <p>Parameters:</p> Name Type Description Default <code>current_position</code> <code>list[int] | None</code> <p>Current index position of (row, column) in the table.</p> <code>None</code> <code>selections</code> <code>list[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Table selections in the format of ((row_start, row_end), (col_start, col_end)), where the end index is exclusive, as is always the case for the Python indexing.</p> <code>&lt;dynamic&gt;</code> <code>separator</code> <code>str | None</code> <p>Separator of the table.</p> <code>None</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class TableMeta(BaseMetadata):\n    \"\"\"Preset for describing the metadata for a \"table\" type.\"\"\"\n\n    current_position: list[int] | None = Field(\n        default=None,\n        description=\"Current index position of (row, column) in the table.\",\n    )\n    selections: list[tuple[tuple[int, int], tuple[int, int]]] = Field(\n        default_factory=list,\n        description=\"Table selections in the format of ((row_start, row_end), (col_start, col_end)), where the end index is exclusive, as is always the case for the Python indexing.\",\n    )\n    separator: str | None = Field(None, description=\"Separator of the table.\")\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.TextMeta","title":"<code>TextMeta</code>","text":"<p>Preset for describing the metadata for a \"text\" type.</p> <p>Parameters:</p> Name Type Description Default <code>language</code> <code>str | None</code> <p>Language of the text file.</p> <code>None</code> <code>spaces</code> <code>int</code> <p>Number of spaces for indentation.</p> <code>4</code> <code>selection</code> <code>tuple[int, int] | None</code> <p>Selection range.</p> <code>None</code> <code>font_family</code> <code>str | None</code> <p>Font family.</p> <code>None</code> <code>font_size</code> <code>float</code> <p>Font size.</p> <code>10</code> <code>encoding</code> <code>str | None</code> <p>Encoding of the text file.</p> <code>None</code> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>class TextMeta(BaseMetadata):\n    \"\"\"Preset for describing the metadata for a \"text\" type.\"\"\"\n\n    language: str | None = Field(None, description=\"Language of the text file.\")\n    spaces: int = Field(4, description=\"Number of spaces for indentation.\")\n    selection: tuple[int, int] | None = Field(None, description=\"Selection range.\")\n    font_family: str | None = Field(None, description=\"Font family.\")\n    font_size: float = Field(10, description=\"Font size.\")\n    encoding: str | None = Field(None, description=\"Encoding of the text file.\")\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.read_metadata","title":"<code>read_metadata(dir_path)</code>","text":"<p>Read the metadata from a directory.</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>def read_metadata(dir_path: Path) -&gt; BaseMetadata:\n    \"\"\"Read the metadata from a directory.\"\"\"\n    with dir_path.joinpath(_CLASS_JSON).open(\"r\") as f:\n        class_js = json.load(f)\n    module = class_js[\"module\"]\n    name = class_js[\"name\"]\n    for sub in iter_subclasses(BaseMetadata):\n        if sub.__name__ == name and sub.__module__ == module:\n            metadata_class = sub\n            break\n    else:\n        raise ValueError(f\"Metadata class {name=}n {module=} not found.\")\n\n    return metadata_class.from_metadata(dir_path)\n</code></pre>"},{"location":"api/standards/model_meta/#himena.standards.model_meta.write_metadata","title":"<code>write_metadata(meta, dir_path)</code>","text":"<p>Write the metadata to a directory.</p> Source code in <code>src\\himena\\standards\\model_meta.py</code> <pre><code>def write_metadata(meta: BaseMetadata, dir_path: Path) -&gt; None:\n    \"\"\"Write the metadata to a directory.\"\"\"\n    meta.write_metadata(dir_path)\n    with dir_path.joinpath(_CLASS_JSON).open(\"w\") as f:\n        json.dump(meta._class_info(), f)\n    return None\n</code></pre>"},{"location":"api/standards/roi/","title":"himena.standards.roi","text":"<p>Standard ROI (Region of Interest) classes for images.</p>"},{"location":"api/standards/roi/#himena.standards.roi.EllipseRoi","title":"<code>EllipseRoi</code>","text":"<p>ROI that represents an ellipse.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>x</code> <code>int | float</code> <p>X-coordinate of the center.</p> required <code>y</code> <code>int | float</code> <p>Y-coordinate of the center.</p> required <code>width</code> <code>int | float</code> <p>Diameter along the x-axis.</p> required <code>height</code> <code>int | float</code> <p>Diameter along the y-axis.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class EllipseRoi(Roi2D):\n    \"\"\"ROI that represents an ellipse.\"\"\"\n\n    x: Union[int, float] = Field(..., description=\"X-coordinate of the center.\")\n    y: Union[int, float] = Field(..., description=\"Y-coordinate of the center.\")\n    width: Union[int, float] = Field(..., description=\"Diameter along the x-axis.\")\n    height: Union[int, float] = Field(..., description=\"Diameter along the y-axis.\")\n\n    def center(self) -&gt; tuple[float, float]:\n        return self.x + self.width / 2, self.y + self.height / 2\n\n    def shifted(self, dx: float, dy: float) -&gt; EllipseRoi:\n        return self.model_copy(update={\"x\": self.x + dx, \"y\": self.y + dy})\n\n    def area(self) -&gt; float:\n        return math.pi * self.width * self.height / 4\n\n    def circumference(self) -&gt; float:\n        a, b = self.width / 2, self.height / 2\n        return math.pi * (3 * (a + b) - math.sqrt((3 * a + b) * (a + 3 * b)))\n\n    def eccentricity(self) -&gt; float:\n        a, b = self.width / 2, self.height / 2\n        return math.sqrt(1 - b**2 / a**2)\n\n    def bbox(self) -&gt; Rect[float]:\n        return Rect(self.x, self.y, self.width, self.height)\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        _yy, _xx = np.indices(shape[-2:])\n        cx, cy = self.center()\n        comp_a = (_yy - cy) / self.height * 2\n        comp_b = (_xx - cx) / self.width * 2\n        return comp_a**2 + comp_b**2 &lt;= 1\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.LineRoi","title":"<code>LineRoi</code>","text":"<p>A 2D line ROI.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>x1</code> <code>float</code> <p>X-coordinate of the first point.</p> required <code>y1</code> <code>float</code> <p>Y-coordinate of the first point.</p> required <code>x2</code> <code>float</code> <p>X-coordinate of the second point.</p> required <code>y2</code> <code>float</code> <p>Y-coordinate of the second point.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class LineRoi(Roi2D):\n    \"\"\"A 2D line ROI.\"\"\"\n\n    x1: float = Field(..., description=\"X-coordinate of the first point.\")\n    y1: float = Field(..., description=\"Y-coordinate of the first point.\")\n    x2: float = Field(..., description=\"X-coordinate of the second point.\")\n    y2: float = Field(..., description=\"Y-coordinate of the second point.\")\n\n    def shifted(self, dx: float, dy: float) -&gt; LineRoi:\n        return LineRoi(\n            x1=self.x1 + dx,\n            y1=self.y1 + dy,\n            x2=self.x2 + dx,\n            y2=self.y2 + dy,\n        )\n\n    def length(self) -&gt; float:\n        \"\"\"Length of the line.\"\"\"\n        return math.hypot(self.x2 - self.x1, self.y2 - self.y1)\n\n    def angle(self) -&gt; float:\n        \"\"\"Angle in degrees.\"\"\"\n        return math.degrees(math.atan2(self.y2 - self.y1, self.x2 - self.x1))\n\n    def radian(self) -&gt; float:\n        \"\"\"Angle in radians.\"\"\"\n        return math.atan2(self.y2 - self.y1, self.x2 - self.x1)\n\n    def linspace(self, num: int) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n        \"\"\"Return a tuple of x and y coordinates of np.linspace along the line.\"\"\"\n        return np.linspace(self.x1, self.x2, num), np.linspace(self.y1, self.y2, num)\n\n    def arange(\n        self, step: float = 1.0\n    ) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n        \"\"\"Return a tuple of x and y coordinates of np.arange along the line.\"\"\"\n        radian = self.radian()\n        num, rem = divmod(self.length(), step)\n        xrem = rem * math.cos(radian)\n        yrem = rem * math.sin(radian)\n        return (\n            np.linspace(self.x1, self.x2 - xrem, int(num) + 1),\n            np.linspace(self.y1, self.y2 - yrem, int(num) + 1),\n        )\n\n    def bbox(self) -&gt; Rect[float]:\n        xmin, xmax = min(self.x1, self.x2), max(self.x1, self.x2)\n        ymin, ymax = min(self.y1, self.y2), max(self.y1, self.y2)\n        return Rect(xmin, ymin, xmax - xmin, ymax - ymin)\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        arr = np.zeros(shape, dtype=bool)\n        xs, ys = self.linspace(int(math.ceil(self.length())))\n        xs = xs.round().astype(int)\n        ys = ys.round().astype(int)\n        arr[ys, xs] = True\n        return arr\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.LineRoi.angle","title":"<code>angle()</code>","text":"<p>Angle in degrees.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def angle(self) -&gt; float:\n    \"\"\"Angle in degrees.\"\"\"\n    return math.degrees(math.atan2(self.y2 - self.y1, self.x2 - self.x1))\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.LineRoi.arange","title":"<code>arange(step=1.0)</code>","text":"<p>Return a tuple of x and y coordinates of np.arange along the line.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def arange(\n    self, step: float = 1.0\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n    \"\"\"Return a tuple of x and y coordinates of np.arange along the line.\"\"\"\n    radian = self.radian()\n    num, rem = divmod(self.length(), step)\n    xrem = rem * math.cos(radian)\n    yrem = rem * math.sin(radian)\n    return (\n        np.linspace(self.x1, self.x2 - xrem, int(num) + 1),\n        np.linspace(self.y1, self.y2 - yrem, int(num) + 1),\n    )\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.LineRoi.length","title":"<code>length()</code>","text":"<p>Length of the line.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def length(self) -&gt; float:\n    \"\"\"Length of the line.\"\"\"\n    return math.hypot(self.x2 - self.x1, self.y2 - self.y1)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.LineRoi.linspace","title":"<code>linspace(num)</code>","text":"<p>Return a tuple of x and y coordinates of np.linspace along the line.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def linspace(self, num: int) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n    \"\"\"Return a tuple of x and y coordinates of np.linspace along the line.\"\"\"\n    return np.linspace(self.x1, self.x2, num), np.linspace(self.y1, self.y2, num)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.LineRoi.radian","title":"<code>radian()</code>","text":"<p>Angle in radians.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def radian(self) -&gt; float:\n    \"\"\"Angle in radians.\"\"\"\n    return math.atan2(self.y2 - self.y1, self.x2 - self.x1)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.PointRoi2D","title":"<code>PointRoi2D</code>","text":"<p>ROI that represents a single point.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>x</code> <code>float</code> <p>X-coordinate of the point.</p> required <code>y</code> <code>float</code> <p>Y-coordinate of the point.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class PointRoi2D(Roi2D):\n    \"\"\"ROI that represents a single point.\"\"\"\n\n    x: float = Field(..., description=\"X-coordinate of the point.\")\n    y: float = Field(..., description=\"Y-coordinate of the point.\")\n\n    def shifted(self, dx: float, dy: float) -&gt; PointRoi2D:\n        return self.model_copy(update={\"x\": self.x + dx, \"y\": self.y + dy})\n\n    def bbox(self) -&gt; Rect[float]:\n        return Rect(self.x, self.y, 0, 0)\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        arr = np.zeros(shape, dtype=bool)\n        arr[..., int(round(self.y)), int(round(self.x))] = True\n        return arr\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.PointsRoi2D","title":"<code>PointsRoi2D</code>","text":"<p>ROI that represents a set of points.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>xs</code> <code>Any</code> <p>List of x-coordinates.</p> required <code>ys</code> <code>Any</code> <p>List of y-coordinates.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class PointsRoi2D(Roi2D):\n    \"\"\"ROI that represents a set of points.\"\"\"\n\n    xs: Any = Field(..., description=\"List of x-coordinates.\")\n    ys: Any = Field(..., description=\"List of y-coordinates.\")\n\n    @field_validator(\"xs\", \"ys\")\n    def _validate_np_arrays(cls, v) -&gt; NDArray[np.number]:\n        out = np.asarray(v)\n        if out.dtype.kind not in \"if\":\n            raise ValueError(\"Must be a numerical array.\")\n        return out\n\n    def shifted(self, dx: float, dy: float) -&gt; PointsRoi2D:\n        return self.model_copy(update={\"xs\": self.xs + dx, \"ys\": self.ys + dy})\n\n    def bbox(self) -&gt; Rect[float]:\n        xmin, xmax = np.min(self.xs), np.max(self.xs)\n        ymin, ymax = np.min(self.ys), np.max(self.ys)\n        return Rect(xmin, ymin, xmax - xmin, ymax - ymin)\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        arr = np.zeros(shape, dtype=bool)\n        xs = np.asarray(self.xs).round().astype(int)\n        ys = np.asarray(self.ys).round().astype(int)\n        arr[..., ys, xs] = True\n        return arr\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.PolygonRoi","title":"<code>PolygonRoi</code>","text":"<p>ROI that represents a closed polygon.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>xs</code> <code>Any</code> <p>List of x-coordinates.</p> required <code>ys</code> <code>Any</code> <p>List of y-coordinates.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class PolygonRoi(SegmentedLineRoi):\n    \"\"\"ROI that represents a closed polygon.\"\"\"\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        return _utils.polygon_mask(shape, np.column_stack((self.ys, self.xs)))\n\n    def area(self) -&gt; float:\n        dot_xy = np.dot(self.xs, np.roll(self.ys, 1))\n        dot_yx = np.dot(self.ys, np.roll(self.xs, 1))\n        return np.abs(dot_xy - dot_yx) / 2\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RectangleRoi","title":"<code>RectangleRoi</code>","text":"<p>ROI that represents a rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>x</code> <code>int | float</code> <p>X-coordinate of the top-left corner.</p> required <code>y</code> <code>int | float</code> <p>Y-coordinate of the top-left corner.</p> required <code>width</code> <code>int | float</code> <p>Width of the rectangle.</p> required <code>height</code> <code>int | float</code> <p>Height of the rectangle.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class RectangleRoi(Roi2D):\n    \"\"\"ROI that represents a rectangle.\"\"\"\n\n    x: Union[int, float] = Field(\n        ..., description=\"X-coordinate of the top-left corner.\"\n    )\n    y: Union[int, float] = Field(\n        ..., description=\"Y-coordinate of the top-left corner.\"\n    )\n    width: Union[int, float] = Field(..., description=\"Width of the rectangle.\")\n    height: Union[int, float] = Field(..., description=\"Height of the rectangle.\")\n\n    def shifted(self, dx: float, dy: float) -&gt; RectangleRoi:\n        \"\"\"Return a new rectangle shifted by the given amount.\"\"\"\n        return self.model_copy(update={\"x\": self.x + dx, \"y\": self.y + dy})\n\n    def area(self) -&gt; float:\n        \"\"\"Return the area of the rectangle.\"\"\"\n        return self.width * self.height\n\n    def bbox(self) -&gt; Rect[float]:\n        \"\"\"Return the bounding box of the rectangle.\"\"\"\n        return Rect(self.x, self.y, self.width, self.height)\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        bb = self.bbox().adjust_to_int(\"inner\")\n        arr = np.zeros(shape, dtype=bool)\n        arr[..., bb.top : bb.bottom, bb.left : bb.right] = True\n        return arr\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RectangleRoi.area","title":"<code>area()</code>","text":"<p>Return the area of the rectangle.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def area(self) -&gt; float:\n    \"\"\"Return the area of the rectangle.\"\"\"\n    return self.width * self.height\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RectangleRoi.bbox","title":"<code>bbox()</code>","text":"<p>Return the bounding box of the rectangle.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def bbox(self) -&gt; Rect[float]:\n    \"\"\"Return the bounding box of the rectangle.\"\"\"\n    return Rect(self.x, self.y, self.width, self.height)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RectangleRoi.shifted","title":"<code>shifted(dx, dy)</code>","text":"<p>Return a new rectangle shifted by the given amount.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def shifted(self, dx: float, dy: float) -&gt; RectangleRoi:\n    \"\"\"Return a new rectangle shifted by the given amount.\"\"\"\n    return self.model_copy(update={\"x\": self.x + dx, \"y\": self.y + dy})\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.Roi1D","title":"<code>Roi1D</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>class Roi1D(RoiModel):\n    def shifted(self, dx: float, dy: float) -&gt; Self:\n        \"\"\"Return a new 1D ROI translated by the given amount.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.Roi1D.shifted","title":"<code>shifted(dx, dy)</code>","text":"<p>Return a new 1D ROI translated by the given amount.</p> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>def shifted(self, dx: float, dy: float) -&gt; Self:\n    \"\"\"Return a new 1D ROI translated by the given amount.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.Roi2D","title":"<code>Roi2D</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>class Roi2D(RoiModel):\n    def bbox(self) -&gt; Rect[float]:\n        \"\"\"Return the bounding box of the ROI.\"\"\"\n        raise NotImplementedError\n\n    def shifted(self, dx: float, dy: float) -&gt; Self:\n        \"\"\"Return a new 2D ROI translated by the given amount.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.Roi2D.bbox","title":"<code>bbox()</code>","text":"<p>Return the bounding box of the ROI.</p> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>def bbox(self) -&gt; Rect[float]:\n    \"\"\"Return the bounding box of the ROI.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.Roi2D.shifted","title":"<code>shifted(dx, dy)</code>","text":"<p>Return a new 2D ROI translated by the given amount.</p> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>def shifted(self, dx: float, dy: float) -&gt; Self:\n    \"\"\"Return a new 2D ROI translated by the given amount.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.Roi3D","title":"<code>Roi3D</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>class Roi3D(RoiModel):\n    def shifted(self, dx: float, dy: float, dz: float) -&gt; Self:\n        \"\"\"Return a new 3D ROI translated by the given amount.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.Roi3D.shifted","title":"<code>shifted(dx, dy, dz)</code>","text":"<p>Return a new 3D ROI translated by the given amount.</p> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>def shifted(self, dx: float, dy: float, dz: float) -&gt; Self:\n    \"\"\"Return a new 3D ROI translated by the given amount.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RoiListModel","title":"<code>RoiListModel</code>  <code>dataclass</code>","text":"<p>List of ROIs, with useful methods.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>str</code> <code>array([], dtype=object)</code> <code>indices</code> <code>str</code> <code>array([], shape=(0, 0), dtype=int32)</code> <code>axis_names</code> <code>str</code> <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src\\himena\\standards\\roi\\_list.py</code> <pre><code>class RoiListModel(NDObjectCollection[RoiModel]):\n    \"\"\"List of ROIs, with useful methods.\"\"\"\n\n    def model_dump_typed(self) -&gt; dict:\n        return {\n            \"rois\": [roi.model_dump_typed() for roi in self],\n            \"indices\": self.indices.tolist() if self.indices is not None else None,\n            \"axis_names\": self.axis_names,\n        }\n\n    @classmethod\n    def construct(cls, dict_: dict) -&gt; RoiListModel:\n        \"\"\"Construct an instance from a dictionary.\"\"\"\n        rois = []\n        for roi_dict in dict_[\"rois\"]:\n            if not isinstance(roi_dict, dict):\n                raise ValueError(f\"Expected a dictionary for 'rois', got: {roi_dict!r}\")\n            roi_type = roi_dict.pop(\"type\")\n            roi = RoiModel.construct(roi_type, roi_dict)\n            rois.append(roi)\n        return cls(\n            items=rois,\n            indices=np.array(dict_[\"indices\"], dtype=np.int32),\n            axis_names=dict_[\"axis_names\"],\n        )\n\n    def model_validate_json(self, text: str) -&gt; RoiListModel:\n        \"\"\"Validate the json string and return an instance.\"\"\"\n        js = json.loads(text)\n        return self.construct(js)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RoiListModel.construct","title":"<code>construct(dict_)</code>  <code>classmethod</code>","text":"<p>Construct an instance from a dictionary.</p> Source code in <code>src\\himena\\standards\\roi\\_list.py</code> <pre><code>@classmethod\ndef construct(cls, dict_: dict) -&gt; RoiListModel:\n    \"\"\"Construct an instance from a dictionary.\"\"\"\n    rois = []\n    for roi_dict in dict_[\"rois\"]:\n        if not isinstance(roi_dict, dict):\n            raise ValueError(f\"Expected a dictionary for 'rois', got: {roi_dict!r}\")\n        roi_type = roi_dict.pop(\"type\")\n        roi = RoiModel.construct(roi_type, roi_dict)\n        rois.append(roi)\n    return cls(\n        items=rois,\n        indices=np.array(dict_[\"indices\"], dtype=np.int32),\n        axis_names=dict_[\"axis_names\"],\n    )\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RoiListModel.model_validate_json","title":"<code>model_validate_json(text)</code>","text":"<p>Validate the json string and return an instance.</p> Source code in <code>src\\himena\\standards\\roi\\_list.py</code> <pre><code>def model_validate_json(self, text: str) -&gt; RoiListModel:\n    \"\"\"Validate the json string and return an instance.\"\"\"\n    js = json.loads(text)\n    return self.construct(js)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RoiModel","title":"<code>RoiModel</code>","text":"<p>Base class for ROIs (Region of Interest) in images.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>class RoiModel(BaseModel):\n    \"\"\"Base class for ROIs (Region of Interest) in images.\"\"\"\n\n    name: str | None = Field(None, description=\"Name of the ROI.\")\n\n    def model_dump_typed(self) -&gt; dict:\n        return {\n            \"type\": _strip_roi_suffix(type(self).__name__.lower()),\n            **self.model_dump(),\n        }\n\n    @classmethod\n    def construct(cls, typ: str, dict_: dict) -&gt; RoiModel:\n        \"\"\"Construct an instance from a dictionary.\"\"\"\n        model_type = pick_roi_model(typ)\n        return model_type.model_validate(dict_)\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        raise NotImplementedError\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RoiModel.construct","title":"<code>construct(typ, dict_)</code>  <code>classmethod</code>","text":"<p>Construct an instance from a dictionary.</p> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>@classmethod\ndef construct(cls, typ: str, dict_: dict) -&gt; RoiModel:\n    \"\"\"Construct an instance from a dictionary.\"\"\"\n    model_type = pick_roi_model(typ)\n    return model_type.model_validate(dict_)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RotatedEllipseRoi","title":"<code>RotatedEllipseRoi</code>","text":"<p>ROI that represents a rotated ellipse.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>start</code> <code>tuple[float, float]</code> <p>Coordinate of the start point.</p> required <code>end</code> <code>tuple[float, float]</code> <p>Coordinate of the end point.</p> required <code>width</code> <code>float</code> <p>Width of the ROI.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class RotatedEllipseRoi(RotatedRoi2D):\n    \"\"\"ROI that represents a rotated ellipse.\"\"\"\n\n    def area(self) -&gt; float:\n        return self.length() * self.width * math.pi / 4\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        _yy, _xx = np.indices(shape[-2:])\n        start_x, start_y = self.start\n        end_x, end_y = self.end\n        length = math.hypot(end_x - start_x, end_y - start_y)\n        cx, cy = (start_x + end_x) / 2, (start_y + end_y) / 2\n        angle = self.angle_radian()\n        comp_a = (_yy - cy) / length * 2\n        comp_b = (_xx - cx) / self.width * 2\n        comp_a, comp_b = (\n            comp_a * math.cos(angle) - comp_b * math.sin(angle),\n            comp_a * math.sin(angle) + comp_b * math.cos(angle),\n        )\n        return comp_a**2 + comp_b**2 &lt;= 1\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.RotatedRectangleRoi","title":"<code>RotatedRectangleRoi</code>","text":"<p>ROI that represents a rotated rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>start</code> <code>tuple[float, float]</code> <p>Coordinate of the start point.</p> required <code>end</code> <code>tuple[float, float]</code> <p>Coordinate of the end point.</p> required <code>width</code> <code>float</code> <p>Width of the ROI.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class RotatedRectangleRoi(RotatedRoi2D):\n    \"\"\"ROI that represents a rotated rectangle.\"\"\"\n\n    def area(self) -&gt; float:\n        return self.length() * self.width\n\n    def bbox(self) -&gt; Rect[float]:\n        p00, p01, p11, p10 = self._get_vertices()\n        xmin = min(p00[0], p01[0], p10[0], p11[0])\n        xmax = max(p00[0], p01[0], p10[0], p11[0])\n        ymin = min(p00[1], p01[1], p10[1], p11[1])\n        ymax = max(p00[1], p01[1], p10[1], p11[1])\n        return Rect(xmin, ymin, xmax - xmin, ymax - ymin)\n\n    def _get_vertices(self):\n        start_x, start_y = self.start\n        end_x, end_y = self.end\n        vx, vy = self._get_vx_vy()\n        center = np.array([start_x + end_x, start_y + end_y]) / 2\n        p00 = center - vx / 2 - vy / 2\n        p01 = center - vx / 2 + vy / 2\n        p10 = center + vx / 2 - vy / 2\n        p11 = center + vx / 2 + vy / 2\n        return p00, p01, p11, p10\n\n    def to_mask(self, shape: tuple[int, ...]):\n        vertices = np.stack(self._get_vertices(), axis=0)\n        return _utils.polygon_mask(shape, vertices[:, ::-1])\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.SegmentedLineRoi","title":"<code>SegmentedLineRoi</code>","text":"<p>ROI that represents a segmented line.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>xs</code> <code>Any</code> <p>List of x-coordinates.</p> required <code>ys</code> <code>Any</code> <p>List of y-coordinates.</p> required Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class SegmentedLineRoi(PointsRoi2D):\n    \"\"\"ROI that represents a segmented line.\"\"\"\n\n    def length(self) -&gt; np.float64:\n        return np.sum(self.lengths())\n\n    def lengths(self) -&gt; NDArray[np.float64]:\n        return np.hypot(np.diff(self.xs), np.diff(self.ys))\n\n    def linspace(self, num: int) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n        \"\"\"Return a tuple of x and y coordinates of np.linspace along the line.\"\"\"\n        tnots = np.concatenate([[0], self.lengths()], dtype=np.float64)\n        teval = np.linspace(0, tnots.sum(), num)\n        xi = np.interp(teval, tnots, self.xs)\n        yi = np.interp(teval, tnots, self.ys)\n        return xi, yi\n\n    def arange(\n        self, step: float = 1.0\n    ) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n        tnots = np.concatenate([[0], self.lengths()], dtype=np.float64)\n        length = tnots.sum()\n        num, rem = divmod(length, step)\n        teval = np.linspace(0, tnots.sum() - rem, int(round(num)))\n        xi = np.interp(teval, tnots, self.xs)\n        yi = np.interp(teval, tnots, self.ys)\n        return xi, yi\n\n    def to_mask(self, shape: tuple[int, ...]) -&gt; NDArray[np.bool_]:\n        arr = np.zeros(shape, dtype=bool)\n        xs, ys = self.linspace(int(math.ceil(self.length())))\n        xs = xs.round().astype(int)\n        ys = ys.round().astype(int)\n        arr[ys, xs] = True\n        return arr\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.SegmentedLineRoi.linspace","title":"<code>linspace(num)</code>","text":"<p>Return a tuple of x and y coordinates of np.linspace along the line.</p> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>def linspace(self, num: int) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n    \"\"\"Return a tuple of x and y coordinates of np.linspace along the line.\"\"\"\n    tnots = np.concatenate([[0], self.lengths()], dtype=np.float64)\n    teval = np.linspace(0, tnots.sum(), num)\n    xi = np.interp(teval, tnots, self.xs)\n    yi = np.interp(teval, tnots, self.ys)\n    return xi, yi\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.SplineRoi","title":"<code>SplineRoi</code>","text":"<p>ROI that represents a spline curve.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name of the ROI.</p> <code>None</code> <code>degree</code> <code>int</code> <p>Degree of the spline curve.</p> <code>3</code> Source code in <code>src\\himena\\standards\\roi\\core.py</code> <pre><code>class SplineRoi(Roi2D):\n    \"\"\"ROI that represents a spline curve.\"\"\"\n\n    degree: int = Field(3, description=\"Degree of the spline curve.\", ge=1)\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.default_roi_label","title":"<code>default_roi_label(nth)</code>","text":"<p>Return a default label for the n-th ROI.</p> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>def default_roi_label(nth: int) -&gt; str:\n    \"\"\"Return a default label for the n-th ROI.\"\"\"\n    return f\"ROI-{nth}\"\n</code></pre>"},{"location":"api/standards/roi/#himena.standards.roi.pick_roi_model","title":"<code>pick_roi_model(typ)</code>  <code>cached</code>","text":"<p>Pick an ROI model class from the given type string</p> Source code in <code>src\\himena\\standards\\roi\\_base.py</code> <pre><code>@cache\ndef pick_roi_model(typ: str) -&gt; type[RoiModel]:\n    \"\"\"Pick an ROI model class from the given type string\"\"\"\n    for sub in iter_subclasses(RoiModel):\n        if _strip_roi_suffix(sub.__name__.lower()) == typ:\n            return sub\n    raise ValueError(f\"Unknown ROI type: {typ!r}\")\n</code></pre>"},{"location":"dev/","title":"Developer's Guide","text":"<ul> <li>The WidgetDataModel Standard</li> <li>Plugin System</li> <li>Reader and Writer Functions</li> <li>Register Functions</li> <li>Register Widgets</li> <li>Register Dock Widgets</li> </ul>"},{"location":"dev/io_provider/","title":"Reader and Writer Functions","text":"<p>This section tells you how to extend the \"Open File(s) ...\" and \"Save ...\" actions so that it works for any file types you'd like to use in <code>himena</code>.</p>"},{"location":"dev/io_provider/#readerwriter-plugins","title":"Reader/Writer Plugins","text":"<p><code>himena</code> uses a <code>register_reader_plugin</code> and <code>register_writer_plugin</code> functions to register functions as reader/writer plugins.</p> <p>The example below is a simple text file reader plugin.</p> <pre><code>from pathlib import Path\nfrom himena.consts import StandardType\nfrom himena.plugins import register_reader_plugin\n\n@register_reader_plugin\ndef read_text(path: Path):\n    text_value = path.read_text()\n    return WidgetDataModel(\n        value=text_value,\n        type=StandardType.TEXT,\n        title=path.name,\n    )\n</code></pre> <p>Now <code>read_text</code> is a reader plugin object.</p> <pre><code>read_text\n</code></pre> Output<pre><code>&lt;ReaderPlugin read_text&gt;\n</code></pre> <p>This is not enough. When a path is given, <code>himena</code> does not know which reader function to be used. To let \".txt\" match the reader function we have just defined, use the <code>define_matcher</code> method. The matcher function must return <code>str</code> of data type if it can read the file, and <code>None</code> otherwise.</p> <pre><code>@read_text.define_matcher\ndef _(path: Path):\n    if path.suffix == \".txt\":\n        return StandardType.TEXT\n    return None\n</code></pre> <p>??? note\"Plugin priority\"</p> <pre><code>You can define the priority of the plugin to be chosen by passing the `priority`\nargument.\n\n``` python\n@register_reader_plugin(priority=10)\ndef read_text(path: Path):\n    ...\n```\n\n`priority` is set to `100` by default, and the default providers have `priority=0`,\nwhich means that if you override the reader/writer for a file type, your provider\nwill always be used.\n\nIf `priority` is negative, the plugin will not be used unless users explicitly\nchoose your plugin by \"Open File With ...\" command.\n</code></pre> <p>Danger</p> <p>The matcher function must not be a time-consuming function. When the application tries to open a file, all registered matcher functions are called.</p> <p>Similarly, you can define a writer plugin.</p> <pre><code>from pathlib import Path\nfrom himena.consts import StandardType\nfrom himena.plugins import register_writer_plugin\n\n@register_writer_plugin\ndef write_text(path: Path, model: WidgetDataModel):\n    return path.write_text(model.value)\n\n@write_text.define_matcher\ndef _(path: Path):\n    if path.suffix == \".txt\":\n        return True\n    return False\n</code></pre> <p>Unlike readers, matcher function returns <code>True</code> if the writer can write the file, and <code>False</code> otherwise.</p>"},{"location":"dev/plugin_system/","title":"Plugin System","text":"<p>To make your module discoverable by <code>himena</code>, you need to configure the <code>pyproject.toml</code> file.</p> <p>For example, if you have a module named <code>himena_my_plugin</code> and all the IO functions are registered in the <code>io</code> submodule, you need to add the following configuration to the <code>pyproject.toml</code> file.</p> <pre><code>[project.entry-points.\"himena.plugin\"]\n\"My Plugin IO\" = \"himena_my_plugin.io\"\n</code></pre> <p>The \"My Plugin IO\" is the display name of your plugin, and the value is the import path to the submodule.</p> <p>Note</p> <p>You don't have to create a new package just for the plugin. This single TOML field will allow your package integrated with <code>himena</code>.</p> <p>To improve the customizability of your plugin, your plugin should be well categorized. For example, IO, widgets, and data processing functions should be separated into different submodules.</p> <pre><code>[project.entry-points.\"himena.plugin\"]\n\"My Plugin IO\" = \"himena_my_plugin.io\"\n\"My Plugin Widgets\" = \"himena_my_plugin.widgets\"\n\"My Plugin Data Processing\" = \"himena_my_plugin.processing\"\n</code></pre>"},{"location":"dev/register_dock_widgets/","title":"Dock Widgets","text":"<p>Dock widgets can be added to the <code>himena</code> main window. Unlike the widgets that are supposed to be added to inside sub-windows, dock widgets don't need any <code>WidgetDataModel</code> to represent their state.</p> When to use dock widgets? <p>Unlike sub-windows, dock widgets are always visible to the user but don't have any internal data. Therefore, dock widgets are suitable for widgets that make data processing routines more efficiently. For example, dock widgets defined in <code>himena_builtins</code> include:</p> <ul> <li>Python interpreter console.</li> <li>File explorers.</li> <li>Command history viewer.</li> </ul>"},{"location":"dev/register_dock_widgets/#register-widget","title":"Register Widget","text":"<pre><code>from himena.plugin import register_dock_widget_action\n\nclass MyDockWidget:\n    ...  # implementation\n\n@register_dock_widget_action(\n    title=\"My Dock Widget\",  # (1)\n    area=\"bottom\",  # (2)\n)\ndef my_dock_widget_action(ui):\n    # Construct and return the dock widget.\n    return MyDockWidget(ui)\n</code></pre> <ol> <li><code>title</code>: The title of the dock widget.</li> <li><code>area</code>: The area where the dock widget is placed. The value can be one of <code>\"left\"</code>,    <code>\"right\"</code>, <code>\"top\"</code>, or <code>\"bottom\"</code>.</li> </ol>"},{"location":"dev/register_dock_widgets/#plugin-configuration","title":"Plugin Configuration","text":"<p><code>himena</code> natively supports plugin configuration that can be defined by the developer and customized by the end user in the setting dialog.</p> <p>To define a plugin configuration, the simplest way is to define a data class.</p> <pre><code>from dataclasses import dataclass, field\n\n@dataclass\nclass MyPluginConfig:\n    some_default_value: str = field(default=\"Hello, world!\")\n</code></pre> <p>Pass the configuration instance to the <code>register_dock_widget_action</code> decorator</p> <pre><code>@register_dock_widget_action(\n    title=\"My Dock Widget\",\n    area=\"bottom\",\n    config=MyPluginConfig(),\n)\ndef my_dock_widget_action(ui):\n    ...\n</code></pre> <p>and define <code>update_configs</code> method in the dock widget class.</p> <pre><code>class MyDockWidget:\n    def update_configs(self, cfg: MyPluginConfig):\n        ... # update the widget state based on the configuration\n</code></pre> <p>This way, <code>MyPluginConfig</code> can be customized in the setting dialog and serialized to the user profile so that it is persistent across sessions.</p>"},{"location":"dev/register_functions/","title":"Register Functions","text":"<p>To process and analyze data, you need functions that convert an object into another. This section tells you how to register such functions so that you can run them on the GUI.</p>"},{"location":"dev/register_functions/#function-definition","title":"Function Definition","text":"<p>Basically, a function that processes data is a function that takes a <code>WidgetDataModel</code> object and returns another <code>WidgetDataModel</code> object. For example, the following function formats a non-indented json text data into an indented, pretty json text data.</p> <pre><code>from himena import WidgetDataModel\n\ndef format_json(model: WidgetDataModel) -&gt; WidgetDataModel:\n    value = json.dumps(json.loads(model.value), indent=4)\n    return WidgetDataModel(value=value, type=\"text\")\n</code></pre> <p>Because <code>himena</code> has its default widget for <code>\"text\"</code>-type model, this function can be readly used in the GUI. You can register this function using <code>register_function()</code> function.</p> <pre><code>from himena import WidgetDataModel\nfrom himena.plugins import register_function\nimport json\n\n@register_function(title=\"Format JSON Text\")\ndef format_json(model: WidgetDataModel) -&gt; WidgetDataModel:\n    value = json.dumps(json.loads(model.value), indent=4)\n    return WidgetDataModel(value=value, type=\"text\")\n</code></pre> <p>The registered function will be shown in the menu bar (under the \"Plugins\" menu by default) and the command palette. When this function is called from the GUI, currently active window will be converted into a <code>WidgetDataModel</code> object and passed to the function. The returned <code>WidgetDataModel</code> object will then be converted into another window.</p>"},{"location":"dev/register_functions/#dependency-injection-and-type-narrowing","title":"Dependency Injection and Type Narrowing","text":"<p><code>himena</code> uses <code>in_n_out</code> library to inject the application context into functions. For example, in the previous example, the <code>WidgetDataModel</code> of the current window is injected to the <code>model</code> argument of the <code>format_json</code> function. If no window is activated, the \"Format JSON Text\" menu is grayed out.</p> <p>A problem of the example above is that the <code>model</code> argument may contain any type of data (not only <code>\"text\"</code>-type data). To narrow the type of data, you can use the <code>types</code> argument of the <code>register_function()</code> decorator.</p> <pre><code>from himena.consts import StandardType\n\n@register_function(\n    title=\"Format JSON Text\",\n    types=[StandardType.TEXT],\n)\ndef format_json(model: WidgetDataModel) -&gt; WidgetDataModel:\n    ...\n</code></pre> <p>With this, the \"Format JSON Text\" menu will be enabled only if the current window is a widget for <code>\"text\"</code>-type data. Another benefit is that this command will be added to the model menu of the <code>\"text\"</code>-type widget.</p>"},{"location":"dev/register_functions/#parametric-functions","title":"Parametric Functions","text":"<p>Many functions require parameter inputs. It is very easy to implement a parametric function in Python: just add more arguments to the function. However, implementing parametric functions in GUI is usually tedious, as you need to create a specific widget for every function.</p> <p><code>himena</code> uses <code>magicgui</code> package to convert a function with parameters into a GUI widget based on the type hint of the function. Therefore, you can easily register a parametric function just by returning a function that takes parameters. To tell <code>himena</code> that the returned value should be converted into a GUI for user input of parameters, you need to annotate the returned value with the <code>Parametric</code> type.</p> <pre><code>from himena.plugins import register_function\nfrom himena.types import Parametric\n\n@register_function(\n    title=\"Format JSON Text\",\n    types=[StandardType.TEXT],\n)\ndef format_json(model: WidgetDataModel) -&gt; Parametric:\n    def run_format_json(indent: int = 4):\n        value = json.dumps(json.loads(model.value), indent=indent)\n        return WidgetDataModel(value=value, type=\"text\")\n    return run_format_json\n</code></pre>"},{"location":"dev/register_functions/#configure-parameter-input-window","title":"Configure Parameter Input Window","text":"<p>The parameter input window is automatically generated by <code>magicgui</code>. However, you can further customize its apparence by <code>configure_gui()</code> decorator.</p> <p>``` python hl_lines=\"1,9\" from himena.plugins import register_function, configure_gui from himena.types import Parametric</p> <p>@register_function(     title=\"Format JSON Text\",     types=[StandardType.TEXT], ) def format_json(model: WidgetDataModel) -&gt; Parametric:     @configure_gui(         indent={\"label\": \"Indent in Spaces\", \"min\": 0, \"max\": 8},     )     def run_format_json(indent: int = 4):         value = json.dumps(json.loads(model.value), indent=indent)         return WidgetDataModel(value=value, type=\"text\")     return run_format_json <pre><code>`configure_gui` can take keyword arguments that are passed to the function it decorates,\nand use `dict` to configure the widget used for the parameter input.\n\nHere's some of the options you can use.\n\n- `label`: The label of the input field.\n- `value`: The default value.\n- `choices`: List of choices.\n- `widget_type`: Widget class to use. This option must be a [`magicgui` ValueWidget](https://pyapp-kit.github.io/magicgui/widgets/).\n- `min`: The minimum value (if applicable).\n- `max`: The maximum value (if applicable).\n\n## Preview Function Outputs\n\nIn some cases, parameters should be tuned based on the output of the function. For\nexample in the case of the `format_json` function, the user may want to see the output\nso that the json string looks good. To add a \"preview\" toggle button to the parameter\ninput window, just add the `preview` argument to the `configure_gui()` decorator.\n\n``` python hl_lines=\"7\"\n@register_function(\n    title=\"Format JSON Text\",\n    types=[StandardType.TEXT],\n)\ndef format_json(model: WidgetDataModel) -&gt; Parametric:\n    @configure_gui(\n        preview=True,\n    )\n    def run_format_json(indent: int = 4):\n        value = json.dumps(json.loads(model.value), indent=indent)\n        return WidgetDataModel(value=value, type=\"text\")\n    return run_format_json\n</code></pre></p>"},{"location":"dev/register_functions/#_1","title":"Register Functions","text":""},{"location":"dev/register_widgets/","title":"Register Widgets","text":""},{"location":"dev/register_widgets/#protocols","title":"Protocols","text":"<p>To avoid the potential dangers of metaclass collision and method collision, <code>himena</code> do not use a super class to define plugin widgets. Instead, your plugin widgets have to implement protocols (methods with correct name and arguments) to enable the communication between the plugin and the main application.</p> Check misspelling <p>Because the plugin widgets do not inherit anything like plugin classes, you have to be careful not to misspell the method name. To check if the method name is correct, you can decorate the protocol methods with <code>validate_protocol</code> decorator.</p> <pre><code>from himena.plugins import validate_protocol\n\nclass MyWidget:\n    @validate_protocol\n    def udpate_model(self, model):  # misspelled, raises error\n        ...\n</code></pre> <p>All the protocols are optional, but to make the plugin better, you should implement as many protocols as possible.</p>"},{"location":"dev/register_widgets/#compatibility-with-widgetdatamodel-standard","title":"Compatibility with <code>WidgetDataModel</code> Standard","text":"<p>To make the plugin widgets compatible with the <code>WidgetDataModel</code> standard that is used everywhere in <code>himena</code>, you have to implement the following protocols:</p> <ul> <li><code>update_model(self, model: WidgetDataModel) -&gt; None</code>: Update the widget state based   on the model.</li> <li><code>to_model(self) -&gt; WidgetDataModel</code>: Return the model that represents the current   state of the widget.</li> <li><code>model_type(self) -&gt; str</code>: Return the type of the model that the widget uses. Model   type is frequently checked in many occasions, so you should implement this method if   <code>to_model</code> is computationally expensive.</li> <li><code>update_value(self, value: Any) -&gt; None</code>: Update the widget state based on the value   without changing the states that are described by the <code>metadata</code> field of the   <code>WidgetDataModel</code>. This method is preferentially called by the <code>update_value</code> method   of <code>SubWindow</code> class.</li> </ul>"},{"location":"dev/register_widgets/#control-widget","title":"Control Widget","text":"<p>The control widget is a widget that is added to the tool bar of the main window to make the sub-window area tidy. This widget can be defined by implementing the following protocol.</p> <ul> <li><code>control_widget(self) -&gt; &lt;backend widget type&gt;</code>: Construct and return the control   widget.</li> </ul> <p>The return type must be interpretable by the backend GUI library. For example, if your plugin widget is implemented using <code>Qt</code>, the return type should be a <code>QWidget</code> object as well.</p>"},{"location":"dev/register_widgets/#use-wrapper-class","title":"Use Wrapper Class","text":"<p>Python already has a lot of libraries that wrap other GUI libraries to provide better interface. In <code>himena</code>, you can directly use these wrapper classes and implement all the protocols on the wrapper class. In this case, you will have to tell where the backend widget is located, which can be done by implementing the following protocol.</p> <ul> <li><code>native_widget(self) -&gt; &lt;backend widget type&gt;</code>: Return the backend widget that is   wrapped by the wrapper class.</li> </ul>"},{"location":"dev/register_widgets/#widget-interactivity","title":"Widget Interactivity","text":"<p>Widgets can be interactively modified by the user. To change the interactivity, or to programmatically mark the widget as modified, you can implement the following protocols.</p> <ul> <li><code>is_editable(self) -&gt; bool</code>: Return whether the widget is editable or not.</li> <li><code>set_editable(self, editable: bool) -&gt; None</code>: Set the widget editable or not.</li> <li><code>is_modified(self) -&gt; bool</code>: Return whether the underlying data is modified or not.</li> <li><code>set_modified(self, modified: bool) -&gt; None</code>: Set the modified state of the widget.</li> </ul>"},{"location":"dev/register_widgets/#response-to-the-gui-events","title":"Response to the GUI Events","text":"<p>Sometimes your widget needs to catch the GUI events to update the widget state.</p> <ul> <li><code>theme_changed_callback(self, theme: Theme) -&gt; None</code>: Called when the theme of the   application is changed. The <code>Theme</code> object is a data class that contains the color   theme of the application.</li> <li><code>widget_added_callback(self) -&gt; None</code>: Called when the sub-window containing this   widget is added to the main window.</li> <li><code>widget_activated_callback(self) -&gt; None</code>: Called when the sub-window containing this   widget is activated (clicked or focus).</li> <li><code>widget_closed_callback(self) -&gt; None</code>:  Called when the sub-window containing this   widget is closed.</li> <li><code>widget_resized_callback(self, old_size: Size, new_size: Size) -&gt; None</code>: Called when   the sub-window containing this widget is resized from the old size to a new size.   <code>Size</code> is a tuple like object with <code>width</code> and <code>height</code> fields.</li> </ul>"},{"location":"dev/register_widgets/#drag-and-drop","title":"Drag and Drop","text":"<p>Drag-and-drop operation is handled using <code>DragDropModel</code>.</p> <ul> <li><code>dropped_callback(self, model: DragDropModel) -&gt; None</code>: Callback method when an item   is dropped on the widget.</li> <li><code>allowed_drop_types(self) -&gt; list[str]</code>: List of types that the widget accepts.</li> </ul>"},{"location":"dev/register_widgets/#widget-appearance","title":"Widget Appearance","text":"<ul> <li><code>size_hint(self) -&gt; tuple[int, int]</code>: Return the size hint of the widget. This method   is called when the widget is added to the main window.</li> <li><code>default_title(self) -&gt; str</code>: Return the default title of the widget. This method is   called when the widget is added to the main window without specifying the title.</li> </ul>"},{"location":"dev/register_widgets/#register-the-widget","title":"Register the Widget","text":"<pre><code>from qtpy import QtWidgets as QtW\nfrom himena.plugins import validate_protocol\n\nclass MyWidget(QtW.QTextEdit):\n    def __init__(self):\n        super().__init__()\n\n    @validate_protocol\n    def update_model(self, model):\n        assert model.type == \"text\"\n        self.setPlainText(model.value)\n\n    @validate_protocol\n    def to_model(self):\n        return WidgetDataModel(value=self.toPlainText(), type=\"text\")\n\n    @validate_protocol\n    def size_hint(self):\n        return 400, 300\n</code></pre> <p>Once you have implemented the protocols like above, you can register the widget class using the <code>register_widget_class</code> function.</p> <pre><code>from himena import StandardType\nfrom himena.plugins import register_widget_class\n\nregister_widget_class(StandardType.TEXT, MyWidget)\n</code></pre> <p>The first argument is the type of the data the widget class is supposed to handle. Whenever the application is requested to add a data model of that type, this widget will be constructed like below:</p> <pre><code>widget = MyWidget()\nwidget.update_model(model)\n</code></pre> <p>and added to the main window inside a sub-window.</p> Register function instead of class <p>Because what is done here is just calling the constructor of the widget class, the object registered by the <code>register_widget_class</code> function does not have to be a class. You can also register a function that returns the widget object.</p> <pre><code>def create_widget():\n    return MyWidget()\n\nregister_widget_class(StandardType.TEXT, create_widget)\n</code></pre> <p>This is useful when you want to execute the file that defines the widget class lazily, in order to reduce the startup time of the application.</p>"},{"location":"dev/widget_data_model/","title":"The WidgetDataModel Standard","text":"<p>All the widgets in <code>himena</code> are built on the <code>WidgetDataModel</code> standard. A <code>WidgetDataModel</code> is a Python object that represents a value of any type, tagged with some additional information of how to interpret the value in GUI. For example, a text data \"xyz\" read from a txt file can be written as follows:</p> <pre><code>WidgetDataModel(value=\"abc\", type=\"text\")\n</code></pre> <p>All the \"data-embedded\" widgets in <code>himena</code> implements <code>update_model()</code> method to update the state of the widget from a <code>WidgetDataModel</code> object, and <code>to_model()</code> method to dump the state of the widget to a <code>WidgetDataModel</code> object.</p> <pre><code>class TextViewer:\n    def __init__(self):\n        # some GUI-specific initialization ...\n\n    def update_model(self, model: WidgetDataModel):\n        self.set_text(model.value)\n\n    def to_model(self) -&gt; WidgetDataModel:\n        return WidgetDataModel(value=self.get_text(), type=\"text\")\n</code></pre> <p>This widget can be registered as a widget that represents a <code>\"text\"</code>-type data using <code>register_widget_class()</code> function.</p> <pre><code>from himena.plugins import register_widget_class\n\nregister_widget_class(\"text\", widget_class=TextViewer)\n</code></pre> <p>The <code>WidgetDataModel</code> standard makes the different part of development very clear-cut.</p> <ul> <li> <p>Reader function is a GUI-independent function that reads a file and returns   a <code>WidgetDataModel</code>.</p> Example reader function<pre><code>def read_txt(file_path: Path) -&gt; WidgetDataModel:\n    text_value = file_path.read_text()\n    return WidgetDataModel(value=text_value, type=\"text\")\n</code></pre> </li> </ul> <p>A proper widget class will be automatically selected based on the <code>type</code> field, and   updated based on the returned model using <code>update_model()</code> method.</p> <ul> <li> <p>Writer function is a GUI-independent function that writes a <code>WidgetDataModel</code>   to a file.</p> Example writer function<pre><code>def write_text(file_path: Path, model: WidgetDataModel):\n    file_path.write_text(model.value)\n</code></pre> </li> </ul> <p>A widget will be automatically converted to a model using <code>to_model()</code> method before   calling this writer function.</p> <ul> <li> <p>Any function for data processing or analysis is also GUI-independent functions   that just convert a <code>WidgetDataModel</code> into another.</p> Example data processing function<pre><code>def to_upper(model: WidgetDataModel) -&gt; WidgetDataModel:\n    assert isinstance(model.value, str)\n    return WidgetDataModel(value=model.value.upper(), type=\"text\")\n</code></pre> <p>A widget will be automatically converted to a model using <code>to_model()</code> method before calling this function, and sent back to the GUI as another widget created based on the returned model.</p> </li> </ul>"},{"location":"dev/widget_data_model/#choosing-the-type","title":"Choosing the Type","text":"<p>You can use any string for <code>type</code> field, but to make your widget interpretable for the <code>himena</code> built-in functions and probably for other plugins, you may want to use the <code>StandardType</code>.</p> <pre><code>from himena.const import StandardType\n\nStandardType.TEXT  # \"text\"\nStandardType.TABLE  # \"table\"\nStandardType.ARRAY  # \"array\"\nStandardType.IMAGE  # \"array.image\"\n</code></pre> <p>You can use \".\" to separate the type into a hierarchy. For example, the standard type <code>\"array.image\"</code> is used for an image data, but it is under \"array\" type because all the image data are essentially arrays. A benefit of this subtyping is that all the \"array\" functions can be applied to the \"array.image\" data.</p>"},{"location":"dev/widget_data_model/#more-specifications","title":"More Specifications","text":"<p>You can set other fields of <code>WidgetDataModel</code> to provide more details of how to convert the data to a widget.</p> <pre><code>WidgetDataModel(\n    value=\"abc\",\n    type=\"text\",\n    title=\"My Text\"  # title of the widget\n    extension_default=\".txt\",  # default file extension in the save dialog\n    extensions=[\".txt\", \".md\"]  # allowed file extensions in the save dialog\n)\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<ul> <li>Basics</li> <li>Tab/Window Manipluation</li> <li>Workflows</li> <li>Sessions</li> <li>Built-in Widgets</li> </ul>"},{"location":"usage/basics/","title":"Basics","text":""},{"location":"usage/basics/#application-design","title":"Application Design","text":""},{"location":"usage/basics/#appearance","title":"Appearance","text":"<p><code>himena</code> GUI has components as shown below.</p> <p></p> <ol> <li>Menu bar. It contains most of the registered commands in the application.</li> <li>Tool bar. It contains frequently used commands.</li> <li>Tab bar. Each tab contains a sub-window area where widgets are placed.</li> <li>Sub-window. Each sub-window contains a widget as its content.</li> <li>Control widget. Each widget has a control widget that provides functionalities    specific to the widget.</li> <li>Python interpreter console. A console widget that can execute Python codes.</li> <li>Dock widget. Widgets docked to the main window. These widgets are usually added    by plugins. The Python interpreter console is also a dock widget.</li> <li>Status bar. It shows a simple one-line message.</li> </ol>"},{"location":"usage/basics/#sub-window","title":"Sub-window","text":"<p>A sub-window usually represents a single data, such as a <code>ndarray</code> or <code>DataFrame</code>. Therefore, data processing is usually done by taking sub-windows as input and output.</p> <p></p> <p>Each data is wrapped by a <code>WidgetDataModel</code> object, which is tagged with some GUI-related information, so that the application understands how to display, save and track the data.</p> <pre><code>from himena.types import WidgetDataModel\nimport numpy as np\n\ndata = WidgetDataModel(value=np.arange(10), type=\"array\", title=\"my array\")  # (1)!\nwin = ui.add_data_model(data)  # (2)!\n</code></pre> <ol> <li>Create a WidgetDataModel object. To interpret the data as an array, set the <code>type</code>     attribute to <code>\"array\"</code>.</li> <li>Add the data model to the application as a sub-window.</li> </ol> <p>More simply, you can just call <code>ui.add_object</code> method to directly add an object to the application.</p> <pre><code>win = ui.add_object(np.arange(10), type=\"array\", title=\"my array\")\n</code></pre> <p>Data can be retrieved from the sub-window by calling <code>to_model</code> method.</p> <pre><code>win.to_model()\n</code></pre> Output<pre><code>WidgetDataModel(value=&lt;ndarray&gt;, source=None, type='array', title='my array')\n</code></pre> <p><pre><code>win.to_model().value\n</code></pre> Output<pre><code>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n</code></pre></p>"},{"location":"usage/basics/#opening-and-saving-files","title":"Opening and Saving Files","text":""},{"location":"usage/basics/#new-file","title":"New file","text":"<p>Press Ctrl+N and you will see a command palette pops up. This palette contains many commands that are related to adding new items to the application. This category includes</p> <ul> <li>Empty window, such as a text or table.</li> <li>Opening a sample data.</li> </ul> <p>For example, the \"New Text\" command will add a new text editor sub-window to the current tab.</p>"},{"location":"usage/basics/#open-files-from-the-local-disk","title":"Open files from the local disk","text":"<p><code>himena</code> supports several ways to open files from the local disk.</p>"},{"location":"usage/basics/#1-open-a-file-as-a-sub-window","title":"(1) Open a file as a sub-window","text":"<p>This is the most common way to open a file. You can open a file from \"File\" menu press Ctrl+O or drag-and-drop the file to the application.</p> <p>Whether the file can be opened, and the opened data can be displayed as a widget, depends on the plugins installed in the application profile.</p>"},{"location":"usage/basics/#2-open-a-folder-as-a-sub-window","title":"(2) Open a folder as a sub-window","text":"<p>A special built-in widget can display a list of <code>WidgetDataModel</code> as a nested widget. Opening a folder will read the folder contents as a collection like below. This command is available from the \"File\" menu, Ctrl+K \u2192 Ctrl+O, or drag-and-drop the folder to the application.</p> <p></p>"},{"location":"usage/basics/#3-open-a-group-of-files-as-a-sub-window","title":"(3) Open a group of files as a sub-window","text":"<p>Instead of opening a folder, you can open a group of files as a sub-window.</p>"},{"location":"usage/basics/#saving-files-to-the-local-disk","title":"Saving files to the local disk","text":"<p>You can save the data in the sub-window to the local disk by selecting \"File\" \u2192 \"Save\" or pressing Ctrl+S. Whether the data can be saved to the specified format depends on the plugins installed in the application profile.</p>"},{"location":"usage/basics/#data-processing","title":"Data Processing","text":"<p>Most of the functions for data processing are defined by functions that take a <code>WidgetDataModel</code> as the input and another <code>WidgetDataModel</code> as the output.</p> <p>For example, starting from the data below</p> <pre><code>df = {\"a\": [2, 3, 5], \"b\": [1.3, 3.2, -1.2]}\nui.add_object(df, type=\"dataframe\")\n</code></pre> <p>you can find \"Filter DataFrame ...\" command in the model menu. This command will open a window for the parameter input, filter the data frame and show the result in a new sub-window.</p> <p></p> <p>The history of the data processing is recorded to the <code>WidgetDataModel</code>. You can open it from the \"Show workflow graph\" command in the window menu.</p> <p></p> <p>Note</p> <p>The workflow is just a <code>WidgetDataModel</code> with type <code>\"workflow\"</code>. Therefore, this operation is just a data processing like any other operations.</p>"},{"location":"usage/builtin_dock_widgets/","title":"Built-in Dock Widgets","text":""},{"location":"usage/builtin_widgets/","title":"Built-in Widgets","text":"<p><code>himena</code> provides <code>himena_builtins</code> plugin package for the most basic widgets for the widely-used data types.</p> <p>Note</p> <p>The detailed description of the widgets are available by running the \"what is this widget?\" command in the window menu.</p>"},{"location":"usage/builtin_widgets/#text-editor-widget","title":"Text Editor Widget","text":"<p>A text widget is simply used to display and edit a text data. Optionally, you can specify the language of the text data to enable syntax highlighting.</p> Specification widget class <code>himena_builtins.qt.widgets.QTextEdit</code> model type <code>\"text\"</code> (<code>StandardType.TEXT</code>) data type <code>str</code> <p></p> <pre><code>from himena.standards.model_meta import TextMeta\n\nui.add_object(\n    \"import numpy as np\\n\\nprint(np.arange(10))\",\n    type=\"text\",\n    title=\"Text Data\",\n    metadata=TextMeta(language=\"python\")\n)\n</code></pre>"},{"location":"usage/builtin_widgets/#spreadsheet-widget","title":"Spreadsheet Widget","text":"<p>A spreadsheet widget is used to display and edit a table data. All the items are stored as strings, so that numerical operations on this widget are not very efficient.</p> Specification widget class <code>himena_builtins.qt.widgets.QSpreadsheet</code> model type <code>\"table\"</code> (<code>StandardType.TABLE</code>) data type <code>ndarray</code> of string dtype <p></p> <pre><code>ui.add_object(\n    [[\"key\", \"value\"], [\"name\", \"Alice\"], [\"age\", 20]],\n    type=\"table\",\n    title=\"Table Data\"\n)\n</code></pre>"},{"location":"usage/builtin_widgets/#dataframe-viewer-widget","title":"DataFrame Viewer Widget","text":"<p>A dataframe viewer widget is used to display a dataframe-like object. Unlike a spreadsheet widget, the underlying data is structured and typed.</p> Specification widget class <code>himena_builtins.qt.widgets.QDataFrameView</code> model type <code>\"dataframe\"</code> (<code>StandardType.DATAFRAME</code>) data type dataframe-like object, such as <code>dict[str, list]</code>, <code>pandas.DataFrame</code>, <code>polars.DataFrame</code> <p></p> <pre><code>ui.add_object(\n    {\n        \"kind\": [\"cat\", \"dog\", \"cat\", \"dog\", \"cat\", \"dog\", \"cat\", \"dog\"],\n        \"size\": [\"small\", \"small\", \"large\", \"large\", \"small\", \"small\", \"large\", \"large\"],\n        \"weight\": [8, 10, 12, 15, 11, 13, 9, 14],\n    },\n    type=\"dataframe\",\n    title=\"DataFrame Data\",\n)\n</code></pre>"},{"location":"usage/builtin_widgets/#dataframe-plot-widget","title":"DataFrame Plot Widget","text":"<p>A dataframe plot widget contains a dataframe-like object just like a dataframe viewer, but the data is supposed to be plotted. Therefore, non-numerical columns are not allowed.</p> Specification widget class <code>himena_builtins.qt.widgets.QDataFramePlotView</code> model type <code>\"dataframe.plot\"</code> (<code>StandardType.DATAFRAME_PLOT</code>) data type dataframe-like object, such as <code>dict[str, list]</code>, <code>pandas.DataFrame</code>, <code>polars.DataFrame</code> <p></p> <pre><code>import numpy as np\n\nx = np.linspace(0, 10, 100)\nui.add_object(\n    {\n        \"x\": x,\n        \"y1\": np.sin(x),\n        \"y2\": np.cos(x) * 1.4,\n    },\n    type=\"dataframe.plot\",\n    title=\"DataFrame Plot Data\",\n)\n</code></pre>"},{"location":"usage/builtin_widgets/#array-viewer-widget","title":"Array Viewer Widget","text":"<p>This widget is used to display a multi-dimensional array-like object.</p> Specification widget class <code>himena_builtins.qt.widgets.QArrayView</code> model type <code>\"array\"</code> (<code>StandardType.ARRAY</code>) data type array-like object, such as <code>numpy.ndarray</code>, <code>xarray.DataArray</code>, <code>dask.Array</code> <p></p> <pre><code>import numpy as np\n\nrng = np.random.default_rng(10)\nui.add_object(\n    rng.normal(size=(3, 40, 18)),\n    type=\"array\",\n    title=\"Array Data\",\n)\n</code></pre>"},{"location":"usage/builtin_widgets/#image-viewer-widget","title":"Image Viewer Widget","text":"<p>This widget is for displaying a multi-dimensional image data. Its design is inspired by ImageJ.</p> <p>2D image slices are displayed in the main view, and the current slice can be changed by the slider. This widget also supports drawing ROIs (Region of Interests) on the image. RGB, complex value and multi-channel images are also supported.</p> Specification widget class <code>himena_builtins.qt.widgets.QImageView</code> model type <code>\"array.image\"</code> (<code>StandardType.IMAGE</code>) data type array-like object, such as <code>numpy.ndarray</code>, <code>xarray.DataArray</code>, <code>dask.Array</code> <p></p> <pre><code>import numpy as np\nfrom himena.standards.model_meta import ImageMeta\nfrom himena.standards import roi\n\nyy, xx = np.indices((100, 100))\nimage_stack = []\nfor n in range(3):\n    image_stack.append(np.sin(xx / 10 * n) * np.cos(yy / 8))\nimage = np.stack(image_stack, axis=0)\nui.add_object(\n    image,\n    type=\"array.image\",\n    metadata=ImageMeta(\n        current_roi=roi.RectangleRoi(x=11, y=28, width=32, height=20),\n        axes=[\"z\", \"y\", \"x\"],\n    ),\n    title=\"Image Data\",\n)\n</code></pre>"},{"location":"usage/builtin_widgets/#plot-widget","title":"Plot Widget","text":"<p><code>himena_builtins</code> provides two types of plot widgets. One is based on the standard plot model defined in <code>himena.standards.plotting</code>, and the other is a direct display of <code>matplotlib.Figure</code> object.</p> <p>The standard plot model is designed to be inter-changeable between different plotting libraries, and <code>himena</code> can understand the underlying structure. Therefore, the plotted data can be read, modified and written consistently. On the other hand, the <code>matplotlib</code> figure object supports the complete set of <code>matplotlib</code> functions.</p> himena standard plot modelmatplotlib figure object Specification widget class <code>himena_builtins.qt.widgets.QModelMatplotlibCanvas</code> model type <code>\"plot\"</code> (<code>StandardType.PLOT</code>) data type the standard plot model defined in <code>himena.standards.plotting</code> Specification widget class <code>himena_builtins.qt.widgets.QMatplotlibCanvas</code> model type <code>\"matplotlib-figure\"</code> (<code>StandardType.MPL_FIGURE</code>) data type <code>matplotlib.Figure</code> object <p></p> <pre><code>from himena.standards import plotting as hplt\nimport numpy as np\n\nfig = hplt.figure()\nx = np.linspace(-1, 1, 100)\nfig.plot(x, np.cos(x) * np.exp(-x**2 / 2))\nxsparse = np.linspace(-1, 1, 9)\nfig.scatter(xsparse, np.cos(xsparse) * np.exp(-xsparse**2 / 2), color=\"black\")\nui.add_object(fig, type=\"plot\", title=\"Plot Data\")\n</code></pre>"},{"location":"usage/builtin_widgets/#excel-like-widget","title":"Excel-like Widget","text":"<p>This widget is used to display and edit a dictionary of tables, which is technically an Excel-like data. The keys of the dictionary are the names of the sheets.</p> Specification widget class <code>himena_builtins.qt.widgets.QExcelEdit</code> model type <code>\"dict.table\"</code> (<code>StandardType.EXCEL</code>) data type <code>dict[str, ndarray]</code> <p></p> <pre><code>ui.add_object(\n    {\n        \"format\": [[\"key\", \"value\"], [\"name\", \"\"], [\"age\", \"\"]],\n        \"example\": [[\"key\", \"value\"], [\"name\", \"Alice\"], [\"age\", 20]],\n    },\n    type=\"dict.table\",\n    title=\"Excel-like Data\",\n)\n</code></pre>"},{"location":"usage/builtin_widgets/#function-widget","title":"Function Widget","text":"<p>This widget contains a non-editable function object. A function widget is usually created by the \"Compile as a function\" command on a text data. A function widget is useful to be used as callable inputs for custom commands, such as <code>scipy.optimization</code> or <code>scipy.integrate</code>.</p> Specification widget class <code>himena_builtins.qt.widgets.QFunctionEdit</code> model type <code>\"function\"</code> (<code>StandardType.FUNCTION</code>) data type callable object <p></p> <pre><code>from himena.standards.model_meta import FunctionMeta\n\ndef example_function(x):\n    return x**2\n\nui.add_object(\n    example_function,\n    type=\"function\",\n    metadata=FunctionMeta(source_code=\"def example_function(x):\\n    return x**2\"),\n    title=\"Function Data\",\n)\n</code></pre>"},{"location":"usage/builtin_widgets/#image-roi-widget","title":"Image ROI Widget","text":"Specification widget class <code>himena_builtins.qt.widgets.QImageRoiView</code> model type <code>\"rois\"</code> (<code>StandardType.ROIS</code>) data type standard roi-list model in <code>himena.standards.roi</code> <pre><code>from himena.standards import roi\n\nroilist = roi.RoiListModel(\n    items=[\n        roi.LineRoi(x1=4, y1=6, x2=18, y2=-1, name=\"line-roi-0\"),\n        roi.LineRoi(x1=12, y1=14, x2=6, y2=4, name=\"line-roi-1\"),\n        roi.RectangleRoi(x=6, y=7, width=8, height=8.4, name=\"rect-roi-0\"),\n        roi.LineRoi(x1=4, y1=6, x2=18, y2=-1, name=\"line-roi-2\"),\n        roi.EllipseRoi(x=6, y=7, width=8, height=8.4, name=\"ellipse-roi-0\")\n    ]\n)\nwin = ui.add_object(roilist, type=\"rois\")\nwin.size = (200, 180)\n</code></pre>"},{"location":"usage/builtin_widgets/#jupyter-notebook-widget","title":"Jupyter Notebook Widget","text":"<p>Text contents in \"ipynb\" format can be rendered in a way similar to Jupyter Notebook.</p> Specification widget class <code>himena_builtins.qt.widgets.QIpynbEdit</code> model type <code>\"text.json.ipynb\"</code> (<code>StandardType.IPYNB</code>) data type <code>str</code> in the IPython Notebook format <p></p> <pre><code>text = r\"\"\"{\n \"cells\": [\n  {\n   \"cell_type\": \"code\",\n   \"outputs\": [{\"name\": \"stdout\", \"output_type\": \"stream\", \"text\": [\"[0 1 2 3 4]\\n\"]}],\n   \"source\": [\"import numpy as np\\n\", \"import matplotlib.pyplot as plt\\n\", \"\\n\", \"print(np.arange(5))\"]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"source\": [\"# Test\\n\", \"\\n\", \"- this is a test file.\"]\n  }\n ]\n}\"\"\"\n\nui.add_object(text, type=\"text.json.ipynb\", title=\"Jupyter Notebook\")\n</code></pre>"},{"location":"usage/builtin_widgets/#model-stack-widget","title":"Model Stack Widget","text":"Specification widget class <code>himena_builtins.qt.widgets.QModelStack</code> model type <code>\"models\"</code> (<code>StandardType.MODELS</code>) data type <code>list[WidgetDataModel]</code> <pre><code>from himena.types import WidgetDataModel\n\nmodels = [\n    WidgetDataModel(value=[[\"key\", \"value\"], [\"name\", \"Alice\"], [\"age\", 20]], type=\"table\", title=\"Table Data\"),\n    WidgetDataModel(value=\"\", type=\"text\", title=\"Text Data\"),\n]\nwin = ui.add_object(models, type=\"models\", title=\"Model Stack\")\nwin.size = (300, 250)\n</code></pre>"},{"location":"usage/builtin_widgets/#workflow-viewer-widget","title":"Workflow Viewer Widget","text":"<p>The workflow of each data can be visualized in this widget.</p> Specification widget class <code>himena_builtins.qt.widgets.QWorkflowView</code> model type <code>\"workflow\"</code> (<code>StandardType.WORKFLOW</code>) data type <code>himena.workflows.Workflow</code> object <p></p> <pre><code>ui.exec_action(\"builtins:new-text\")\nwin = ui.add_object(ui.current_model.workflow, type=\"workflow\", title=\"Workflow\")\nwin.size = (280, 120)\n</code></pre>"},{"location":"usage/sessions/","title":"Sessions","text":"<p>A \"session\" is a collection of tabs and sub-windows that can be saved and restored later. Sessions are useful for saving your work halfway through.</p>"},{"location":"usage/sessions/#basic-usage","title":"Basic Usage","text":""},{"location":"usage/sessions/#restore-a-session-by-workflows","title":"Restore a Session by Workflows","text":""},{"location":"usage/tab_and_window/","title":"Tab/Window Manipulation","text":"<p>The current state of the application can be programmatically manipulated by using the <code>ui</code> variable.</p>"},{"location":"usage/tab_and_window/#access-to-tabs-and-sub-windows","title":"Access to Tabs and Sub-windows","text":"<p><code>ui.tabs</code> is a list-like object that contains all the tab. Each tab is another list-like objects that contains all the sub-windows.</p> <pre><code>ui.tabs[0]  # The first tab\n</code></pre> Output Example<pre><code>TabArea([\n  SubWindow(title='Table-0', widget=&lt;builtins:QSpreadsheet&gt;),\n  SubWindow(title='Untitled-1', widget=&lt;builtins:QTextEdit&gt;),\n])\n</code></pre> <pre><code>ui.tabs[0][1]  # The second sub-window in the first tab\n</code></pre> Output Example<pre><code>SubWindow(title='Untitled-1', widget=&lt;builtins:QTextEdit&gt;)\n</code></pre> <p>Currently active tab and sub-window can be accessed by followign properties.</p> <pre><code>ui.tabs.current_index  # The index of the current tab\nui.tabs[0].current_index  # The index of the current sub-window in the first tab\n</code></pre> <p>There are shortcut methods to access the current sub-window and the underlying data model.</p> <pre><code>ui.current_window  # The current sub-window\nui.current_model  # The current data model\n</code></pre>"},{"location":"usage/tab_and_window/#adding-tabs-and-sub-windows","title":"Adding Tabs and Sub-windows","text":"<p>To add a new tab, use <code>ui.add_tab</code> method.</p> <pre><code>ui.add_tab()\nui.add_tab(\"new tab\")  # with a name\n</code></pre> <p>Both main window and tab have methods of same names to add sub-windows. If a method is called from the main window, sub-window will be added to the current tab, or to a new tab if there is no tab.</p> <pre><code># add array object to the current tab\nui.add_object(np.arange(10), type=\"array\", title=\"my array\")\n\n# add array object to the current tab\nui.tabs[0].add_object(np.arange(10), type=\"array\", title=\"my array\")\n\n# add a WidgetDataModel\nmodel = WidgetDataModel(value=np.arange(10), type=\"array\", title=\"my array\")\nui.add_data_model(model)\n\n# add any Qt widget\nfrom qtpy.QtWidgets import QPushButton\n\nui.add_widget(QPushButton(\"Hello, world!\"))\n\n# add a magicgui widget\nfrom magicgui.widgets import LineEdit\n\nui.add_magicgui(LineEdit(name=\"name\", value=\"abc\"))\n</code></pre>"},{"location":"usage/tab_and_window/#access-to-the-data-and-widget-states","title":"Access to the Data and Widget States","text":"<p>Basically, the sub-window state is obtained by a <code>WidgetDataModel</code>.</p> <pre><code>win = ui.add_object(\"abc\", type=\"text\", title=\"my text\")\nmodel = win.to_model()  # a WidgetDataModel object\nmodel.value  # \"abc\"\n</code></pre> <p>Widget states that are irrelevant to the data are stored in the <code>metadata</code> property. The type of this property differs between data types, and sometimes, widget types. In the case of text data, <code>TextMeta</code> object is used in the default widget.</p> <pre><code>model.metadata\n</code></pre> Output<pre><code>TextMeta(\n  language='Plain Text',\n  spaces=4,\n  selection=(0, 0),\n  font_family='Consolas',\n  font_size=10.0,\n  encoding='utf-8',\n)\n</code></pre>"},{"location":"usage/tab_and_window/#closing-tabs-and-sub-windows","title":"Closing Tabs and Sub-windows","text":"<p>Tabs and sub-windows can be closed by <code>del</code>.</p> <pre><code>del ui.tabs[0]  # close the first tab\ndel ui.tabs[0][1]  # close the second sub-window in the first tab\n</code></pre>"},{"location":"usage/tab_and_window/#resizing-and-moving-sub-windows","title":"Resizing and Moving Sub-windows","text":"<p>The geometry of sub-windows can be manipulated by <code>rect</code> property. It is a tuple-like <code>WindowRect</code> object.</p> <pre><code>win = ui.current_window\nwin.rect\n</code></pre> Output<pre><code>WindowRect(left=28, top=28, width=400, height=300)\n</code></pre> <pre><code>win.rect = (50, 40, 200, 250)  # update the geometry\n</code></pre> <p>If you only want to resize the window, you can use the <code>size</code> property.</p> <pre><code>win.size = (200, 250)  # resize the window\n</code></pre> <p>To move sub-windows, <code>WindowRect</code> object has several useful methods.</p> <ul> <li><code>move_top_left</code></li> <li><code>move_top_right</code></li> <li><code>move_bottom_left</code></li> <li><code>move_bottom_right</code></li> </ul> <p>These methods return a new <code>WindowRect</code> object with updated positions.</p> <pre><code>win.rect = win.rect.move_top_left(10, 20)\nwin.rect\n</code></pre> Output<pre><code>WindowRect(left=10, top=20, width=200, height=250)\n</code></pre>"},{"location":"usage/workflows/","title":"Workflows","text":"<p>A \"workflow\" is a record of the commands and parameters you used to create a data model. For complicated data analysis tasks, looking at the workflow will help you remember what you did.</p>"},{"location":"usage/workflows/#built-in-workflow-viewer","title":"Built-in Workflow Viewer","text":"<p><code>himena-builtins</code> subpackage provides a built-in workflow viewer. You can view the workflow of a sub-window</p>"}]}